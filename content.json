{"meta":{"title":"lbvs86823","subtitle":null,"description":null,"author":"lbvs86823","url":"https://lbvs86823.github.io"},"pages":[],"posts":[{"title":"centOS7 安装man中文手册","slug":"linux/install_man_CN","date":"2019-05-09T10:21:05.000Z","updated":"2020-03-20T06:27:43.649Z","comments":true,"path":"2019/05/09/linux/install_man_CN/","link":"","permalink":"https://lbvs86823.github.io/2019/05/09/linux/install_man_CN/","excerpt":"","text":"查找man中文语言手册安装包# yum list | grep man.*zh man-pages-zh-CN.noarch 1.5.2-4.el7 base 安装# yum -y install man-pages-zh-CN.noarch 配置编辑配置文件：vi ~/.bashrc，增加如下一行配置 # alias cman=&apos;man -M /usr/share/man/zh_CN&apos; -M 设置手册页的路径。注意，这是在对应用户的家目录（宿主目录）下写入的。如果要全局生效，可以在/etc/bashrc将这一行填入。 生效配置# source ~/.bashrc # cman ls # 测试效果","categories":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/tags/linux/"},{"name":"centOS","slug":"centOS","permalink":"https://lbvs86823.github.io/tags/centOS/"},{"name":"man","slug":"man","permalink":"https://lbvs86823.github.io/tags/man/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}]},{"title":"axios 中文文档","slug":"js/js_axios","date":"2018-10-12T02:12:21.000Z","updated":"2020-03-20T06:27:43.632Z","comments":true,"path":"2018/10/12/js/js_axios/","link":"","permalink":"https://lbvs86823.github.io/2018/10/12/js/js_axios/","excerpt":"","text":"一，概述Axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端(库)，可以用在浏览器和 node.js 中。本质上也是对原生XHR的封装，只不过它是 Promise 的实现版本，符合最新的ES规范，有以下一些特性： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF Axios 面向现代浏览器设计，所以古老的浏览器并不支持。因为 Axios 设计简洁，API简单，支持浏览器和node，所以大受欢迎。它能很好的与各种前端框架整合。 二，安装npm install axios // 使用 npm 安装 bower install axios // 使用 bower 安装 yarn add axios // 使用 yarn 安装 // 页面引入 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 三，使用案例1.执行GET请求const axios = require(&apos;axios&apos;); // 通过 ID 获取 user 创建请求 axios.get(&apos;/user?ID=12345&apos;) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 上面的请求也可以这样做 axios.get(&apos;/user&apos;, { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 2.执行POST请求const axios = require(&apos;axios&apos;); axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 3.执行多个并发请求const axios = require(&apos;axios&apos;); function getUserAccount() { return axios.get(&apos;/user/12345&apos;); } function getUserPermissions() { return axios.get(&apos;/user/12345/permissions&apos;); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 这里两个请求现在都执行完成了 })); 四，axios API 详解1.axios(config)可以通过将相关配置 config 对象传递给 axios 来发出请求 // 发送 POST 请求 axios({ method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; } }); // 获取远端图片 axios({ method:&apos;get&apos;, url:&apos;http://bit.ly/2mTM3nY&apos;, responseType:&apos;stream&apos; }) .then(function(response) { response.data.pipe(fs.createWriteStream(&apos;ada_lovelace.jpg&apos;)) }); 2.axios(url[, config])// 发送 GET 请求（默认的方法） axios(&apos;/user/12345&apos;); 五，请求方法别名为方便起见，为所有已经支持的请求方法提供了别名 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 六，处理并发请求 axios.all(iterable) axios.spread(callback) 七，创建实例1. axios.create([config])可以使用自定义配置新建一个 axios 实例 const instance = axios.create({ baseURL: &apos;https://some-domain.com/api/&apos;, timeout: 1000, headers: {&apos;X-Custom-Header&apos;: &apos;foobar&apos;} }); 2.实例方法以下是可用的实例方法。指定的配置将与实例的配置合并。 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#options(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) axios#getUri([config]) 八，请求配置 config这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // `url` 是用于请求的服务器 URL url: &apos;/user&apos;, // `method` 是创建请求时使用的方法 method: &apos;get&apos;, // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法上 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos; 上 // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: &apos;Fred&apos; }, // syntax alternative to send data into the body // method post // only the value is sent, not the key data: &apos;Country=Brasil&amp;City=Belo Horizonte&apos;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // default is `0` (no timeout) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; }, // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // default // `responseEncoding` 指示用于解码响应的编码 // 注意: 如果请求类型为 &apos;stream&apos; 或者客户端请求，则此设置将忽略 responseEncoding: &apos;utf8&apos;, // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` 设置带有 xsrf token 令牌值的http请求头名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // Do whatever you want with the native progress event }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. &apos;/var/run/docker.sock&apos; to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // &apos;proxy&apos; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: &apos;127.0.0.1&apos;, port: 9000, auth: { username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 九，响应结构某个请求的响应包含以下信息： { // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &apos;OK&apos;, // `headers` 服务器响应的头 headers: {}, // `config` 时为请求提供的配置信息 config: {}, // &apos;request&apos; // `request` is the request that generated this response // It is the last ClientRequest instance in node.js (in redirects) // and an XMLHttpRequest instance the browser request: {} } 使用 then 时，你将接收下面这样的响应 : axios.get(&apos;/user/12345&apos;) .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 十，配置默认值1.全局的 axios 默认值axios.defaults.baseURL = &apos;https://api.example.com&apos;; axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 2.自定义实例默认值// Set config defaults when creating the instance const instance = axios.create({ baseURL: &apos;https://api.example.com&apos; }); // Alter defaults after instance has been created instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 3.配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 `0` var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get(&apos;/longRequest&apos;, { timeout: 5000 }); 十一，拦截器在请求或响应被 then 或 catch 处理前拦截它们。 // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： const myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器： const instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 十二，错误处理axios.get(&apos;/user/12345&apos;) .catch(function (error) { if (error.response) { // The request was made and the server responded with a status code // that falls out of the range of 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else if (error.request) { // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js console.log(error.request); } else { // Something happened in setting up the request that triggered an Error console.log(&apos;Error&apos;, error.message); } console.log(error.config); }); 你还可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get(&apos;/user/12345&apos;, { validateStatus: function (status) { return status &lt; 500; // Reject only if the status code is greater than or equal to 500 } }) 十三，取消请求使用 cancel token 取消请求Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get(&apos;/user/12345&apos;, { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log(&apos;Request canceled&apos;, thrown.message); } else { // 处理错误 } }); axios.post(&apos;/user/12345&apos;, { name: &apos;new name&apos; }, { cancelToken: source.token }) // 取消请求（message 参数是可选的） source.cancel(&apos;Operation canceled by the user.&apos;); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： const CancelToken = axios.CancelToken; let cancel; axios.get(&apos;/user/12345&apos;, { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // cancel the request cancel(); 注意: 可以使用同一个 cancel token 取消多个请求 十四，其他1.参数处理默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。在浏览器中，您可以使用 URLSearchParams API，如下所示： const params = new URLSearchParams(); params.append(&apos;param1&apos;, &apos;value1&apos;); params.append(&apos;param2&apos;, &apos;value2&apos;); axios.post(&apos;/foo&apos;, params); 请注意，所有浏览器都不支持URLSearchParams（请参阅 caniuse.com），但可以使用 polyfill（确保填充全局环境）。 或者，您可以使用 qs 库编码数据： const qs = require(&apos;qs&apos;); axios.post(&apos;/foo&apos;, qs.stringify({ &apos;bar&apos;: 123 })); 或者以另一种方式（ES6）: import qs from &apos;qs&apos;; const data = { &apos;bar&apos;: 123 }; const options = { method: &apos;POST&apos;, headers: { &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; }, data: qs.stringify(data), url, }; axios(options); 在node.js中，您可以使用 querystring 模块，如下所示： const querystring = require(&apos;querystring&apos;); axios.post(&apos;http://something.com/&apos;, querystring.stringify({ foo: &apos;bar&apos; })); 您也可以使用 qs库。 2.浏览器Promise支持axios 依赖原生的 ES6 Promise 实现而被 支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. 3.TypeScript支持axios包括TypeScript定义。 import axios from &apos;axios&apos;; axios.get(&apos;/user?ID=12345&apos;); 更新详情你可以参考 官方文档","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"axios","slug":"axios","permalink":"https://lbvs86823.github.io/tags/axios/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"influxDB 入门指南","slug":"monitor/influxdb","date":"2018-07-11T02:03:27.000Z","updated":"2020-03-20T06:27:43.655Z","comments":true,"path":"2018/07/11/monitor/influxdb/","link":"","permalink":"https://lbvs86823.github.io/2018/07/11/monitor/influxdb/","excerpt":"","text":"I 前言1. 入门1.1 安装运行采用docker方式安装： docker search influxdb //搜索influxdb的相关镜像 docker pull influxdb //选择官方的最新版本 docker images //查看已经存在的镜像 挂在本地目录运行: influxdb的镜像默认 数据目录在 /var/lib/influxdb docker run -p 8086:8086 -v /workspace/influxdb_data:/var/lib/influxdb influxdb 1.2 相关配置influxdb 暴露了三个端口： 8086 ： 针对http api 请求接口暴露的端口 8083 ： 管理员接口，缺省不可用的，在1.3以后的版本已经移除 2003 : 针对Graphite的支持接口，缺省不可用 influxdb 既可以通过配置文件配置也可以使用环境变量来配置： 比如使用配置文件配置如下: docker run --rm influxdb influxd config &gt; /workspace/influxdb_data/config/influxdb.conf //形成一个缺省的配置文件 修改默认配置挂载一个外部配置文件： docker run -p 8086:8086 -v /workspace/influxdb_data/config/influxdb.conf:/etc/influxdb/influxdb.conf:ro influxdb -config /etc/influxdb/influxdb.conf 2. 配置文件解析配置文件详解: reporting-disabled = false # 该选项用于上报influxdb的使用信息给InfluxData公司，默认值为false bind-address = &quot;127.0.0.1:8088&quot; # 备份恢复时使用，默认值为8088 [meta] # meta相关配置 dir = &quot;/Users/libing/Documents/workspace/influxdb_data/meta&quot; # meta数据存放目录 retention-autocreate = true # 用于控制默认存储策略，数据库创建时，会自动生成autogen的存储策略，默认值：true logging-enabled = true # 是否开启meta日志，默认值：true [data] # data相关配置 dir = &quot;/Users/libing/Documents/workspace/influxdb_data/data&quot; # 最终数据（TSM文件）存储目录 index-version = &quot;inmem&quot; # 对于influxdb新产生的分片索引的类型将在这里被设置。初始默认的索引类型是一种 in-memory 索引，如果你修改成 tsi1 将会对于高基数数据支持的更好。（high-cardinality 是描述tag rentention-policy measurement组合成series规模的度量值） wal-dir = &quot;/Users/libing/Documents/workspace/influxdb_data/wal&quot; # 预写日志存储目录 wal-fsync-delay = &quot;0s&quot; validate-keys = false query-log-enabled = true # 是否开启tsm引擎查询日志，默认值： true cache-max-memory-size = 1073741824 # 用于限定shard最大值，大于该值时会拒绝写入，默认值：1000MB，单位：byte cache-snapshot-memory-size = 26214400 # 用于设置快照大小，大于该值时数据会刷新到tsm文件，默认值：25MB，单位：byte cache-snapshot-write-cold-duration = &quot;10m0s&quot; # tsm引擎 snapshot写盘延迟，默认值：10Minute compact-full-write-cold-duration = &quot;4h0m0s&quot; # tsm文件在压缩前可以存储的最大时间，默认值：4Hour compact-throughput = 50331648 compact-throughput-burst = 50331648 max-series-per-database = 1000000 # 限制数据库的级数，该值为0时取消限制，默认值：1000000 max-values-per-tag = 100000 # 一个tag最大的value数，0取消限制，默认值：100000 max-concurrent-compactions = 0 max-index-log-file-size = 1048576 trace-logging-enabled = false tsm-use-madv-willneed = false [coordinator] # coordinator查询管理的配置选项 write-timeout = &quot;10s&quot; # 写操作超时时间，默认值： 10s max-concurrent-queries = 0 # 最大并发查询数，0无限制，默认值： 0 query-timeout = &quot;0s&quot; # 查询操作超时时间，0无限制，默认值：0s log-queries-after = &quot;0s&quot; # 慢查询超时时间，0无限制，默认值：0s max-select-point = 0 # SELECT语句可以处理的最大点数（points），0无限制，默认值：0 max-select-series = 0 # SELECT语句可以处理的最大级数（series），0无限制，默认值：0 max-select-buckets = 0 # SELECT语句可以处理的最大&quot;GROUP BY time()&quot;的时间周期，0无限制，默认值：0 [retention] # 旧数据的保留策略 enabled = true # 是否启用该模块，默认值 ： true check-interval = &quot;30m0s&quot; # 检查时间间隔，默认值 ：&quot;30m&quot; [shard-precreation] # 分区预创建 enabled = true # 是否启用该模块，默认值 ： true check-interval = &quot;10m0s&quot; # 检查时间间隔，默认值 ：&quot;10m&quot; advance-period = &quot;30m0s&quot; # 预创建分区的最大提前时间，默认值 ：&quot;30m&quot; [monitor] # 控制InfluxDB自有的监控系统。 默认情况下，InfluxDB把这些数据写入_internal 数据库，如果这个库不存在则自动创建。 _internal 库默认的retention策略是7天，如果你想使用一个自己的retention策略，需要自己创建。 store-enabled = true # 是否启用该模块，默认值 ：true store-database = &quot;_internal&quot; # 默认数据库：&quot;_internal&quot; store-interval = &quot;10s&quot; # 统计间隔，默认值：&quot;10s&quot; [subscriber] # 控制Kapacitor接受数据的配置 enabled = true # 是否启用该模块，默认值 ：true http-timeout = &quot;30s&quot; # http超时时间，默认值：&quot;30s&quot; insecure-skip-verify = false # 是否允许不安全的证书 ca-certs = &quot;&quot; # 设置CA证书 write-concurrency = 40 # 设置并发数目，默认值：40 write-buffer-size = 1000 # 设置buffer大小，默认值：1000 [http] # http API enabled = true # 是否启用该模块，默认值 ：true bind-address = &quot;:8086&quot; # 绑定地址，默认值：&quot;:8086&quot; auth-enabled = false # 是否开启认证，默认值：false log-enabled = true # 是否开启日志，默认值：true suppress-write-log = false write-tracing = false # 是否开启写操作日志，如果置成true，每一次写操作都会打日志，默认值：false flux-enabled = false # 是否开启pprof，默认值：true pprof-enabled = true debug-pprof-enabled = false https-enabled = false # 是否开启https，默认值：false https-certificate = &quot;/etc/ssl/influxdb.pem&quot; # 设置https证书路径，默认值：&quot;/etc/ssl/influxdb.pem&quot; https-private-key = &quot;&quot; # 设置https私钥，无默认值 max-row-limit = 0 # 配置查询返回最大行数，0无限制，默认值：0 max-connection-limit = 0 # 配置最大连接数，0无限制，默认值：0 shared-secret = &quot;&quot; # 用于JWT签名的共享密钥，无默认值 realm = &quot;InfluxDB&quot; unix-socket-enabled = false # 是否使用unix-socket，默认值：false unix-socket-permissions = &quot;0777&quot; bind-socket = &quot;/var/run/influxdb.sock&quot; # unix-socket路径，默认值：&quot;/var/run/influxdb.sock&quot; max-body-size = 25000000 access-log-path = &quot;&quot; max-concurrent-write-limit = 0 max-enqueued-write-limit = 0 enqueued-write-timeout = 30000000000 [logging] format = &quot;auto&quot; level = &quot;info&quot; suppress-logo = false [[graphite]] # graphite 相关配置 enabled = false # 是否启用该模块，默认值 ：false bind-address = &quot;:2003&quot; # 绑定地址，默认值：&quot;:2003&quot; database = &quot;graphite&quot; # 数据库名称，默认值：&quot;graphite&quot; retention-policy = &quot;&quot; # 存储策略，无默认值 protocol = &quot;tcp&quot; # 协议，默认值：&quot;tcp&quot; batch-size = 5000 # 批量size，默认值：5000 batch-pending = 10 # 配置在内存中等待的batch数，默认值：10 batch-timeout = &quot;1s&quot; # 超时时间，默认值：&quot;1s&quot; consistency-level = &quot;one&quot; # 一致性级别，默认值：&quot;one separator = &quot;.&quot; # 多个measurement间的连接符，默认值： &quot;.&quot; udp-read-buffer = 0 # udp读取buffer的大小，0表示使用操作系统提供的值，如果超过操作系统的默认配置则会出错。 该配置的默认值：0 [[collectd]] enabled = false bind-address = &quot;:25826&quot; database = &quot;collectd&quot; retention-policy = &quot;&quot; batch-size = 5000 batch-pending = 10 batch-timeout = &quot;10s&quot; read-buffer = 0 typesdb = &quot;/usr/share/collectd/types.db&quot; security-level = &quot;none&quot; auth-file = &quot;/etc/collectd/auth_file&quot; parse-multivalue-plugin = &quot;split&quot; [[opentsdb]] enabled = false bind-address = &quot;:4242&quot; database = &quot;opentsdb&quot; retention-policy = &quot;&quot; consistency-level = &quot;one&quot; tls-enabled = false certificate = &quot;/etc/ssl/influxdb.pem&quot; batch-size = 1000 batch-pending = 5 batch-timeout = &quot;1s&quot; log-point-errors = true [[udp]] enabled = false bind-address = &quot;:8089&quot; database = &quot;udp&quot; retention-policy = &quot;&quot; batch-size = 5000 batch-pending = 10 read-buffer = 0 batch-timeout = &quot;1s&quot; precision = &quot;&quot; [continuous_queries] log-enabled = true enabled = true query-stats-enabled = false run-interval = &quot;1s&quot; [tls] min-version = &quot;&quot; max-version = &quot;&quot;","categories":[{"name":"database","slug":"database","permalink":"https://lbvs86823.github.io/categories/database/"}],"tags":[{"name":"monitor","slug":"monitor","permalink":"https://lbvs86823.github.io/tags/monitor/"},{"name":"influxdb","slug":"influxdb","permalink":"https://lbvs86823.github.io/tags/influxdb/"}],"keywords":[{"name":"database","slug":"database","permalink":"https://lbvs86823.github.io/categories/database/"}]},{"title":"js 标准内置对象之 Promise (控制抽象对象)","slug":"js/js_promise","date":"2018-06-22T03:42:51.000Z","updated":"2020-03-20T06:27:43.636Z","comments":true,"path":"2018/06/22/js/js_promise/","link":"","permalink":"https://lbvs86823.github.io/2018/06/22/js/js_promise/","excerpt":"","text":"一，概述Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象。 一个 Promise 有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法，所以在异步操作的完成和绑定处理方法之间不存在竞争）。因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回 promise 对象， 所以它们可以被链式调用。注意： 如果一个 promise 对象处在 fulfilled 或 rejected 状态而不是 pending 状态，那么它也可以被称为 settled 状态。你可能也会听到一个术语resolved ，它表示 promise 对象处于 settled 状态。 二，语法规则new Promise( function(resolve, reject) {...} /* executor */ ); executor 是带有 resolve 和 reject 两个参数的函数 。Promise 构造函数执行时立即调用 executor 函数， resolve 和 reject 两个函数作为参数传递给 executor（executor 函数在 Promise 构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将 promise的状态改为 fulfilled（完成）或 rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用 resolve函数来将 promise 状态改成 fulfilled，要么调用 reject 函数将 promise 的状态改为 rejected。如果在 executor 函数中抛出一个错误，那么该 promise 状态为 rejected。 executor 函数的返回值被忽略。 三，对象属性1.Promise.lengthlength属性，其值总是为 1 (构造器参数的数目). 2.Promise.prototype表示 Promise 构造器的原型. 四，对象方法1.Promise.all(iterable)这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法） 2.Promise.race(iterable)当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 3.Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 4.Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 五，Promise 原型1.属性Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. 2.方法Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.finally(onFinally)添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected) 六，使用案例1.创建PromisePromise 对象是由关键字 new 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。 const myFirstPromise = new Promise((resolve, reject) =&gt; { // ?做一些异步操作，最终会调用下面两者之一: // // resolve(someValue); // fulfilled // ?或 // reject(&quot;failure reason&quot;); // rejected }); 想要某个函数?拥有promise功能，只需让其返回一个promise即可。 function myAsyncFunction(url) { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onload = () =&gt; resolve(xhr.responseText); xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(); }); }; 2.基础示例let myFirstPromise = new Promise(function(resolve, reject){ //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. setTimeout(function(){ resolve(&quot;成功!&quot;); //代码正常执行！ }, 250); }); myFirstPromise.then(function(successMessage){ //successMessage的值是上面调用resolve(...)方法传入的值. //successMessage参数不一定非要是字符串类型，这里只是举个例子 console.log(&quot;Yay! &quot; + successMessage); }); 3.高级示例本例展示了 Promise 的一些机制。 testPromise() 方法在每次点击 &lt;button&gt; 按钮时被调用，该方法会创建一个promise 对象，使用 window.setTimeout() 让Promise等待 1-3 秒不等的时间来填充数据（通过Math.random()方法）。 Promise 的值的填充过程都被日志记录（logged）下来，这些日志信息展示了方法中的同步代码和异步代码是如何通过Promise完成解耦的。 &apos;use strict&apos;; var promiseCount = 0; function testPromise() { let thisPromiseCount = ++promiseCount; let log = document.getElementById(&apos;log&apos;); log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount + &apos;) 开始 (&lt;small&gt;同步代码开始&lt;/small&gt;)&lt;br/&gt;&apos;); // 新构建一个 Promise 实例：使用Promise实现每过一段时间给计数器加一的过程，每段时间间隔为1~3秒不等 let p1 = new Promise( // resolver 函数在 Promise 成功或失败时都可能被调用 (resolve, reject) =&gt; { log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount + &apos;) Promise 开始 (&lt;small&gt;异步代码开始&lt;/small&gt;)&lt;br/&gt;&apos;); // 创建一个异步调用 window.setTimeout( function() { // 填充 Promise resolve(thisPromiseCount); }, Math.random() * 2000 + 1000); } ); // Promise 不论成功或失败都会调用 then // catch() 只有当 promise 失败时才会调用 p1.then( // 记录填充值 function(val) { log.insertAdjacentHTML(&apos;beforeend&apos;, val + &apos;) Promise 已填充完毕 (&lt;small&gt;异步代码结束&lt;/small&gt;)&lt;br/&gt;&apos;); }) .catch( // 记录失败原因 (reason) =&gt; { console.log(&apos;处理失败的 promise (&apos;+reason+&apos;)&apos;); }); log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount + &apos;) Promise made (&lt;small&gt;同步代码结束&lt;/small&gt;)&lt;br/&gt;&apos;); } 4.使用 XHR 加载图像另一个用了 Promise 和 XMLHttpRequest 加载一个图像的例子可在MDN GitHub promise-test 中找到。 你也可以看这个实例。每一步都有注释可以让你详细的了解Promise和XHR架构。 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"promise","slug":"promise","permalink":"https://lbvs86823.github.io/tags/promise/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"《Spring Session 中文手册》 之 第九章 API 文档","slug":"spring/spring_session_api","date":"2018-05-18T04:15:12.000Z","updated":"2021-08-09T01:11:35.042Z","comments":true,"path":"2018/05/18/spring/spring_session_api/","link":"","permalink":"https://lbvs86823.github.io/2018/05/18/spring/spring_session_api/","excerpt":"","text":"第九章 API 文档你可以浏览完整的 Javadoc 在线文档，下面是一些关键API的说明： SessionSessionRepositoryFindByIndexNameSessionRepositoryReactiveSessionRepository@EnableSpringHttpSession@EnableSpringWebSessionRedisIndexedSessionRepositoryReactiveRedissSessionRepositoryMapSessionRepositoryReactiveMapSessionRepositoryJdbcIndexedSessionRepositoryHazelcastIndexedSessionRepositoryCookieSerializer 9.1 Session 的使用实际上 一个 Session 就是一个 key-value 键值对Map的实现。比较典型的使用方法如下： public class RepositoryDemo&lt;S extends Session&gt; { private SessionRepository&lt;S&gt; repository; public void demo() { # 创建Session S toSave = this.repository.createSession(); # 设置过期时间 toSave.setMaxInactiveInterval(Duration.ofSeconds(30)); # 保存属性值到session User rwinch = new User(&quot;rwinch&quot;); toSave.setAttribute(ATTR_USER, rwinch); # 保存session this.repository.save(toSave); # 取回session S session = this.repository.findById(toSave.getId()); # 从session中取回属性 User user = session.getAttribute(ATTR_USER); assertThat(user).isEqualTo(rwinch); } // ... setter methods ... } 9.2 SessionRepositroy 的使用SessionRepositroy 负责 sesion 实例的创建，取回，持久化。一般你不应该和 SessionRepositroy， session直接打交道；相反，开发人员一般是通过HttpSession 和 WebSocket 与 SessionRepository 和 Session 进行间接交互的。 9.3 FindByIndexNameSessionRepository 的使用SessionRepository 提供了操作(增删改查) Session 的基本API，因此你可以很容易的基于这个接口增加额外的功能实现。FindByIndexNameSessionRepository 提供了一个通过给定的索引名和索引值来查找所有的session的方法(findByIndexNameAndIndexValue)。这个方法依赖于你的程序用用户名填充 session中以 FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME 为key的值 String username = &quot;username&quot;; this.session.setAttribute(FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username); 当session被保存后，你可以通过下面的方法查找到session： String username = &quot;username&quot;; Map&lt;String, Session&gt; sessionIdToSession = this.sessionRepository.findByPrincipalName(username); 9.4 ReactiveSessionRepository 的使用ReactiveSessionRepository 负责非阻塞响应式的 sesion 实例的创建，取回，持久化。一般你不应该和 ReactiveSessionRepository， session直接打交道；相反，开发人员一般是通过WebSession 与 ReactiveSessionRepository 和 Session 进行间接交互的。 9.5 @EnableSpringHttpSession 的使用你可以增加一个 @EnableSpringHttpSession 注解到配置类(包含有 @Configuration 的注解)上面，会暴露一个类SessionRepositoryFilter的名字叫 springSessionRepositoryFilter 的bean，为了使用它，你必须提供一个单例的 SessionRepository bean 如下： @EnableSpringHttpSession @Configuration public class SpringHttpSessionConfig { @Bean public MapSessionRepository sessionRepository() { return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); } } 9.6 @EnableSpringWebSession 的使用你可以增加一个 @EnableSpringWebSession 注解到配置类(包含有 @Configuration 的注解)上面，会暴露一个类WebSessionManager的名字叫 webSessionManager 的bean，为了使用它，你必须提供一个单例的 ReactiveSessionRepository bean 如下： @EnableSpringWebSession public class SpringWebSessionConfig { @Bean public ReactiveSessionRepository reactiveSessionRepository() { return new ReactiveMapSessionRepository(new ConcurrentHashMap&lt;&gt;()); } } 9.7 RedisIndexedSessionRepository 的使用RedisIndexedSessionRepository 使用 spring data 的 RedisOperations 对 SessionRepository 接口进行了redis的实现。在web环境中，通常与SessionRepositoryFilter 结合使用，并且这个实现支持通过 SessionMessageListener 监听 SessionCreatedEvent 和 SessionDestroyedEvent 事件。 9.7.1 使用 RedisIndexedSessionRepository下面是一个常用的创建实例的方法 RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // ... configure redisTemplate ... SessionRepository&lt;? extends Session&gt; repository = new RedisIndexedSessionRepository(redisTemplate); 9.7.2 使用 @EnableRedisHttpSession在web环境中，要想创建一个 RedisIndexedSessionRepository 的实例最简单的方式就是使用 @EnableRedisHttpSession,你可以找到完整的例子。你可以使用下列属性来自定义配置。 maxInactiveIntervalInSeconds ：会话过期时间，单位是秒。 redisNamespace ： 配置session在redis中的key前缀(用:分割)。 flushMode ： 设置session数据写入redis的时机。on_save: 等待response返回后再写入； immediate: 立即写入 自定义 RedisSerializer你可以自定义一个序列化bean名字叫 springSessionDefaultRedisSerializer 它实现了 RedisSerializer&lt;Object&gt; 接口。 9.7.3 使用 Redis TaskExecutorRedisIndexedSessionRepository订阅接受redis的事件通过使用监听容器 RedisMessageListenerContainer。你可以创建一个bean名叫 springSessionRedisTaskExecutor 或者 springSessionRedisSubscriptionExecutor 来自定义这些事件的分发调度机制。你可以在这里找到更多关于redis执行器的详细信息。 9.7.4 存储细节创建一个session：HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe \\ creationTime 1404360000000 \\ maxInactiveInterval 1800 \\ lastAccessedTime 1404360000000 \\ sessionAttr:attrName someAttrValue \\ sessionAttr2:attrName someAttrValue2 EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe &quot;&quot; EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe EXPIRE spring:session:expirations1439245080000 2100 保存一个session：每一个session保存到redis的时候，是用的哈希(Hash)结构来存储的session对象。 HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe \\ creationTime 1404360000000 \\ maxInactiveInterval 1800 \\ lastAccessedTime 1404360000000 \\ sessionAttr:attrName someAttrValue \\ sessionAttr2:attrName someAttrValue2 session Id 是 33fdd1b6-b496-4b33-9f7d-df96679d32fe creationTime 是创建session的时间，毫秒值 maxInactiveInterval 是session的过期时间，单位是秒(30分钟) lastAccessedTime 是最后一次的访问时间，毫秒值 下面2行是session中的键值对。 优化写入RedisIndexedSessionRepository 管理着session实例，并且跟踪着其属性的改变和更新。这就意味着，如果一个属性被写入一次并且被读取多次时，属性需要被写一次。比如上面的session属性sessionAttr2 保存时可以运行如下命令： HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe sessionAttr:attrName2 newValue session 过期通过使用 EXPIRE 命令， 根据 Session.getMaxInactiveInterval() 将过期与每个会话关联。 EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 过期时间通常设置来比实际过期时间晚5分钟，这样做可以使当session过期了，还可以访问到session的值。也可以确保在session过期时，我们在执行必要的处理工作后再清楚session。注意： SessionRepository.findById(String) 方法确保了一个没有过期的session被返回，这意味着你没有必要在使用session前再去检查它是否过期了。 Spring session 依赖于redis的 delete 和 expired keyspace notifications 触发 SessionDeletedEvent，SessionExpiredEvent 事件。这个2个事件确保与其关联的数据从redis中清除。例如：你使用了spring的 session websockect，redis的 delete 和 expired 事件触发任何与之关联的websocket 连接被关闭。 过期并不会跟踪 session key 本身，只是意味着session中的数据将不在可用而已。相反，一个特殊的 session 过期key被用来标识过期，比如上面的过期key如下： APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe &quot;&quot; EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 当一个session 过期key 被 delete 或者 expired 时， keyspace notification 将触发去查找实际的session，并且触发一个SessionDestroyedEvent事件。 如果key没有被访问，redis无法保证何时触发expired事件，具体来说，redis用来清理过期key的后台任务是低优先级的任务，可能不会触发key过期的事件。为了处理过期事件不一定会被触发的事实，我们可以确保每一个可以在预期要过期时都被访问到，这样key过期时，redis就会删除这个key了，并且在我们尝试访问可以时触发expired事件。 因此，每个会话过期时间也被跟踪最后一分钟，这样允许后台任务访问可能过期的会话，以确保以更确定的方式触发redis的过期事件。 SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe EXPIRE spring:session:expirations1439245080000 2100 后台任务使用这些显示的请求每一个key，通过访问它，而不是删除它，确保redis在key ttl 过期时，为我们删除key。 9.7.5 SessionDeletedEvent and SessionExpiredEvent","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"session","slug":"session","permalink":"https://lbvs86823.github.io/tags/session/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"Spring Session 之 Redis 实现","slug":"spring/spring_session_redis","date":"2018-05-18T04:15:12.000Z","updated":"2021-08-09T01:11:35.043Z","comments":true,"path":"2018/05/18/spring/spring_session_redis/","link":"","permalink":"https://lbvs86823.github.io/2018/05/18/spring/spring_session_redis/","excerpt":"","text":"@EnableRedisHttpSessionspringSessionRepositoryFilter ： 该过滤器实现了从 spring session 取代 httpSession。RedisConnectionFactoryHttpServletRequestWrapper # session 的存储方式 支持 jdbc, redis, hazelcast, mongodb, none spring.session.store-type=redis # none: 禁用 spring session # 设置session的超时时间 spring.session.timeout= 1m # 如果没设置就自动去取 server.servlet.session.timeout 设置的值 # 设置 redis session 的保存机制 spring.session.redis.flush-mode=on-save # 设置 在redis中key的打头字符串 spring.session.redis.namespace=spring:session # 配置连接redis的信息 spring.redis.host=localhost spring.redis.password= spring.redis.port=6379 # 清理redis中的数据 $ redis-cli keys &apos;*&apos; | xargs redis-cli del spring session 在redis中的存储格式1) &quot;spring:session:expirations:1585404180000&quot; 2) &quot;spring:session:index:org.springframework.session.FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME:admin&quot; 3) &quot;spring:session:sessions:b10234b4-8027-478c-8196-7f65f56a6cd9&quot; 4) &quot;spring:session:sessions:expires:b10234b4-8027-478c-8196-7f65f56a6cd9&quot; spring.session.jdbc.table-name=SESSIONS session 监听SessionCreatedEventSessionDestroyedEventSessionEventHttpSessionListenerAdapter @Bean public HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); }","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"session","slug":"session","permalink":"https://lbvs86823.github.io/tags/session/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"Spring Security 参考指南","slug":"spring/sping security reference","date":"2018-04-11T14:09:21.000Z","updated":"2020-03-20T06:27:43.677Z","comments":true,"path":"2018/04/11/spring/sping security reference/","link":"","permalink":"https://lbvs86823.github.io/2018/04/11/spring/sping security reference/","excerpt":"","text":"#Spring Security 参考指南(5.0.4.RELEASE)# I 前言1. 入门2. 介绍3. Spring Security 5.0 的新特性4. 样例及其手册5. java 配置方式6. Security 命名空间配置7. 应用样例8. Spring Security 社区II 架构和实现9. 技术概览9.1 运行环境Spring Security 3.0 要求java版本1.5或以上，Spring Security 旨在作为一个独立的容器运行，因此不需要任何特殊的配置放到你的java运行时环境，尤其是，不需要配置特殊的java身份验证和授权服务（JAAS）策略文件，也不需要将Spring Security 放入常见的类路径中。 同样，如果您使用的是EJB容器或Servlet容器，则不需要在任何地方放置任何特殊配置文件，也不需要将Spring Security包含在服务器类加载器中。 所有必需的文件都将包含在您的应用程序中。 这种设计提供了最大的部署时间灵活性，因为您可以简单地将目标工件（不管是JAR，WAR还是EAR）从一个系统复制到另一个系统，并立即生效。 9.2 核心组件在Spring Security 3.0中，spring-security-core.jar的内容被精简到最低限度。 它不再包含任何与Web应用程序安全性，LDAP或命名空间配置相关的代码。 我们来看看在核心模块中可以找到的一些Java类型。 它们代表了框架的构建块，所以如果您需要超越简单的名称空间配置，那么了解它们的含义非常重要，即使您实际上不需要直接与它们交互。 9.2.1 SecurityContextHolder, SecurityContext and Authentication Objects最基本的对象是SecurityContextHolder。这是我们存储应用程序当前安全上下文的详细信息的地方，其中包括当前使用该应用程序的主体的详细信息。默认情况下，SecurityContextHolder使用ThreadLocal来存储这些细节，这意味着即使安全上下文没有显式作为参数传递给这些方法，安全上下文也始终可用于同一执行线程中的方法。以这种方式使用ThreadLocal是相当安全的，因为如果在处理当前委托人的请求之后谨慎清除线程，那么它是非常安全的。当然，Spring Security会自动为您处理，因此您无需担心。 有些应用程序并不完全适合使用ThreadLocal，因为它们使用线程的具体方式。例如，Swing客户端可能希望Java虚拟机中的所有线程使用相同的安全上下文。可以在启动时使用策略配置SecurityContextHolder，以指定如何存储上下文。对于独立应用程序，您可以使用SecurityContextHolder.MODE_GLOBAL策略。其他应用程序可能希望安全线程产生的线程也具有相同的安全身份。这是通过使用SecurityContextHolder.MODE_INHERITABLETHREADLOCAL实现的。您可以通过两种方式从默认的SecurityContextHolder.MODE_THREADLOCAL更改模式。第一个是设置系统属性，第二个是在SecurityContextHolder上调用一个静态方法。大多数应用程序不需要改变默认值，但是如果你这样做了，请查看JavaDoc for SecurityContextHolder以了解更多信息。 10. 核心服务III 测试11. 测试方法安全12. Spring MVC 继承测试13. WebFlux 支持IV Web 应用安全14. Security 过滤器链15. 核心的Security过滤器16. 继承Servlet API17. Basic 和 Digest 鉴权18. Remember-Me 鉴权19. CSRF(Crosss Site Request Forgery) 跨站请求伪造20. CORS(Cross-origin resource sharing)跨域资源共享21. Security HTTP 响应请求头22. Session 管理23. Anonymous 鉴权24. WebSocket 安全V 鉴权25. 鉴权架构26. Secure 对象实现27. 基于表达式的权限控制VI 附加主题28. 域名安全29. 预认证方案30. LDAP 鉴权31. OAuth2.0 登录(高级配置)32. JSP 标签库33. JAAS(Java Authentication and Authorization Service)java的认证和授权服务34. CAS 鉴权35. X.509 鉴权36. Run-As 鉴权切换37. Crypto 模块38. 并发支持39. 整合Spring MVCVII Spring Data 整合40. Spring Data 整合 Security的配置41. @Query 安全表达式VIII 附录42. Security的数据库Schema43. Security 命名空间44. Spring Security 相关依赖45. 代理服务配置46. Spring Security FAQ","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"security","slug":"security","permalink":"https://lbvs86823.github.io/tags/security/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"js 之 解构赋值","slug":"js/js_destructuring_assignment","date":"2018-01-16T06:15:35.000Z","updated":"2020-03-20T06:27:43.634Z","comments":true,"path":"2018/01/16/js/js_destructuring_assignment/","link":"","permalink":"https://lbvs86823.github.io/2018/01/16/js/js_destructuring_assignment/","excerpt":"","text":"一.概述解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将 属性/值 从 对象/数组 中取出,赋值 给其他变量。 二.语法规则var a, b, rest; [a, b] = [10, 20]; console.log(a); // 10 console.log(b); // 20 [a, b, ...rest] = [10, 20, 30, 40, 50]; console.log(a); // 10 console.log(b); // 20 console.log(rest); // [30, 40, 50] ({ a, b } = { a: 10, b: 20 }); console.log(a); // 10 console.log(b); // 20 // Stage 4（已完成）提案中的特性 ({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}); console.log(a); // 10 console.log(b); // 20 console.log(rest); // {c: 30, d: 40} 三.示例I.解构数组1.变量声明并赋值时的解构var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]; var [x, y, z] = foo; console.log(x); // &quot;one&quot; console.log(y); // &quot;two&quot; console.log(z); // &quot;three&quot; 2.变量先声明后赋值时的解构var a, b; [a, b] = [1, 2]; console.log(a); // 1 console.log(b); // 2 3.默认值为了防止从数组中取出一个值为undefined的对象，可以在表达式左边的数组中为任意对象预设默认值。 var a, b; [a=5, b=7] = [1]; console.log(a); // 1 console.log(b); // 7 4.交换变量在一个解构表达式中可以交换两个变量的值。没有解构赋值的情况下，交换两个变量需要一个临时变量。 var a = 1; var b = 3; [a, b] = [b, a]; console.log(a); // 3 console.log(b); // 1 5.解析一个从函数返回的数组从一个函数返回一个数组是十分常见的情况。解构使得处理返回值为数组时更加方便。在下面例子中，要让 [1, 2] 成为函数的 f() 的输出值，可以使用解构在一行内完成解析。 function f() { return [1, 2]; } var a, b; [a, b] = f(); console.log(a); // 1 console.log(b); // 2 6.忽略某些返回值function f() { return [1, 2, 3]; } var [a, , b] = f(); console.log(a); // 1 console.log(b); // 3 [,,] = f(); // 你也可以忽略全部返回值 7.将剩余数组赋值给一个变量当解构一个数组时，可以使用剩余模式，将数组剩余部分赋值给一个变量。 var [a, ...b] = [1, 2, 3]; console.log(a); // 1 console.log(b); // [2, 3] 注意：如果剩余元素右侧有逗号，会抛出 SyntaxError，因为剩余元素必须是数组的最后一个元素。 8.用正则表达式匹配提取值用正则表达式的 exec() 方法匹配字符串会返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串——如果不需要的话。 function parseProtocol(url) { var parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url); if (!parsedURL) { return false; } console.log(parsedURL); // [&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/Web/JavaScript&quot;] var [, protocol, fullhost, fullpath] = parsedURL; return protocol; } console.log(parseProtocol(&apos;https://developer.mozilla.org/en-US/Web/JavaScript&apos;)); // &quot;https&quot; II.解构对象1.基本赋值var o = {p: 42, q: true}; var {p, q} = o; console.log(p); // 42 console.log(q); // true 2.无声明赋值一个变量可以独立于其声明进行解构赋值。 var a, b; ({a, b} = {a: 1, b: 2}); 注意：赋值语句周围的圆括号 ( ... ) 在使用对象字面量无声明解构赋值时是必须的。{a, b} = {a: 1, b: 2} 不是有效的独立语法，因为左边的 {a, b} 被认为是一个块而不是对象字面量。然而，({a, b} = {a: 1, b: 2}) 是有效的，正如 var {a, b} = {a: 1, b: 2}你的 ( ... ) 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。 3.给新的变量名赋值可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。 var o = {p: 42, q: true}; var {p: foo, q: bar} = o; console.log(foo); // 42 console.log(bar); // true 4.默认值变量可以先赋予默认值。当要提取的对象没有对应的属性，变量就被赋予默认值。 var {a = 10, b = 5} = {a: 3}; console.log(a); // 3 console.log(b); // 5 5.给新的变量命名并提供默认值一个属性可以同时: 从一个对象解构，并分配给一个不同名称的变量分配一个默认值，以防未解构的值是 undefined。 var {a:aa = 10, b:bb = 5} = {a: 3}; console.log(aa); // 3 console.log(bb); // 5 6.函数参数默认值ES5 版本 function drawES5Chart(options) { options = options === undefined ? {} : options; var size = options.size === undefined ? &apos;big&apos; : options.size; var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords; var radius = options.radius === undefined ? 25 : options.radius; console.log(size, cords, radius); // now finally do some chart drawing } drawES5Chart({ cords: { x: 18, y: 30 }, radius: 30 }); ES2015 版本 function drawES2015Chart({size = &apos;big&apos;, cords = { x: 0, y: 0 }, radius = 25} = {}){ console.log(size, cords, radius); // do some chart drawing } drawES2015Chart({ cords: { x: 18, y: 30 }, radius: 30 }); 在上面的 drawES2015Chart 的函数签名中，解构的左手边被分配给右手边的空对象字面值：{size = &#39;big&#39;, cords = {x: 0, y: 0}, radius = 25} = {}。你也可以在没有右侧分配的情况下编写函数。但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用 drawES2015Chart() 而不提供任何参数。如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。 7.解构嵌套对象和数组const metadata = { title: &apos;Scratchpad&apos;, translations: [ { locale: &apos;de&apos;, localization_tags: [], last_edit: &apos;2014-04-14T08:43:37&apos;, url: &apos;/de/docs/Tools/Scratchpad&apos;, title: &apos;JavaScript-Umgebung&apos; } ], url: &apos;/en-US/docs/Tools/Scratchpad&apos; }; let { title: englishTitle, // rename translations: [ { title: localeTitle, // rename }, ], } = metadata; console.log(englishTitle); // &quot;Scratchpad&quot; console.log(localeTitle); // &quot;JavaScript-Umgebung&quot; 8.For of 迭代和解构var people = [ { name: &apos;Mike Smith&apos;, family: { mother: &apos;Jane Smith&apos;, father: &apos;Harry Smith&apos;, sister: &apos;Samantha Smith&apos; }, age: 35 }, { name: &apos;Tom Jones&apos;, family: { mother: &apos;Norah Jones&apos;, father: &apos;Richard Jones&apos;, brother: &apos;Howard Jones&apos; }, age: 25 } ]; for (var {name: n, family: {father: f}} of people) { console.log(&apos;Name: &apos; + n + &apos;, Father: &apos; + f); } // &quot;Name: Mike Smith, Father: Harry Smith&quot; // &quot;Name: Tom Jones, Father: Richard Jones&quot; 9.从作为函数实参的对象中提取数据function userId({id}) { return id; } function whois({displayName: displayName, fullName: {firstName: name}}){ console.log(displayName + &quot; is &quot; + name); } var user = { id: 42, displayName: &quot;jdoe&quot;, fullName: { firstName: &quot;John&quot;, lastName: &quot;Doe&quot; } }; console.log(&quot;userId: &quot; + userId(user)); // &quot;userId: 42&quot; whois(user); // &quot;jdoe is John&quot; 这段代码从 user 对象中提取并输出 id、displayName 和 firstName。 10.对象属性计算名被解构let key = &quot;z&quot;; let { [key]: foo } = { z: &quot;bar&quot; }; console.log(foo); // &quot;bar&quot; 10.对象解构中的 Rest(剩余参数)将 rest 剩余参数语法添加到解构中。Rest 属性收集那些尚未被解构模式拾取的剩余可枚举属性键。 let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40} a; // 10 b; // 20 rest; // { c: 30, d: 40 } 11.无效的 JavaScript 标识符作为属性名称通过提供有效的替代标识符，解构可以与不是有效的JavaScript标识符的属性名称一起使用。 const foo = { &apos;fizz-buzz&apos;: true }; const { &apos;fizz-buzz&apos;: fizzBuzz } = foo; console.log(fizzBuzz); // &quot;true&quot; 12.解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）// 声明对象 和 自身 self 属性 var obj = {self: &apos;123&apos;}; // 在原型链中定义一个属性 prot obj.__proto__.prot = &apos;456&apos;; // test const {self, prot} = obj; // self &quot;123&quot; // prot &quot;456&quot;（访问到了原型链） 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"js 之 ... 剩余参数","slug":"js/js_rest_parameters","date":"2018-01-16T06:15:35.000Z","updated":"2020-03-20T06:27:43.636Z","comments":true,"path":"2018/01/16/js/js_rest_parameters/","link":"","permalink":"https://lbvs86823.github.io/2018/01/16/js/js_rest_parameters/","excerpt":"","text":"一.概述... 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 二.语法规则function(a, b, ...args) { // ... } 如果函数的最后一个命名参数以 ... 为前缀，则它将成为一个由剩余参数组成的真数组，其中从0（包括）到 args.length（排除）的元素由传递给函数的实际参数提供。在上面的例子中，args 将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。 1.剩余参数和 arguments 对象的区别剩余参数和 arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop。 arguments 对象还有一些附加的属性 （如 callee 属性）。 2.解构剩余参数剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。 function f(...[a, b, c]) { return a + b + c; } f(1) // NaN (b and c are undefined) f(1, 2, 3) // 6 f(1, 2, 3, 4) // 6 (the fourth parameter is not destructured) 3.从 arguments 到数组引入了剩余参数来减少由参数引起的样板代码。 // Before rest parameters, &quot;arguments&quot; could be converted to a normal array using: function f(a, b) { var normalArray = Array.prototype.slice.call(arguments); // -- or -- var normalArray = [].slice.call(arguments); // -- or -- var normalArray = Array.from(arguments); var first = normalArray.shift(); // OK, gives the first argument var first = arguments.shift(); // ERROR (arguments is not a normal array) } // Now we can easily gain access to a normal array using a rest parameter function f(...args) { var normalArray = args; var first = normalArray.shift(); // OK, gives the first argument } 为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。 function sortArguments() { var args = Array.prototype.slice.call(arguments); var sortedArgs = args.sort(); return sortedArgs; } console.log(sortArguments(5, 3, 7, 1)); // shows 1, 3, 5, 7 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"js 之 exprot 语法","slug":"js/js_export","date":"2018-01-16T05:05:35.000Z","updated":"2020-03-20T06:27:43.635Z","comments":true,"path":"2018/01/16/js/js_export/","link":"","permalink":"https://lbvs86823.github.io/2018/01/16/js/js_export/","excerpt":"","text":"一，语法概述在创建JavaScript模块时，export 语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。无论您是否声明，导出的模块都处于严格模式。 export 语句不能用在嵌入式脚本中。 二，语法规则// 导出单个特性 export let name1, name2, …, nameN; // let可以是变量(var) 或者 常量(const) export let name1 = …, name2 = …, …, nameN; // let可以是变量(var) 或者 常量(const) // 导出函数 export function FunctionName(){...} // 导出类 export class ClassName {...} // 导出列表 export { name1, name2, …, nameN }; // 重命名导出 export { variable1 as name1, variable2 as name2, …, nameN }; // 默认导出(变量， 常量， 类， 函数) export default expression; export default function (…) { … } // function可以是类(class) export default function name1(…) { … } // function可以是类(class) export { name1 as default, … }; // 聚合模块 export * from …; export { name1, name2, …, nameN } from …; export { import1 as name1, import2 as name2, …, nameN } from …; export { default } from …; nameN 要导出的标识符（以便其他脚本通过 import 语句进行导入）. 三，例子有两种不同的导出方式，命名导出和默认导出。你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。每种方式对应于上述的一种语法： 1.命名导出// 导出早前定义的函数 export { myFunction }; // 导出常量 export const foo = Math.sqrt(2); 2.默认导出export default function() {} // 默认导出函数 export default class {} // 默认导出类 export * from …; // 此语法不能从导入的模块导出默认导出值 export {default} from &apos;mod&apos;; //如果需要导出默认值时请使用此方法 在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称。但是，可以使用任何名称导入默认导出。 3.模块重定向如果我们想要在当前模块中，导出指定导入模块的默认导出（等于是创建了一个“重定向”） // module &quot;redirect-module.js&quot; export {default} from &apos;./other-module&apos;; export * from &apos;./other-module&apos;; 4.完整的导出与导入使用在模块中 “my-module.js” 中定义如下代码： function cube(x) { return x * x * x; } const foo = Math.PI + Math.SQRT2; var graph = { options: { color:&apos;white&apos;, thickness:&apos;2px&apos; }, draw: function() { console.log(&apos;From graph draw function&apos;); } } export { cube, foo, graph }; 在其它脚本中，我们可以这样使用它： // 在html中应使用带有module类型的script。 // 示例: // &lt;script type=&quot;module&quot; src=&quot;./demo.js&quot;&gt;&lt;/script&gt; // // 在http服务器上访问，否则将会有一个CORS保护报错。 // // script demo.js import { cube, foo, graph } from &apos;my-module.js&apos;; graph.options = { color:&apos;blue&apos;, thickness:&apos;3px&apos; }; graph.draw(); console.log(cube(3)); // 27 console.log(foo); // 4.555806215962888 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"js 之 箭头函数","slug":"js/js_arrow_functions","date":"2018-01-16T05:05:35.000Z","updated":"2020-03-20T06:27:43.631Z","comments":true,"path":"2018/01/16/js/js_arrow_functions/","link":"","permalink":"https://lbvs86823.github.io/2018/01/16/js/js_arrow_functions/","excerpt":"","text":"一，语法概述=&gt; 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super 或 new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 二，语法规则1.基础语法(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression //相当于：(param1, param2, …, paramN) =&gt; { return expression; } // 当只有一个参数时，圆括号是可选的： (singleParam) =&gt; { statements } singleParam =&gt; { statements } // 没有参数的函数应该写成一对圆括号。 () =&gt; { statements } 2.高级语法//加括号的函数体返回对象字面量表达式： params =&gt; ({foo: bar}) //支持剩余参数和默认参数 (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements } //同样支持参数列表解构 let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 三，例子引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。 1. 更短的函数var elements = [ &apos;Hydrogen&apos;, &apos;Helium&apos;, &apos;Lithium&apos;, &apos;Beryllium&apos; ]; elements.map(function(element) { return element.length; }); // 返回数组：[8, 6, 7, 9] // 上面的普通函数可以改写成如下的箭头函数 elements.map((element) =&gt; { return element.length; }); // 返回数组：[8, 6, 7, 9] // 当箭头函数只有一个参数时，可以省略参数的圆括号 elements.map(element =&gt; { return element.length; }); // 返回数组：[8, 6, 7, 9] // 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号 elements.map(element =&gt; element.length); // 返回数组：[8, 6, 7, 9] // 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构 // 需要注意的是字符串 `&quot;length&quot;` 是我们想要获得的属性的名称，而 `len` 则只是个变量名，可以替换成任意合法的变量名 elements.map(({ &quot;length&quot;: len }) =&gt; len); // 返回数组：[8, 6, 7, 9] 2.没有单独的 this在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值： 如果是该函数是一个构造函数， this 指针指向一个新的对象在严格模式下的函数调用下， this 指向 undefined如果是该函数是一个对象的方法，则它的 this 指针指向这个对象等等 This被证明是令人厌烦的面向对象风格的编程。 function Person() { // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() { // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; }, 1000); } var p = new Person(); 在ECMAScript 3/5中，通过将this值分配给封闭的变量，可以解决this问题。 function Person() { var that = this; that.age = 0; setInterval(function growUp() { // 回调引用的是`that`变量, 其值是预期的对象. that.age++; }, 1000); } 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： function Person(){ this.age = 0; setInterval(() =&gt; { this.age++; // |this| 正确地指向 p 实例 }, 1000); } var p = new Person(); 通过 call 或 apply 调用由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this），他们的第一个参数会被忽略。（这种现象对于 bind 方法同样成立） var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); } }; console.log(adder.add(1)); // 输出 2 console.log(adder.addThruCall(1)); // 仍然输出 2 3.不绑定 arguments箭头函数不绑定 Arguments 对象。因此，在本示例中，arguments 只是引用了封闭作用域内的 arguments var arguments = [1, 2, 3]; var arr = () =&gt; arguments[0]; arr(); // 1 function foo(n) { // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n, 即传给foo函数的第一个参数 var f = () =&gt; arguments[0] + n; return f(); } foo(1); // 2 foo(2); // 4 foo(3); // 6 foo(3,2);//6 在大多数情况下，使用剩余参数是相较使用 arguments 对象的更好选择。 function foo(arg) { var f = (...args) =&gt; args[0]; return f(arg); } foo(1); // 1 function foo(arg1,arg2) { var f = (...args) =&gt; args[1]; return f(arg1,arg2); } foo(1,2); //2 4.使用箭头函数作为方法箭头函数表达式对非方法函数是最合适的, 让我们看看当我们试着把它们作为方法时发生了什么。 &apos;use strict&apos;; var obj = { i: 10, b: () =&gt; console.log(this.i, this), c: function() { console.log( this.i, this) } } obj.b(); // undefined, Window{...} obj.c(); // 10, Object {...} 5.不能使用 new 操作符箭头函数不能用作构造器，和 new一起用会抛出错误。 var Foo = () =&gt; {}; var foo = new Foo(); // TypeError: Foo is not a constructor 6.不能使用 prototype 属性箭头函数没有prototype属性。 var Foo = () =&gt; {}; console.log(Foo.prototype); // undefined 7.不能使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。 8.函数体箭头函数可以有一个“简写体”或常见的“块体”。在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。 var func = x =&gt; x * x; // 简写函数 省略return var func = (x, y) =&gt; { return x + y; }; //常规编写 明确的返回值 9.返回对象字面量记住用 params =&gt; {object:literal} 这种简单的语法返回对象字面量是行不通的。 var func = () =&gt; { foo: 1 }; // Calling func() returns undefined! var func = () =&gt; { foo: function() {} }; // SyntaxError: function statement requires a name 这是因为花括号 {...} 里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。所以，记得用圆括号把对象字面量包起来： var func = () =&gt; ({foo: 1}); 10.换行箭头函数在参数和箭头之间不能换行。 var func = () =&gt; 1; // SyntaxError: expected expression, got &apos;=&gt;&apos; 但是，可以通过在 =&gt; 之后换行，或者用 ( )、{ } 来实现换行，如下： var func = (a, b, c) =&gt; 1; var func = (a, b, c) =&gt; ( 1 ); var func = (a, b, c) =&gt; { return 1 }; var func = ( a, b, c ) =&gt; 1; // 不会有语法错误 11.解析顺序虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 let callback; callback = callback || function() {}; // ok callback = callback || () =&gt; {}; // SyntaxError: invalid arrow-function arguments callback = callback || (() =&gt; {}); // ok 四.更多示例1.箭头函数也可以使用条件（三元）运算符var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15 simple(10); // 10 let max = (a, b) =&gt; a &gt; b ? a : b; 2.箭头函数也可以使用闭包// 标准的闭包函数 function A(){ var i=0; return function b(){ return (++i); }; }; var v=A(); v(); //1 v(); //2 //箭头函数体的闭包（ i=0 是默认参数） var Add = (i=0) =&gt; {return (() =&gt; (++i) )}; var v = Add(); v(); //1 v(); //2 //因为仅有一个返回，return 及括号（）也可以省略 var Add = (i=0)=&gt; ()=&gt; (++i); 3.箭头函数递归var fact = (x) =&gt; ( x==0 ? 1 : x*fact(x-1) ); fact(5); // 120 4.箭头函数内定义的变量及其作用域// 常规写法 var greeting = () =&gt; {let now = new Date(); return (&quot;Good&quot; + ((now.getHours() &gt; 17) ? &quot; evening.&quot; : &quot; day.&quot;));} greeting(); //&quot;Good day.&quot; console.log(now); // ReferenceError: now is not defined 标准的let作用域 // 参数括号内定义的变量是局部变量（默认参数） var greeting = (now=new Date()) =&gt; &quot;Good&quot; + (now.getHours() &gt; 17 ? &quot; evening.&quot; : &quot; day.&quot;); greeting(); //&quot;Good day.&quot; console.log(now); // ReferenceError: now is not defined // 对比：函数体内{}不使用var定义的变量是全局变量 var greeting = () =&gt; {now = new Date(); return (&quot;Good&quot; + ((now.getHours() &gt; 17) ? &quot; evening.&quot; : &quot; day.&quot;));} greeting(); //&quot;Good day.&quot; console.log(now); // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间) // 对比：函数体内{} 用var定义的变量是局部变量 var greeting = () =&gt; {var now = new Date(); return (&quot;Good&quot; + ((now.getHours() &gt; 17) ? &quot; evening.&quot; : &quot; day.&quot;));} greeting(); //&quot;Good day.&quot; console.log(now); // ReferenceError: now is not defined 5.其他例子// 空的箭头函数返回 undefined let empty = () =&gt; {}; (() =&gt; &apos;foobar&apos;)(); // Returns &quot;foobar&quot; // (这是一个立即执行函数表达式,可参阅 &apos;IIFE&apos;术语表) var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15 simple(10); // 10 let max = (a, b) =&gt; a &gt; b ? a : b; // Easy array filtering, mapping, ... var arr = [5, 6, 13, 0, 1, 18, 23]; var sum = arr.reduce((a, b) =&gt; a + b); // 66 var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18] var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 2, 36, 46] // 更简明的promise链 promise.then(a =&gt; { // ... }).then(b =&gt; { // ... }); // 无参数箭头函数在视觉上容易分析 setTimeout( () =&gt; { console.log(&apos;I happen sooner&apos;); setTimeout( () =&gt; { // deeper code console.log(&apos;I happen later&apos;); }, 1); }, 1); 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"js 之 import 语法","slug":"js/js_import","date":"2018-01-16T04:27:27.000Z","updated":"2020-03-20T06:27:43.635Z","comments":true,"path":"2018/01/16/js/js_import/","link":"","permalink":"https://lbvs86823.github.io/2018/01/16/js/js_import/","excerpt":"","text":"一.语法概述静态的 import 语句用于导入由另一个模块导出的绑定。无论是否声明了 strict mode ，导入的模块都运行在严格模式下。在浏览器中，import 语句只能在声明了 type=&quot;module&quot; 的 script 的标签中使用。 此外，还有一个类似函数的动态 import()，它不需要依赖 type=&quot;module&quot; 的script标签。 在 script 标签中使用 nomodule 属性，可以确保向后兼容。 二.语法规则import defaultExport from &quot;module-name&quot;; import * as name from &quot;module-name&quot;; import { export } from &quot;module-name&quot;; import { export as alias } from &quot;module-name&quot;; import { export1 , export2 } from &quot;module-name&quot;; import { foo , bar } from &quot;module-name/path/to/specific/un-exported/file&quot;; import { export1 , export2 as alias2 , [...] } from &quot;module-name&quot;; import defaultExport, { export [ , [...] ] } from &quot;module-name&quot;; import defaultExport, * as name from &quot;module-name&quot;; import &quot;module-name&quot;; var promise = import(&quot;module-name&quot;);//这是一个处于第三阶段的提案。 defaultExport 导入模块的默认导出接口的引用名。module-name 要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。某些特定的打包工具可能允许或需要使用扩展或依赖文件，它会检查比对你的运行环境。只允许单引号和双引号的字符串。name 导入模块对象整体的别名，在引用导入模块时，它将作为一个命名空间来使用。export, exportN 被导入模块的导出接口的名称。alias, aliasN 将引用指定的导入的名称。 三.例子1.导入整个模块的内容import * as myModule from &apos;/modules/my-module.js&apos;; 在这里，访问导出接口意味着使用模块名称（在本例为“myModule”）作为命名空间。例如，如果上面导入的模块包含一个接口doAllTheAmazingThings()，你可以这样调用： myModule.doAllTheAmazingThings(); 2.导入单个接口import {myExport} from &apos;/modules/my-module.js&apos;; 3.导入多个接口import {foo, bar} from &apos;/modules/my-module.js&apos;; 4.导入带有别名的接口import {reallyReallyLongModuleExportName as shortName} from &apos;/modules/my-module.js&apos;; 5.导入时重命名多个接口import { reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short } from &apos;/modules/my-module.js&apos;; 6.仅为副作用而导入一个模块整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。 import &apos;/modules/my-module.js&apos;; 7.导入默认值引入模块可能有一个 defaultexport（无论它是对象，函数，类等）可用。然后可以使用import语句来导入这样的默认接口。 最简单的用法是直接导入默认值： import myDefault from &apos;/modules/my-module.js&apos;; 也可以同时将default 语法与上述用法（命名空间导入或命名导入）一起使用。在这种情况下，default 导入必须首先声明。 import myDefault, * as myModule from &apos;/modules/my-module.js&apos;; // myModule used as a namespace import myDefault, {foo, bar} from &apos;/modules/my-module.js&apos;; // specific, named imports 8.动态导入关键字 import 可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise。 import(&apos;/modules/my-module.js&apos;) .then((module) =&gt; { // Do something with the module. }); 这种使用方式也支持 await 关键字。 let module = await import(&apos;/modules/my-module.js&apos;); 更新多详情请参考 javaScript手册","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"Spring Boot 参考指南","slug":"spring/sping boot reference guide","date":"2018-01-11T12:29:20.000Z","updated":"2020-03-20T06:27:43.676Z","comments":true,"path":"2018/01/11/spring/sping boot reference guide/","link":"","permalink":"https://lbvs86823.github.io/2018/01/11/spring/sping boot reference guide/","excerpt":"","text":"#Spring Boot 参考指南(2.0.1.RELEASE)# I Spring Boot 文档1. 文档介绍2. 如何得到帮助3. 第一步4. 如何运行 Spring Boot5. 了解 Spring Boot 的相关特性6. 如何应用到你的应用7. Spring Boot 高级的特性II Spring Boot 入门8. Spring Boot 介绍9. 系统要求10. 安装 Spring Boot11. 开发你的第一个 Spring Boot 应用12. 接下来需要了解？III Spring Boot 如何使用13. 构建系统14. 组织架构你的代码15. 配置16. 自动配置17. Spring Beans 和 依赖注入18. 使用 @SpringBootApplication 注解19. 运行你的应用20. 开发工具21. 如何打包你的应用到生产环境22. 接下来需要了解？IV Spring Boot 功能介绍23. Spring 应用24. 将配置外部化25. Spring的Profile配置26. 日志27. 开发web应用28. 安全29. 如何使用数据库30. 如何使用NOSQL31. 如何使用缓存32. 如何使用消息33. 如何使用 RestTemplate 调用Rest服务34. 如何使用 WebClient 调用Rest服务35. 验证36. 发送邮件37. 如何使用JTA做分布式事务38. HazelCast39. Quartz Scheduler40. 继承Spring41. Spring Session42. 通过JMX进行监控和管理43. 测试44. WebSockets45. Web Services46. 自定义自动化配置47. 对 Kotlin 的支持48. 接下来需要了解？V Spring Boot 的生产级功能特性49. 启用生产级别的功能50. 相关功能切入点51. 通过Http进行管理和监控52. 通过JMX进行监控和管理53. 日志54. 统计55. 审计56. HTTP 跟踪57. 过程监控58. 对 Cloud Foundry 的支持59. 接下来需要了解？VI 如何部署 Spring Boot 应用60. 如何部署到云服务61. 安装 Spring Boot 应用62. 接下来需要了解？VII Spring Boot 命令行接口63. 安装 CLI64. 使用 CLI65. 使用 Groovy Beans DSL 开发应用66. 用 settings.xml 配置CLI67. 接下来需要了解？VIII 如何使用构建工具构建 Spring Boot68. 使用 Maven 构建 Spring Boot69. 使用 Gradle 构建 Spring Boot70. 使用 Ant 构建 Spring Boot71. 对其他系统的构建支持72. 接下来需要了解？IX 如何使用手册73. Spring Boot 应用74. 属性配置75. 内嵌web服务76. Spring MVC77. HTTP Clients78. 日志79. 数据访问80. 数据库初始化81. 消息82. 批量应用程序83. 执行器 Actuator84. 安全85. 热交换86. 构建87. 传统助手X 附录A. 通用应用属性B. 配置meta元数据C. 自动化配置D. 测试自动化注解E. 可只执行化的jarF. 部署的版本化","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"boot","slug":"boot","permalink":"https://lbvs86823.github.io/tags/boot/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"vue 实例属性之 computed","slug":"js/vue/vueComputed","date":"2017-12-17T07:13:21.000Z","updated":"2020-03-20T06:27:43.638Z","comments":true,"path":"2017/12/17/js/vue/vueComputed/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueComputed/","excerpt":"","text":"vue 实例属性之 computed 类型：{ [key: string]: Function | { get: Function, set: Function } }详情：计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 var Comp = Vue.extend({ props: [&apos;msg&apos;], template: &apos;&lt;div&gt;{{ msg }}&lt;/div&gt;&apos; }) var vm = new Comp({ propsData: { msg: &apos;hello&apos; } }) 注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。 computed: { aDouble: vm =&gt; vm.a * 2 } 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 var vm = new Vue({ data: { a: 1 }, computed: { // 仅读取 aDouble: function () { return this.a * 2 }, // 读取和设置 aPlus: { get: function () { return this.a + 1 }, set: function (v) { this.a = v - 1 } } } }) vm.aPlus // =&gt; 2 vm.aPlus = 3 vm.a // =&gt; 2 vm.aDouble // =&gt; 4","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例属性之 propsData","slug":"js/vue/vuePropsData","date":"2017-12-17T07:13:21.000Z","updated":"2020-03-20T06:27:43.644Z","comments":true,"path":"2017/12/17/js/vue/vuePropsData/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vuePropsData/","excerpt":"","text":"vue 实例属性之 propsData 类型：{ [key: string]: any }限制：只用于 new 创建的实例中。详情：创建实例时传递 props。主要作用是方便测试。 var Comp = Vue.extend({ props: [&apos;msg&apos;], template: &apos;&lt;div&gt;{{ msg }}&lt;/div&gt;&apos; }) var vm = new Comp({ propsData: { msg: &apos;hello&apos; } })","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例属性之 methods","slug":"js/vue/vueMethods","date":"2017-12-17T07:13:21.000Z","updated":"2020-03-20T06:27:43.641Z","comments":true,"path":"2017/12/17/js/vue/vueMethods/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueMethods/","excerpt":"","text":"vue 实例属性之 methods 类型：{ [key: string]: Function }详情：methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 var vm = new Vue({ data: { a: 1 }, methods: { plus: function () { this.a++ } } }) vm.plus() vm.a // 2","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例属性之 watch","slug":"js/vue/vueWatch","date":"2017-12-17T07:13:21.000Z","updated":"2020-03-20T06:27:43.646Z","comments":true,"path":"2017/12/17/js/vue/vueWatch/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueWatch/","excerpt":"","text":"vue 实例属性之 watch 类型：{ [key: string]: string | Function | Object | Array }详情：一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 var vm = new Vue({ data: { a: 1, b: 2, c: 3, d: 4, e: { f: { g: 5 } } }, watch: { a: function (val, oldVal) { console.log(&apos;new: %s, old: %s&apos;, val, oldVal) }, // 方法名 b: &apos;someMethod&apos;, // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: { handler: function (val, oldVal) { /* ... */ }, deep: true }, // 该回调将会在侦听开始之后被立即调用 d: { handler: &apos;someMethod&apos;, immediate: true }, e: [ &apos;handle1&apos;, function handle2 (val, oldVal) { /* ... */ }, { handler: function handle3 (val, oldVal) { /* ... */ }, /* ... */ } ], // watch vm.e.f&apos;s value: {g: 5} &apos;e.f&apos;: function (val, oldVal) { /* ... */ } } }) vm.a = 2 // =&gt; new: 2, old: 1 注意，不应该使用箭头函数来定义 watcher 函数(例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例属性之 data","slug":"js/vue/vueData","date":"2017-12-17T06:57:15.000Z","updated":"2020-03-20T06:27:43.639Z","comments":true,"path":"2017/12/17/js/vue/vueData/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueData/","excerpt":"","text":"vue 实例属性之 data 类型：Object | Function限制：组件的定义只接受 function。 var data = { a: 1 } // 直接创建一个实例 var vm = new Vue({ data: data }) vm.a // =&gt; 1 vm.$data === data // =&gt; true Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。 一旦观察过，你就无法在根数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。 实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。 以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(…)) 得到深拷贝的原始数据对象。","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例属性之 props","slug":"js/vue/vueProps","date":"2017-12-17T06:53:31.000Z","updated":"2020-03-20T06:27:43.643Z","comments":true,"path":"2017/12/17/js/vue/vueProps/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueProps/","excerpt":"","text":"vue 实例属性之 props 类型：Array | Object详情：props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。 你可以基于对象的语法使用以下选项： type: 可以是下列原生构造函数中的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的更多信息在此。 default: any为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。 required: Boolean定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。 validator: Function自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。 // 简单语法 Vue.component(&apos;props-demo-simple&apos;, { props: [&apos;size&apos;, &apos;myMessage&apos;] }) // 对象语法，提供验证 Vue.component(&apos;props-demo-advanced&apos;, { props: { // 检测类型 height: Number, // 检测类型 + 其他验证 age: { type: Number, default: 0, required: true, validator: function (value) { return value &gt;= 0 } } } })","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例生命周期钩子","slug":"js/vue/vueHook","date":"2017-12-17T04:41:21.000Z","updated":"2020-03-20T06:27:43.640Z","comments":true,"path":"2017/12/17/js/vue/vueHook/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueHook/","excerpt":"","text":"vue 实例生命周期钩子所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法. created: () =&gt; this.fetchTodos() 这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate 类型：Function详细：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created 类型：Function详细：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前尚不可用。 beforeMount 类型：Function详细：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。 mounted 类型：Function详细：实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。 如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。 注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick： mounted: function () { this.$nextTick(function () { // Code that will run only after the // entire view has been rendered }) } beforeUpdate 类型：Function详细：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated 类型：Function详细：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。该钩子在服务器端渲染期间不被调用。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick： updated: function () { this.$nextTick(function () { // Code that will run only after the // entire view has been re-rendered }) } activated 类型：Function详细：被 keep-alive 缓存的组件激活时调用。该钩子在服务器端渲染期间不被调用。 deactivated 类型：Function详细：被 keep-alive 缓存的组件停用时调用。该钩子在服务器端渲染期间不被调用。 beforeDestroy 类型：Function详细：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 destroyed 类型：Function详细：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。该钩子在服务器端渲染期间不被调用。 errorCaptured 类型：(err: Error, vm: Component, info: string) =&gt; ?boolean详细：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。 错误传播规则 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 实例的生命周期","slug":"js/vue/vueLifeCycle","date":"2017-12-17T03:04:11.000Z","updated":"2020-03-20T06:27:43.640Z","comments":true,"path":"2017/12/17/js/vue/vueLifeCycle/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueLifeCycle/","excerpt":"","text":"vue 实例的生命周期","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"vue 入门","slug":"js/vue/vueStart","date":"2017-12-17T02:03:41.000Z","updated":"2020-03-20T06:27:43.645Z","comments":true,"path":"2017/12/17/js/vue/vueStart/","link":"","permalink":"https://lbvs86823.github.io/2017/12/17/js/vue/vueStart/","excerpt":"","text":"一，vue 安装Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器，你可以参考中文文档 vue，vue CLI 进行更详细的了解。 # 最新稳定版 $ npm install vue # 命令行工具 (CLI) $ npm install -g @vue/cli # OR $ yarn global add @vue/cli # 检查其版本是否正确 $ vue -V 二，vue 的基本语法Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： &lt;div id=&quot;app&quot;&gt; {{ message }} &lt;/div&gt; var app = new Vue({ el: &apos;#app&apos;, data: { message: &apos;Hello Vue!&apos; } }) 指令： v-bind # 绑定函数 v-if # 条件判断 v-for # for循环 v-on # 添加事件监听器 v-model # 实现表单输入和应用状态之间的双向绑定 四，vue 实例创建每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 当创建一个 Vue 实例时，你可以传入一个选项对象。这篇教程主要描述的就是如何使用这些选项来创建你想要的行为。一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。","categories":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"},{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"https://lbvs86823.github.io/categories/vue/"}]},{"title":"Yarn 依赖管理工具","slug":"tools/yarn","date":"2017-11-27T04:43:59.000Z","updated":"2020-03-20T06:27:43.686Z","comments":true,"path":"2017/11/27/tools/yarn/","link":"","permalink":"https://lbvs86823.github.io/2017/11/27/tools/yarn/","excerpt":"","text":"一，Yarn 是干啥的?Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码， 或者分享自己的代码。Yarn 做这些快捷、安全、可靠，所以你不用担心什么。 通过Yarn你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。 使用过程中遇到问题，你可以将其上报或者贡献解决方案。一旦问题被修复， Yarn会更新保持同步。 代码通过 包（package） (或者称为 模块（module）) 的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。主要有以下一些优势： Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 离线模式：如果你以前安装过某个包，再次安装时可以在没有任何互联网连接的情况下进行。 确定性: 不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装。 二，安装 Yarn$ brew install yarn 如果未在 PATH 环境变量中找到 yarn，请按照以下步骤添加 yarn 到 PATH 环境变量中，使其可以随处运行。 注意：您的配置文件可能是 .profile、.bash_profile、.bashrc、.zshrc 等。 将此项加入您的配置文件： export PATH=”$PATH:/opt/yarn-[version]/bin” （路径可能根据您安装 Yarn 的位置而有差异）在终端中，执行登录并登出以使更改生效为了可以全局访问 Yarn 的可执行文件，你需要在您的终端中设置 PATH 环境变量。若要执行此操作，请添加 export PATH=”$PATH:yarn global bin“ 到您的配置文件中。 三，Yarn 工作流将包管理器引入到项目中会引入一个围绕依赖关系的新工作流。 Yarn 尽最大努力不让你感知它的存在，并让工作流中的每一步 都易于理解。 关于基本工作流程，您应该了解以下几点： 创建一个新项目 添加/更新/删除依赖项 安装/重新安装依赖项 使用版本管理工具（例如 git） 持续集成 四，Yarn 的使用命令$ yarn --veriosn #查看安装软件的版本 $ yarn init #初始化一个新项目 # 设置仓库镜像 $ yarn config get registry // 查看当前仓库地址 $ yarn config set registry https://registry.npm.taobao.org // 设置淘宝仓库地址 # 添加依赖包 $ yarn add [package] $ yarn add [package]@[version] $ yarn add [package]@[tag] # 将依赖项添加到不同依赖项类别中 # 分别添加到 devDependencies、peerDependencies 和 optionalDependencies 类别中： $ yarn add [package] --dev $ yarn add [package] --peer $ yarn add [package] --optional # 升级依赖包 $ yarn upgrade [package] $ yarn upgrade [package]@[version] $ yarn upgrade [package]@[tag] # 移除依赖包 $ yarn remove [package] # 安装项目的全部依赖 $ yarn install 五，运行项目$ yarn run [script] [&lt;args&gt;] 你可以在你的 package.json 文件中，定义一个 scripts 属性： { &quot;name&quot;: &quot;my-package&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;babel src -d lib&quot;, &quot;test&quot;: &quot;jest&quot; } } 然后就可以采用如下命令运行： $ yarn run test $ yarn run test -o --watch","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://lbvs86823.github.io/tags/tool/"},{"name":"yarn","slug":"yarn","permalink":"https://lbvs86823.github.io/tags/yarn/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"kafka 入门指南","slug":"kafka/kafka","date":"2017-07-17T04:53:09.000Z","updated":"2021-04-25T07:49:40.365Z","comments":true,"path":"2017/07/17/kafka/kafka/","link":"","permalink":"https://lbvs86823.github.io/2017/07/17/kafka/kafka/","excerpt":"","text":"kafka 入门指南启动服务器1.首先启动内置的zookeeper服务器 ./bin/zookeeper-server-start.sh ./config/zookeeper.properties #如果需要在后台运行, 可以添加 -daemon 参数。 #输出如下字样表示启动成功 INFO binding to port 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.NIOServerCnxnFactory) 2.启动kafka服务器 ./bin/kafka-server-start.sh ./config/server.properties #如果需要在后台运行, 可以添加 -daemon 参数。 #输出如下字样表示启动成功 INFO [KafkaServer id=0] started (kafka.server.KafkaServer) 创建主题创建一个主题(topic) 名称为：test， 该主题只有一个分区(partition)，且该分区只有一个副本(replica) ./bin/kafka-topics.sh --create --zookeeper localhost:2181 --topic test --partitions 1 --replication-factor 1 Created topic test. #创建成功 主题状态查看./bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test Topic:test PartitionCount:1 ReplicationFactor:1 Configs: Topic:test Partition: 0 Leader: 0 Replicas: 0 Isr: 0 发送消息./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test &gt;Hello Kafka &gt;This is my first Kafka message &gt;....... # 不断的输入信息，回车发出消息 消费消息./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning Hello Kafka This is my first Kafka message ...... # 不断的收到信息 kafka设计1.高吞吐量/低延时 大量使用操作系统页缓存，内存操作速度快且命中率高 kafka不直接参与物理IO操作，而是交由操作系统来完成 采用追加写入方式，摒弃了缓慢的磁盘随机读写操作 使用以sendfile为代表的零拷贝技术加强网络间的数据传输效率。 2.消息持久化 消息的发送与消费解耦 所有数据都会立即被写入文件系统的持久化日志中，之后kafka服务器才会返回给客户端通知它们消息已被成功写入。 3.负载均衡和故障转移 智能化分区领导者选举实现负载均衡 通过注册到zookeeper的心跳机制实现故障转移 4.伸缩性 每台kafka服务器上的状态统一交由zookeeper管理","categories":[{"name":"kafka","slug":"kafka","permalink":"https://lbvs86823.github.io/categories/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://lbvs86823.github.io/tags/kafka/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://lbvs86823.github.io/tags/zookeeper/"}],"keywords":[{"name":"kafka","slug":"kafka","permalink":"https://lbvs86823.github.io/categories/kafka/"}]},{"title":"es6 新语法","slug":"js/es6_new","date":"2017-02-27T03:27:27.000Z","updated":"2020-03-20T06:27:43.629Z","comments":true,"path":"2017/02/27/js/es6_new/","link":"","permalink":"https://lbvs86823.github.io/2017/02/27/js/es6_new/","excerpt":"","text":"let 块作用域声明变量var x = 2; // Here x is 2 { let x = 5; // Here x is 5 } // Here x is 2 const 声明常量值常量类似于 let 变量，但不能更改值。 var x = 5; // Here x is 5 { const x = 7; // Here x is 7 } // Here x is 5 ** 指数运算符支持取幂运算符（**）将第一个操作数提升到第二个操作数的幂。 var x = 6; var z = x ** 2; // 结果是 36 # x ** y 的结果与 Math.pow(x,y) 相同 var x = 5; var z = Math.pow(x,2); // 结果是 25 默认参数值ES6 允许函数参数具有默认值。 function myFunction(x, y = 55) { // y is 55 if not passed or undefined return x + y; } myFunction(5); // 将返回 60 Array.find()find() 方法返回通过测试函数的第一个数组元素的值。请注意此函数接受 3 个参数： 项目值项目索引数组本身 # 此例查找（返回）第一个大于 9 的元素（的值）： var numbers = [1, 9, 14, 3, 6]; var first = numbers.find(myFunction); function myFunction(value, index, array) { return value &gt; 9; } Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引。请注意此函数接受 3 个参数： 项目值项目索引数组本身 # 此例确定大于 9 的第一个元素的索引： var numbers = [1, 9, 14, 3, 6]; var first = numbers.find(myFunction); function myFunction(value, index, array) { return value &gt; 9; } Number对象的新属性和方法 EPSILONMIN_SAFE_INTEGERMAX_SAFE_INTEGERNumber.isInteger(x) # 测试参数是否是整数Number.isSafeInteger() # 测试安全整数是可以精确表示为双精度数的整数。安全整数指的是从 -(253 - 1) 到 +(253 - 1) 的所有整数。这是安全的：9007199254740991。这是不安全的：9007199254740992。 新增的全局方法 isFinite(x) # 如果参数为 Infinity 或 NaN，则方法返回 false，否则返回 trueisNaN(x) # 如果参数是 NaN，则 方法返回 true。否则返回 false 箭头函数箭头函数允许使用简短的语法来编写函数表达式，您不需要 function 关键字、return 关键字以及花括号。 // ES5 var x = function(x, y) { return x * y; } // ES6 const x = (x, y) =&gt; x * y; const x = (x, y) =&gt; { return x * y }; 箭头功能没有自己的 this。它们不适合定义对象方法。箭头功能未被提升。它们必须在使用前进行定义。如果函数是单个语句，则只能省略 return 关键字和花括号。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es6","slug":"es6","permalink":"https://lbvs86823.github.io/tags/es6/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"npm 包管理工具","slug":"tools/npm","date":"2017-02-12T12:13:39.000Z","updated":"2020-03-20T06:27:43.685Z","comments":true,"path":"2017/02/12/tools/npm/","link":"","permalink":"https://lbvs86823.github.io/2017/02/12/tools/npm/","excerpt":"","text":"一，NPM 是干啥的?NPM (NPM中文) 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。注册表 是一个巨大的数据库，保存了每个包（package）的信息。CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 二，安装 NPMNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodeJs已经集成了npm，只要安装nodeJs就可以了，你可以直接去下载安装。 $ npm -v # 测试安装成功，查看安装版本 三，NPM 的使用命令$ npm init #初始化一个新项目 $ npm install &lt;package_name&gt; #安装本地包 -g 为全局安装, `install` 可以用别名 `i` 替代 $ npm update &lt;package_name&gt; #更新软件包 -g 为全局更新 $ npm outdated #检测过时的软件包 $ npm uninstall &lt;package_name&gt; #卸载软件包 --save 删除package.json中的依赖信息 -g 为卸载全局的 四，运行项目$ npm [script] [&lt;args&gt;] 你可以在你的 package.json 文件中，定义一个 scripts 属性： { &quot;name&quot;: &quot;my-package&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;babel src -d lib&quot;, &quot;test&quot;: &quot;jest&quot; } } 然后就可以采用如下命令运行： $ npm test $ npm test -o --watch","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://lbvs86823.github.io/tags/tool/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://lbvs86823.github.io/tags/nodeJs/"},{"name":"npm","slug":"npm","permalink":"https://lbvs86823.github.io/tags/npm/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"Docker 安装 Nginx","slug":"docker/dockerInstallNginx","date":"2016-09-15T07:22:41.000Z","updated":"2020-03-20T06:27:43.621Z","comments":true,"path":"2016/09/15/docker/dockerInstallNginx/","link":"","permalink":"https://lbvs86823.github.io/2016/09/15/docker/dockerInstallNginx/","excerpt":"","text":"1. 查找 Nginx 镜像访问镜像仓库: https://hub.docker.com/ 搜索 nginx 即可。可以通过 Sort by 查看其他版本的 Nginx，默认是最新版本 nginx:latest 。当然，你还可以使用命令行来进行操作选择你要的版本： $ docker search nginx 2. 拉取 Nginx 镜像$ docker pull nginx:latest # 拉取最新的 $ docker pull nginx:1.17.8 # 拉取特定的版本 $ docker images # 查看本地镜像 3. 运行 Nginx 容器$ docker run -it --name nginx-test -p 8080:80 -d nginx 参数说明： -p 8080:80：映射容器服务的 80 端口到宿主机的 8080 端口。外部可以直接通过宿主机ip:8080 访问到 nginx 的服务。 如果要建立目录映射:首先在本地建立所需的映射目录： $ mkdir -p /usr/local/docker/nginx/{conf,conf.d,html,logs} 其次需要编写相关的配置文件：default.conf编写： server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht { # deny all; #} } 编写nginx.conf文件： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 以上操作你还可以从一个启动的nginx容器中去copy所需要的问题到本地： $ docker cp tmp-nginx-container:/etc/nginx/conf.d /usr/local/docker/nginx/conf.d $ docker cp tmp-nginx-container:/etc/nginx/nginx.conf /usr/local/docker/nginx/conf/nginx.conf $ docker cp tmp-nginx-container:/usr/share/nginx/html /usr/local/docker/nginx/html $ docker cp tmp-nginx-container:/var/log/nginx /usr/local/docker/nginx/logs 再运行命令： $ docker run -it --restart=always --name nginx -p 80:80 \\ -v /usr/local/docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \\ -v /usr/local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v /usr/local/docker/nginx/conf.d:/etc/nginx/conf.d \\ -v /usr/local/docker/nginx/html:/usr/share/nginx/html \\ -v /usr/local/docker/nginx/logs:/var/log/nginx \\ -d nginx:1.17.8 –restart=always: 当Docker 重启时，容器会自动启动。–privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录 以下是一些常用的操作： # 检查容器是否正确运行 $ docker container ls # -a 显示所有容器，包括没有启动，不加就只显示运行中的 $ docker ps -a # -a 显示所有容器，包括没有启动，不加就只显示运行中的与上面的一条类似 # 停止容器 $ docker stop xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) # 删除容器 $ docker rm xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) -f 强制删除(包括运行中的) 4. 访问 Nginx 测试最后我们可以通过浏览器可以直接访问 ip地址 + 端口号的 nginx 服务看到如下页面： Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx.","categories":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}]},{"title":"Docker 安装 Redis","slug":"docker/dockerInstallRedis","date":"2016-09-14T02:30:15.000Z","updated":"2020-03-20T06:27:43.622Z","comments":true,"path":"2016/09/14/docker/dockerInstallRedis/","link":"","permalink":"https://lbvs86823.github.io/2016/09/14/docker/dockerInstallRedis/","excerpt":"","text":"1. 查找 Redis 镜像访问镜像仓库: https://hub.docker.com/ 搜索 redis 即可。可以通过 Sort by 查看其他版本的 Redis，默认是最新版本 redis:latest 。当然，你还可以使用命令行来进行操作选择你要的版本： $ docker search redis 2. 拉取 Redis 镜像$ docker pull redis:latest # 拉取最新的 $ docker pull redis:5.0.7 # 拉取特定的版本 $ docker images # 查看本地镜像 3. 运行 Redis 容器$ docker run -itd --name redis-test -p 6379:6379 redis 参数说明： -p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。 如果要建立目录映射:首先编写redis的配置文件redis.conf (这个文件需要和容器中的redis配置文件做映射)：你可以到github上面去搜索reids对应的版本，找到这个文件下载下来修改如下配置： daemonize yes : 找到这个配置,修改成no(不作为守护进程运行，如果作为守护进程运行将在/var/run/redis.pid中写入一个pid文件) 修改配置可以支持远程(3.2版本后新增protected-mode配置，默认是yes，即开启。)：解决方法分为两种： 1、关闭protected-mode模式 修改成 no 即可2、配置bind或者设置密码 bind 192.168.1.100 10.0.0.1 # 增加访问主机的ip 或者配置密码： # bind 127.0.0.1 # 注释掉此配置 requirepass 123456 # 找到此配置设置密码 再运行命令： $ docker run -it --restart=always --name redis -p 6379:6379 \\ -v /usr/local/docker/redis/conf/redis.conf:/etc/redis/redis.conf \\ -v /usr/local/docker/redis/data:/data \\ -d redis:5.0.7 redis-server /etc/redis/redis.conf --appendonly yes --requirepass 123456 –restart=always: 当Docker 重启时，容器会自动启动。–privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录redis-server /etc/redis/redis.conf : 指定配置文件启动redis-server进程–appendonly yes : 开启数据持久化–requirepass 123456 : 设置密码 以下是一些常用的操作： # 检查容器是否正确运行 $ docker container ls # -a 显示所有容器，包括没有启动，不加就只显示运行中的 $ docker ps -a # -a 显示所有容器，包括没有启动，不加就只显示运行中的与上面的一条类似 # 停止容器 $ docker stop xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) # 删除容器 $ docker rm xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) -f 强制删除(包括运行中的) 4. 连接 Redis 测试# 进入redis容器内 docker exec -it xxx /bin/bash # xxx 为对应的容器Id前几个字符(也可以用镜像name) # 查看redis的配置文件 root@c5987cecb142:/# cat /etc/redis/redis.conf # 连接redis root@c5987cecb142:/# redis-cli root@c5987cecb142:/# redis-cli -h 127.0.0.1 -p 6379 -a 123456","categories":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}]},{"title":"Docker 安装 MySql","slug":"docker/dockerInstallMysql","date":"2016-09-13T11:39:24.000Z","updated":"2020-03-20T06:27:43.620Z","comments":true,"path":"2016/09/13/docker/dockerInstallMysql/","link":"","permalink":"https://lbvs86823.github.io/2016/09/13/docker/dockerInstallMysql/","excerpt":"","text":"1. 查找 MySQL 镜像访问镜像仓库: https://hub.docker.com/ 搜索 mysql即可。可以通过 Sort by 查看其他版本的 MySQL，默认是最新版本 mysql:latest 。当然，你还可以使用命令行来进行操作选择你要的版本： $ docker search mysql 2. 拉取 MySQL 镜像$ docker pull mysql:latest # 拉取最新的 $ docker pull mysql:8.0.19 # 拉取特定的版本 $ docker images # 查看本地镜像 3. 运行 MySQL 容器$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 参数说明： –name：容器名，此处命名为mysql-test-e：配置信息，此处配置mysql的root用户的登陆密码-d：源镜像名，此处为 mysql:5.7-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 如果要建立目录映射:首先编写mysql配置文件my.cnf (这个文件需要和容器中的mysql配置文件做映射)： [mysqld] user=mysql character-set-server=utf8 default_authentication_plugin=mysql_native_password secure_file_priv=/var/lib/mysql expire_logs_days=7 sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION max_connections=1000 [client] default-character-set=utf8 [mysql] default-character-set=utf8 # 将上面的内容粘贴到下面的文件中保存 vi /usr/local/docker/mysql/my.cnf 再运行命令： $ docker run -it --restart=always --name mysql -p 3306:3306 \\ -v /usr/local/docker/mysql/conf/my.cnf:/etc/mysql/my.cnf \\ -v /usr/local/docker/mysql/conf:/etc/mysql \\ -v /usr/local/docker/mysql/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql:8.0.19 –restart=always: 当Docker 重启时，容器会自动启动。–privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字 以下是一些常用的操作： # 检查容器是否正确运行 $ docker container ls # -a 显示所有容器，包括没有启动，不加就只显示运行中的 $ docker ps -a # -a 显示所有容器，包括没有启动，不加就只显示运行中的与上面的一条类似 # 停止容器 $ docker stop xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) # 删除容器 $ docker rm xxx # xxx 为对应的容器Id前几个字符(也可以用镜像name) -f 强制删除(包括运行中的) 注意：如果启动mysql报如下错误，那是因为MYSQL新特性secure_file_priv对读写文件的影响。 mysqld: Error on realpath() on &apos;/var/lib/mysql-files&apos; (Error 2 - No such file or directory) [ERROR] [MY-010095] [Server] Failed to access directory for --secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : /var/lib/mysql-files [ERROR] [MY-010119] [Server] Aborting 解决问题方法: windows下：修改my.ini 在[mysqld]内加入secure_file_priv=/var/lib/mysql linux下：修改my.cnf 在[mysqld]内加入secure_file_priv=/var/lib/mysql 4. 连接 MySQL 测试# 进入mysql容器内 docker exec -it xxx /bin/bash # xxx 为对应的容器Id前几个字符(也可以用镜像name) # 查看mysql的配置文件 root@c5987cecb142:/# cat /etc/mysql/my.cnf # 连接mysql root@c5987cecb142:/# mysql -uroot -p123456","categories":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"https://lbvs86823.github.io/tags/mysql/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}]},{"title":"Docker 常用命令","slug":"docker/dockerCommand","date":"2016-09-11T11:10:44.000Z","updated":"2020-03-20T06:27:43.618Z","comments":true,"path":"2016/09/11/docker/dockerCommand/","link":"","permalink":"https://lbvs86823.github.io/2016/09/11/docker/dockerCommand/","excerpt":"","text":"docker常用命令：sudo service docker start/stop/restart docker –versiondocker-compose –versiondocker-machine –versiondocker infodocker run -d -p 80:80 –name webserver nginx 镜像相关操作1.获取镜像：docker pull [docker registry 地址[:端口]/]仓库名[:标签]] eg: docker pull ubuntu:16.04 2.查看镜像docker image ls 列出已经下载的所有[顶层]镜像docker images 列出已经下载的所有[顶层]镜像docker image ls -a 列出所有镜像[包括中间层镜像]docker image ls -f dangling=true 查看虚悬镜像docker image prune 删除悬虚镜像 3.使用镜像：docker run 仓库名[:标签] 4.删除本地镜像docker image rm [&lt;镜像1&gt; &lt;镜像2&gt; …] 5.制作镜像docker commit [仓库名称:标签] 使用Dockerfile定制镜像 6.查看镜像历史记录docker history :标签 容器相关操作1.启动容器基于镜像新建一个容器并启动docker run -it ubuntu:16.04 /bin/echo ‘hello world’ 当利用docker run 来创建容器时，docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个Ip地址给容器执行用户指定的应用程序执行完毕后容器被终止 将一个终止状态的容器启动docker container start/restart [containerId or names]容器的核心是为执行应用程序准备所必须需要的资源。 查看容器信息docker container ls [-a] 查看容器的输出信息docker container logs [containerId or names] 终止容器docker container stop [containerId or names]当容器中指定的应用程序终结时，容器也自动终止。 进入容器docker attach [containerId or names] (docker自带命令) docker exec -it [containerId or names] 导出容器docker export [containerId or names] 导入容器快照docker import 快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态) docker load 导入镜像文件到本地仓库(镜像文件将保存完整的记录体积也要大) 删除一个容器docker container rm [containerId or names]docker container rm -f [containerId or names] 强制删除一个正在运行中的容器docker container prune 清除所有终止状态的容器 docker system df 查看镜像，容器，数据卷所占用的空间 docker ps 查看当前容器运行着哪些镜像 docker start webserverdocker sotp webserverdocker rm webserver","categories":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/tags/docker/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}]},{"title":"CentOS Docker 安装","slug":"docker/dockerInstallCentos","date":"2016-09-08T10:30:14.000Z","updated":"2020-03-20T06:27:43.619Z","comments":true,"path":"2016/09/08/docker/dockerInstallCentos/","link":"","permalink":"https://lbvs86823.github.io/2016/09/08/docker/dockerInstallCentos/","excerpt":"","text":"1. 卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2. 安装 Docker Engine-Community在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。 2.1 安装相关依赖包：安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 $ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 2.2 设置仓库：使用以下命令来设置稳定的仓库。 $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 2.3 安装 Docker Engine-Community：安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本： $ sudo yum install docker-ce docker-ce-cli containerd.io 2.4 安装特定版本的 Docker Engine-Community：列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。 $ yum list docker-ce --showduplicates | sort -r # 显示如下 docker-ce.x86_64 3:18.09.2-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable docker-ce.x86_64 18.06.3.ce-3.el7 docker-ce-stable docker-ce.x86_64 18.06.2.ce-3.el7 docker-ce-stable docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable 通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.2-3.el7 。 # 安装指定的版本 $ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 3. 启动 Docker$ docker -v # 验证docker 查看安装版本 $ sudo systemctl start docker # 启动 $ sudo docker run hello-world # 运行镜像测试 4. 配置 Docker 镜像国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，比如： Docker官方提供的中国镜像库：https://registry.docker-cn.com七牛云加速器：https://reg-mirror.qiniu.com 当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。 对于使用 upstart 的系统（Ubuntu14.04、Debian7Wheezy）而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址： DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot; # 重新启动服务 $ sudo service docker restart 对于使用 systemd 的系统(Ubuntu16.04+、Debian8+、CentOS7)，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）： {&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]} # 重新启动服务 $ sudo systemctl daemon-reload $ sudo systemctl restart docker 检查镜像加速器是否生效: $ docker info # 可以看到下面类似的片段 Registry Mirrors: https://registry.docker-cn.com/","categories":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/tags/docker/"},{"name":"centos","slug":"centos","permalink":"https://lbvs86823.github.io/tags/centos/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://lbvs86823.github.io/categories/docker/"}]},{"title":"es5 新语法","slug":"js/es5_new","date":"2016-06-18T07:41:37.000Z","updated":"2020-03-20T06:27:43.628Z","comments":true,"path":"2016/06/18/js/es5_new/","link":"","permalink":"https://lbvs86823.github.io/2016/06/18/js/es5_new/","excerpt":"","text":"指令”use strict”“use strict” 定义 JavaScript 代码应该以“严格模式”执行。您可以在所有程序中使用严格模式。它可以帮助您编写更清晰的代码，例如阻止您使用未声明的变量。“use strict” 只是一个字符串表达式。旧浏览器如果不理解它们就不会抛出错误。 声明严格模式: 通过在脚本或函数的开头添加 “use strict”; 来声明严格模式。 在脚本开头进行声明，拥有全局作用域（脚本中的所有代码均以严格模式来执行） 在函数中声明严格模式，拥有局部作用域（只有函数中的代码以严格模式执行） 所有 “use strict”; 只会对“理解”其含义的新编译器产生影响。 严格模式中不允许的事项: 在不声明变量的情况下使用变量，是不允许的：x = 3.14; // 这将引发错误对象也是变量，在不声明对象的情况下使用对象也是不允许的：x = {p1:10, p2:20}; // 这将引发错误删除变量（或对象）是不允许的：var x = 3.14; delete x; // 这将引发错误删除函数是不允许的：function x(p1, p2) {}; delete x; // 这将引发错误重复参数名是不允许的：function x(p1, p1) {}; // 这将引发错误八进制数值文本是不允许的：var x = 010; // 这将引发错误转义字符是不允许的：var x = \\010; // 这将引发错误写入只读属性是不允许的：var obj = {}; Object.defineProperty(obj, “x”, {value:0, writable:false}); obj.x = 3.14; // 这将引发错误写入只能获取的属性是不允许的：var obj = {get x() {return 0} }; obj.x = 3.14; // 这将引发错误删除不可删除的属性是不允许的：delete Object.prototype; // 这将引发错误字符串 “eval” 不可用作变量：var eval = 3.14; // 这将引发错误字符串 “arguments” 不可用作变量: var arguments = 3.14; // 这将引发错误with 语句是不允许的：with (Math){x = cos(2)}; // 这将引发错误处于安全考虑，不允许 eval() 在其被调用的作用域中创建变量：eval (“var x = 2”); alert (x); // 这将引发错误在类似 f() 的函数调用中，this 的值是全局对象。在严格模式中，现在它成为了 undefined。严格模式中不允许使用为未来预留的关键词（implements,interface,let,package,private,protected,public,static,yield）“use strict” 指令只能在脚本或函数的开头被识别。 Sting对象新增方法trim()删除字符串两端的空白字符。 var str = &quot; Hello World! &quot;; var x= str.trim(); // 这里 x = &quot;Hello World!&quot; 数组对象新增方法isArray(x)检查对象x是否为数组 forEach(func)该func函数接受 3 个参数： 项目值项目索引数组本身 为每个数组元素调用一次函数func，返回值是undefined，不可以链式调用。 var txt = &quot;&quot;; var numbers = [1, 2, 3, 4, 5]; numbers.forEach(func); function func(value) { txt = txt + value + &quot; &quot;; } // txt = &quot;1 2 3 4 5 &quot; map(func)该func函数接受 3 个参数： 项目值项目索引数组本身 通过对每个数组元素执行函数func来创建新数组，不会对没有值的数组元素执行函数。返回一个新数组，原数组不会改变。 var numbers1 = [1, 2, 3, 4, 5]; var numbers2 = numbers1.map(func); function func(value) { return value * 2; } // numbers2 = [2, 4, 6, 8, 10]; filter(func)该func函数接受 3 个参数： 项目值项目索引数组本身 过滤通过一个函数测试func返回一个新的数组。 var numbers1 = [1, 2, 3, 4, 5]; var numbers2 = numbers1.filter(func); function func(value) { return value &gt;= 4; } // numbers2 = [4, 5]; reduce(func，x)该方法能够接受一个初始值x，func在数组中从左到右运行该func函数接受 4 个参数： 总数（初始值/先前返回的值）项目值项目索引数组本身 var numbers1 = [1, 2, 3, 4, 5]; var sum = numbers1.reduce(func); function func(total, value, index, arr) { return total + value; } // sum = 15; reduceRight(func，x)该方法能够接受一个初始值x，func在数组中从右到左运行 every(func)检测所有数组元素都通过了func函数的测试。该func函数接受 3 个参数： 项目值项目索引数组本身 var numbers1 = [1, 2, 3, 4, 5]; var test = numbers1.every(func); function func(value, index, arr) { return value &gt; 4; } // test = false; some(func)检测某些数组元素都通过了func函数的测试。该func函数接受 3 个参数： 项目值项目索引数组本身 var numbers1 = [1, 2, 3, 4, 5]; var test = numbers1.some(func); function func(value, index, arr) { return value &gt; 4; } // test = true; indexOf(item，start)在数组中搜索元素值并返回其位置，没找到返回 -1item: 必需。要检索的项目。start: 可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾 var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var a = fruits.indexOf(&quot;Apple&quot;); # a=0 //第一个项目的位置是 0，第二个项目的位置是 1，以此类推。 lastIndexOf(item，start)与 Array.indexOf() 类似，但是从数组结尾开始搜索。 find(func) 这个是老版本支持的方法返回通过测试函数func的第一个数组元素的值。该func函数接受 3 个参数： 项目值项目索引数组本身 var numbers1 = [1, 2, 3, 4, 5]; var first = numbers1.some(func); function func(value, index, arr) { return value &gt; 4; } // first = 5; findIndex(func) 这个老版本支持的方法返回通过测试函数func的第一个数组元素的索引。 var numbers1 = [1, 2, 3, 4, 5]; var first = numbers1.some(func); function func(value, index, arr) { return value &gt; 4; } // first = 4; JSON对象新增方法parse(txt)用于将文本转换为 JavaScript 对象： stringify()将对象转换为字符串，结果将是遵循 JSON 表示法的字符串。 Date对象新增方法now()Date.now() 返回自零日期（1970 年 1 月 1 日 00:00:00:00）以来的毫秒数。 属性 Getter 和 SetterES5 允许您使用类似于获取或设置属性的语法来定义对象方法。 var person = { firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot;, get lang() { return this.language; }, set lang(value) { this.language = value; } }; lan = person.lang; // 这里 lan = &quot;NO&quot; // 使用 setter 设置对象属性： person.lang = &quot;en&quot;; // 使用 getter 显示来自对象的数据： lan = person.lang; // 这里 lan = &quot;en&quot; Object对象新增的属性和方法 Object.defineProperty(object, property, descriptor) // 添加或更改对象属性Object.defineProperties(object, descriptors) // 添加或更改多个对象属性Object.getOwnPropertyDescriptor(object, property) // 访问属性Object.getOwnPropertyNames(object) // 将所有属性作为数组返回Object.keys(object) // 将可枚举属性作为数组返回Object.getPrototypeOf(object) // 访问原型Object.preventExtensions(object) // 防止向对象添加属性Object.isExtensible(object) // 如果可以将属性添加到对象，则返回 trueObject.seal(object) // 防止更改对象属性（而不是值）Object.isSealed(object) // 如果对象被密封，则返回 trueObject.freeze(object) // 防止对对象进行任何更改Object.isFrozen(object) // 如果对象被冻结，则返回 true // 创建对象： var person = { firstName: &quot;Bill&quot;, lastName : &quot;Gates&quot;, language : &quot;NO&quot; }; // 更改属性： Object.defineProperty(person, &quot;language&quot;, { get : function() { return language }, set : function(value) { language = value.toUpperCase()} }); // 更改语言 person.language = &quot;en&quot;; 语法变更对字符串的属性访问 charAt() 方法返回字符串中指定索引（位置）的字符：ECMAScript 5 允许对字符串进行属性访问： var str = &quot;HELLO WORLD&quot;; str.charAt(0); // 返回 H var str = &quot;HELLO WORLD&quot;; str[0]; // 返回 H 数组和对象字面量中的尾随逗号ECMAScript 5 允许在对象和数组定义中使用尾随逗号, 但是 JSON 不允许使用尾随逗号。 // 允许： person = { firstName: &quot;Bill&quot;, lastName: &quot; Gates&quot;, age: 62, } // 允许： points = [ 1, 5, 10, 25, 40, 100, ]; // 不允许： var person = &apos;{&quot;firstName&quot;:&quot;Bill&quot;, &quot;lastName&quot;:&quot;Gates&quot;, &quot;age&quot;:62,}&apos; JSON.parse(person) 多行字符串字面量如果使用反斜杠转义，ECMAScript 5 允许多行的字符串文字（字面量）： &quot;Hello \\ Kitty!&quot;; 作为属性名称的保留字ECMAScript 5允许保留字作为属性名称： var obj = {name: &quot;Bill&quot;, new: &quot;yes&quot;}","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"es5","slug":"es5","permalink":"https://lbvs86823.github.io/tags/es5/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"Java bean 的一些专用名词解释","slug":"javacore/javabean","date":"2015-10-17T13:13:11.000Z","updated":"2020-03-20T06:27:43.626Z","comments":true,"path":"2015/10/17/javacore/javabean/","link":"","permalink":"https://lbvs86823.github.io/2015/10/17/javacore/javabean/","excerpt":"","text":"我们在一些架构书籍中经常会听到一些专业名词，下面就一些关于对象方面的术语进行讲解。 PO(Persistant Object) 持久对象在 o/r 映射的时候出现的概念，如果没有 o/r 映射，没有这个概念存在了。可以看成是与数据库中的表相映射的 java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 DO(Domain Object) 领域对象就是从现实世界中抽象出来的有形或无形的业务实体。一般和数据中的表结构对应。 TO(Transfer Object) 传输对象在应用程序不同逻辑层之间传输的对象 VO(View Object) 持久对象视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 BO(Business Object) 业务对象从业务模型的角度看, 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。 DTO(Data Transfer Object) 数据传输对象这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 POJO(Plain Ordinary Java Object) 简单无规则 java 对象纯的传统意义的 java 对象。是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法。","categories":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lbvs86823.github.io/tags/Java/"}],"keywords":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}]},{"title":"Homebrew Mac OS 系统软件包管理利器","slug":"tools/homebrew","date":"2015-06-07T14:13:29.000Z","updated":"2020-03-20T06:27:43.682Z","comments":true,"path":"2015/06/07/tools/homebrew/","link":"","permalink":"https://lbvs86823.github.io/2015/06/07/tools/homebrew/","excerpt":"","text":"一，Homebrew 是干啥的?Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。与(Debian/Ubuntu)系列的apt包管理系统和(Redhat/Fedora)系列的yum包管理系统一样。主要有以下一些优势： Homebrew 软件不会将文件安装到它本身目录之外，所以可将Homebrew安装到任意位置。 Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 。 二，安装 Homebrew$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 用来存放Homebrew安装的程序。 三，Homebrew 的使用命令$ brew install apk #安装软件包 $ brew list #查看已安装包列表 $ brew uninstall apk #卸载软件包 $ brew search &lt;apk&gt; #查询可用的软件包 $ brew info &lt;apk&gt; #显示任意或者指定包信息 $ brew deps &lt;apk&gt; #显示任意或者指定包依赖 #软件更新相关 $ brew update #更新Homebrew $ brew outdated #查看那些已安装的程序需要更新 $ brew update &lt;apk&gt; #更新具体的某个软件 $ brew upgrade &lt;apk&gt; #升级具体的某个软件 $ brew cleanup #删除所有程序的老版本 $ brew cleanup &lt;apk&gt; #删除体的某个程序的老版本 $ brew -v #查看Homebrew的版本 $ brew -h #查看Homebrew帮助文档 #相关服务命令 $ brew services list #查看使用brew安装的服务列表 $ brew services run formula|--all #启动服务（仅启动不注册） $ brew services start formula|--all #启动服务，并注册 $ brew services stop formula|--all #停止服务，并取消注册 $ brew services restart formula|--all #重启服务，并注册 $ brew services cleanup #清除已卸载应用的无用的配置 运行命令 brew install packageName 时，结果界面一直卡在Updating Homebrew上，有两种解决办法: 1.关闭brew每次执行命令时的自动更新（推荐） $ vi ~/.bash_profile # 新增一行 $ export HOMEBREW_NO_AUTO_UPDATE=true 2.出现Updating Homebrew的时候ctrl+c一下就行了。 四，将软件安装源替换为国内镜像但是由于国内网络问题，国外资源安装比较慢，我们需要替换Homebrew的镜像源。比如：采用阿里大厂的1.替换brew.git: $ cd &quot;$(brew --repo)&quot; $ git remote set-url origin https://github.com/Homebrew/brew.git #这个是原始的安装源地址 $ git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git #阿里的镜像地址 2.替换homebrew-core.git: $ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; $ git remote set-url origin https://github.com/Homebrew/homebrew-core.git #这个是原始的安装 $ git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git #阿里的镜像地址 3.替换homebrew-cask.git: $ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&quot; $ git remote set-url origin https://github.com/Homebrew/homebrew-cask.git #这个是原始的安装 $ git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-cask.git #阿里的镜像地址 4.替换homebrew-bottles(二进制预编译包的镜像)： $ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile $ source ~/.bash_profile #将刚添加到~/.bash_profile文件的语句注释掉即可 也可以使用清华大学的镜像站： $ git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git $ git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git $ git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git $ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile $ source ~/.bash_profile $ brew update 五，卸载 Homebrew$ cd `brew --prefix` $ rm -rf Cellar $ brew prune $ rm `git ls-files` $ rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions $ rm -rf .git $ rm -rf ~/Library/Caches/Homebrew","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"https://lbvs86823.github.io/tags/homebrew/"},{"name":"tool","slug":"tool","permalink":"https://lbvs86823.github.io/tags/tool/"},{"name":"mac os","slug":"mac-os","permalink":"https://lbvs86823.github.io/tags/mac-os/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"MyBatis 转义字符处理","slug":"mybatis/mybatis_special_char","date":"2015-05-18T03:13:19.000Z","updated":"2020-03-20T06:27:43.656Z","comments":true,"path":"2015/05/18/mybatis/mybatis_special_char/","link":"","permalink":"https://lbvs86823.github.io/2015/05/18/mybatis/mybatis_special_char/","excerpt":"","text":"对中对特殊字符的处理 字符 转义字符 备注 &lt; &amp;lt; 小于 &gt; &amp;gt; 大于 &amp; &amp;amp; 与 ‘ &amp;apos; 单引号 ” &amp;quot; 双引号 &lt;![CDATA[ xxxxxxx ]]&gt; 在括号中包括的特殊字符mybatis不会解析。 对值替换的处理基本上 #{} 和 ${} 是 Mybatis 中两种常见的值替换方式。 #{} 是预编译处理，再sql语句中会替换成 ? 在 PreparedStatement 动态编译的时候赋值，如果传入的字符串会自动在两侧加上 &#39;&#39; 单引号；${} 是字符串替换，会替换成变量的值，且不会自动加 &#39;&#39; 使用 ${} 会导致sql注入，不利于系统的安全性！ public class GenericTokenParser { private final String openToken; private final String closeToken; private final TokenHandler handler; public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) { this.openToken = openToken; this.closeToken = closeToken; this.handler = handler; } public String parse(String text) { if (text == null || text.isEmpty()) { return &quot;&quot;; } // search open token int start = text.indexOf(openToken); if (start == -1) { return text; } char[] src = text.toCharArray(); int offset = 0; final StringBuilder builder = new StringBuilder(); StringBuilder expression = null; while (start &gt; -1) { if (start &gt; 0 &amp;&amp; src[start - 1] == &apos;\\\\&apos;) { // this open token is escaped. remove the backslash and continue. builder.append(src, offset, start - offset - 1).append(openToken); offset = start + openToken.length(); } else { // found open token. let&apos;s search close token. if (expression == null) { expression = new StringBuilder(); } else { expression.setLength(0); } builder.append(src, offset, start - offset); offset = start + openToken.length(); int end = text.indexOf(closeToken, offset); while (end &gt; -1) { if (end &gt; offset &amp;&amp; src[end - 1] == &apos;\\\\&apos;) { // this close token is escaped. remove the backslash and continue. expression.append(src, offset, end - offset - 1).append(closeToken); offset = end + closeToken.length(); end = text.indexOf(closeToken, offset); } else { expression.append(src, offset, end - offset); break; } } if (end == -1) { // close token was not found. builder.append(src, start, src.length - start); offset = src.length; } else { builder.append(handler.handleToken(expression.toString())); offset = end + closeToken.length(); } } start = text.indexOf(openToken, offset); } if (offset &lt; src.length) { builder.append(src, offset, src.length - offset); } return builder.toString(); } }","categories":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lbvs86823.github.io/tags/MyBatis/"}],"keywords":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}]},{"title":"中介者模式","slug":"patterns/mediator","date":"2015-03-04T03:01:33.000Z","updated":"2021-08-20T08:46:49.283Z","comments":true,"path":"2015/03/04/patterns/mediator/","link":"","permalink":"https://lbvs86823.github.io/2015/03/04/patterns/mediator/","excerpt":"","text":"一.简介中介者模式是定义一个中介者角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变他们之间的交互。 二.结构中介者模式包含以下角色： 抽象中介者(Mediator)类 ：提供了注册与转发同事对象信息的抽象方法。 具体的中介者(Concrete Mediator)类：实现抽象中介者，定义一个容器来管理同事对象，协调各个同事之间的交互关系。 抽象同事(Colleague)类: 定义保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能 具体同事(Concrete Colleague)类: 抽象同事类的实现者， 当需要与其他同事对象交互时，由中介者对象赋值后续的交互。 三.实现public interface Mediator { void contact(Person person, String msg); } public abstract class Person { protected String name; protected Mediator mediator; public Person(String name, Mediator mediator) { this.name = name; this.mediator = mediator; } } public class Tenant extends Person { public Tenant(String name, Mediator mediator) { super(name, mediator); } public void say(String msg) { mediator.contact(this, msg); } public void listen(String msg) { System.out.println(&quot;租客 &quot; + name + &quot; 收到消息：&quot; + msg); } } public class HouseOwner extends Person { public HouseOwner(String name, Mediator mediator) { super(name, mediator); } public void say(String msg) { mediator.contact(this, msg); } public void listen(String msg) { System.out.println(&quot;房主 &quot; + name + &quot; 收到消息：&quot; + msg); } } public class MediatorCompany implements Mediator { private HouseOwner houseOwner; private Tenant tenant; @Override public void contact(Person person, String msg) { if (person == houseOwner){ tenant.listen(msg); }else { houseOwner.listen(msg); } } public void setHouseOwner(HouseOwner houseOwner) { this.houseOwner = houseOwner; } public void setTenant(Tenant tenant) { this.tenant = tenant; } } public static void main(String[] args) { MediatorCompany company = new MediatorCompany(); Tenant tenant = new Tenant(&quot;张三&quot;, company); HouseOwner owner = new HouseOwner(&quot;李四&quot;, company); company.setTenant(tenant); company.setHouseOwner(owner); tenant.say(&quot;我要租房子&quot;); owner.say(&quot;我有一套房子要出租&quot;); } // =============输出结果================== 房主 李四 收到消息：我要租房子 租客 张三 收到消息：我有一套房子要出租","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"mediator","slug":"mediator","permalink":"https://lbvs86823.github.io/tags/mediator/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"命令模式","slug":"patterns/commond","date":"2015-03-04T02:43:22.000Z","updated":"2021-08-19T09:56:00.028Z","comments":true,"path":"2015/03/04/patterns/commond/","link":"","permalink":"https://lbvs86823.github.io/2015/03/04/patterns/commond/","excerpt":"","text":"一.简介命令模式是将请求封装在对象的内部。当在整个调用过程比较复杂，或者存在多处这种调用机制，这时使用命令模式对该调用加以封装，便于功能的再利用。 调用前后需要进行某些额外的操作(参数处理，日志，缓存，记录历史操作等。。) 二.结构命令模式包含以下角色： 抽象命令(Command)类 ：定义命令接口，声明执行的方法 具体命令(Concrete Command)类：实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作 接收者(Receiver)类: 接收者是真正执行命令的对象，任何类都可能成为一个接收者，只要他能够实现命令要求实现的相应功能 调用者(Invoker)类： 要求命令对象执行请求，通常会持有命令对象，可以持有多个命令对象，这里是真正触发命令并要求命令执行相应操作的地方，即命令的入口 三.实现public abstract class Command { public abstract void exec(); public abstract void undo(); } public class LightReceiver { public void on() { System.out.println(&quot;打开电灯&quot;); } public void off() { System.out.println(&quot;关闭电灯&quot;); } } public class LightOn extends Command { private LightReceiver receiver; public LightOn(LightReceiver receiver) { this.receiver = receiver; } @Override public void exec() { receiver.on(); } @Override public void undo() { receiver.off(); } } public class LightOff extends Command { private LightReceiver receiver; public LightOff(LightReceiver receiver) { this.receiver = receiver; } @Override public void exec() { receiver.off(); } @Override public void undo() { receiver.on(); } } public class Invoker { Map&lt;String, Command&gt; onMap = new HashMap&lt;&gt;(); Map&lt;String, Command&gt; offMap = new HashMap&lt;&gt;(); Map&lt;String, Command&gt; ondoMap = new HashMap&lt;&gt;(); public void initCommand(String target, Command on, Command off) { onMap.put(target, on); offMap.put(target, off); } public void turnOn(String target) { onMap.get(target).exec(); ondoMap.put(target, onMap.get(target)); } public void turnOff(String target) { offMap.get(target).exec(); ondoMap.put(target, offMap.get(target)); } public void undo(String target) { offMap.get(target).undo(); } } public static void main(String[] args) { LightReceiver lightReceiver = new LightReceiver(); LightOn on = new LightOn(lightReceiver); LightOff off = new LightOff(lightReceiver); Invoker invoker = new Invoker(); invoker.initCommand(&quot;light&quot;, on, off); invoker.turnOn(&quot;light&quot;); invoker.turnOff(&quot;light&quot;); invoker.undo(&quot;light&quot;); } // =================输出结果=================== 打开电灯 关闭电灯 打开电灯 四 Spring中的典型应用JdbcTemplate","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"commond","slug":"commond","permalink":"https://lbvs86823.github.io/tags/commond/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"状态模式","slug":"patterns/state","date":"2015-03-04T00:45:12.000Z","updated":"2021-08-20T07:03:36.036Z","comments":true,"path":"2015/03/04/patterns/state/","link":"","permalink":"https://lbvs86823.github.io/2015/03/04/patterns/state/","excerpt":"","text":"一.简介状态模式是主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为一一对应，状态之间可以相互转换。当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了类。 二.结构状态模式包含以下角色： 抽象状态(State)类 ：定义一个接口，用来封装环境对象中的特定状态所对应的行为 具体的状态(Concrete State)类：实现抽象状态所对应的行为 环境(Context)类: 上下文，定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态的对象来处理。 三.实现public abstract class LiftSate { protected Context context; public void setContext(Context context) { this.context = context; } abstract void open(); abstract void close(); abstract void run(); abstract void stop(); } public class OpenState extends LiftSate { @Override void open() { System.out.println(&quot;打开电梯&quot;); } @Override void close() { context.setSate(Context.CLOSE_STATE); context.close(); } @Override void run() { } @Override void stop() { } } public class CloseState extends LiftSate { @Override void open() { context.setSate(Context.OPEN_STATE); context.open(); } @Override void close() { System.out.println(&quot;关闭电梯&quot;); } @Override void run() { context.setSate(Context.RUN_STATE); context.run(); } @Override void stop() { context.setSate(Context.STOP_STATE); context.stop(); } } public class RunState extends LiftSate { @Override void open() { } @Override void close() { } @Override void run() { System.out.println(&quot;电梯运行&quot;); } @Override void stop() { context.setSate(Context.STOP_STATE); context.stop(); } } public class StopState extends LiftSate { @Override void open() { context.setSate(Context.OPEN_STATE); context.open(); } @Override void close() { context.setSate(Context.CLOSE_STATE); context.close(); } @Override void run() { context.setSate(Context.RUN_STATE); context.run(); } @Override void stop() { System.out.println(&quot;电梯停止&quot;); } } public class Context { public final static OpenState OPEN_STATE = new OpenState(); public final static CloseState CLOSE_STATE = new CloseState(); public final static RunState RUN_STATE = new RunState(); public final static StopState STOP_STATE = new StopState(); private LiftSate sate; public LiftSate getSate() { return sate; } public void setSate(LiftSate sate) { this.sate = sate; this.sate.setContext(this); } void open() { this.sate.open(); } void close() { this.sate.close(); } void run() { this.sate.run(); } void stop() { this.sate.stop(); } } public static void main(String[] args) { //Context context = new Context(); //context.setSate(new OpenState()); //context.setSate(new CloseState()); context.setSate(new RunState()); context.open(); context.run(); context.close(); context.stop(); } 将所有与某个状态有关的行为放到一个类中，并且可以方便的增加新的状态，只需要改变对象状态即可改变对象的行为。允许状态的转换逻辑与状态对象合成一体，而不是某个巨大的条件语句块。 使用场景： 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式 一个操作含有庞大的分支结构，并且这些分支决定对象的状态时","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"state","slug":"state","permalink":"https://lbvs86823.github.io/tags/state/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"迭代器模式","slug":"patterns/iterator","date":"2015-03-03T03:33:41.000Z","updated":"2021-08-18T02:36:58.474Z","comments":true,"path":"2015/03/03/patterns/iterator/","link":"","permalink":"https://lbvs86823.github.io/2015/03/03/patterns/iterator/","excerpt":"","text":"一.简介迭代器模式是提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 二.结构迭代器模式包含以下角色： 抽象聚合(Aggreate)类 ：定义存储，添加，删除聚合元素以及创建迭代器对象的接口 具体聚合(Concrete Aggreate)类：实现抽象聚合类，返回一个具体的迭代器的实例 抽象迭代器(Iterator)类: 定义访问和遍历聚合元素的接口，通常包括hasNext(), next()等方法 具体迭代器(Concrete Iterator)类: 实现抽象迭代器接口中定义的方法，完成对聚合对象的遍历，记录遍历的当前位置 三.实现public interface Iterator&lt;E&gt; { boolean hasNext(); E next(); } public class ArrayIterator&lt;E&gt; implements Iterator { private E[] elements; private int index = -1; public ArrayIterator(E[] elements) { this.elements = elements; } @Override public boolean hasNext() { if (elements == null || index &gt;= elements.length - 1) { return false; } return true; } @Override public Object next() { index++; if (index &gt; elements.length - 1) { throw new ArrayIndexOutOfBoundsException(index); } return elements[index]; } } public class ListIterator&lt;E&gt; implements Iterator { private List&lt;E&gt; elements; private int index = -1; public ListIterator(List&lt;E&gt; elements) { this.elements = elements; } @Override public boolean hasNext() { if (elements == null || index &gt;= elements.size()-1) { return false; } return true; } @Override public Object next() { index++; if (index &gt;= elements.size()) { throw new ArrayIndexOutOfBoundsException(index); } return elements.get(index); } } public interface Aggregate&lt;E&gt; { Iterator&lt;E&gt; iterator(); void add(E element); } public class ArrayAggregate implements Aggregate&lt;String&gt; { private String[] elements; private int index = -1; public ArrayAggregate() { elements = new String[10]; } @Override public Iterator&lt;String&gt; iterator() { return new ArrayIterator&lt;String&gt;(elements); } @Override public void add(String element) { index++; if (index &gt; elements.length - 1) { throw new ArrayIndexOutOfBoundsException(index); } elements[index] = element; } } public class ListAggregate implements Aggregate&lt;String&gt; { private List&lt;String&gt; elements; public ListAggregate() { elements = new ArrayList&lt;&gt;(); } @Override public Iterator&lt;String&gt; iterator() { return new ListIterator&lt;String&gt;(elements); } @Override public void add(String element) { elements.add(element); } } public static void main(String[] args) { ArrayAggregate arr = new ArrayAggregate(); for (int x = 0; x &lt; 10; x++) { arr.add(&quot;arr of element&quot; + (x + 1)); } Iterator&lt;String&gt; it = arr.iterator(); while (it.hasNext()) { System.out.println(it.next()); } ListAggregate list = new ListAggregate(); for (int x = 0; x &lt; 10; x++) { list.add(&quot;list of element&quot; + (x + 1)); } it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } 四 JDK中的ArrayList 中的迭代器实现public Iterator&lt;E&gt; iterator() { return new Itr(); } /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } List集合ListIterator和Iterator迭代器区别与用法 相同点：都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。 不同点： 使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。 ListIterator有add方法，可以向List中添加对象，而Iterator不能。 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。 ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"iterator","slug":"iterator","permalink":"https://lbvs86823.github.io/tags/iterator/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"备忘录模式","slug":"patterns/memento","date":"2015-03-03T01:29:59.000Z","updated":"2021-08-19T01:30:45.364Z","comments":true,"path":"2015/03/03/patterns/memento/","link":"","permalink":"https://lbvs86823.github.io/2015/03/03/patterns/memento/","excerpt":"","text":"一.简介备忘录模式是为对象状态提供存储和恢复功能(比如典型的”执行和撤销 “操作)。借助备忘录模式，可以捕获对象的状态，以便于将来把对象恢复为以前的状态，具体采用哪种方式来存储对象的状态，取决于对象状态需要保存的时间长短。 二.结构备忘录式包含以下角色： 发起人(Originator)类 ：记录当前时刻内部的状态信息，提供创建备忘录和恢复备忘录数据的功能，它可以访问备忘录里面的所有信息 备忘录(Memento)类：负责存储内部状态信息，在需要的时候提供给发起人使用。 管理者(Caretaker)类: 对备忘录进行管理，提供保存，获取备忘录的功能，但是不对备忘录中的内容进行任何操作。 三.实现public class Memento { protected String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } public class Originator { private String state; public void display() { System.out.println(&quot;当前状态是: &quot; + this.state); } public String getState() { return state; } public void setState(String state) { this.state = state; } public Memento save() { return new Memento(state); } public void recover(Memento memento) { this.state = memento.getState(); } } public class Caretaker { private List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;(); public void add(Memento memento) { mementos.add(memento); } public Memento get(int index) { return mementos.get(index); } } public static void main(String[] args) { Originator orig = new Originator(); orig.setState(&quot;1&quot;); Caretaker taker = new Caretaker(); taker.add(orig.save()); orig.display(); orig.setState(&quot;2&quot;); taker.add(orig.save()); orig.display(); orig.setState(&quot;3&quot;); taker.add(orig.save()); orig.display(); orig.recover(taker.get(1)); orig.display(); } // 输出结果 当前状态是: 1 当前状态是: 2 当前状态是: 3 当前状态是: 2","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"memento","slug":"memento","permalink":"https://lbvs86823.github.io/tags/memento/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"访问者模式","slug":"patterns/visitor","date":"2015-03-03T01:29:59.000Z","updated":"2021-08-18T07:58:35.514Z","comments":true,"path":"2015/03/03/patterns/visitor/","link":"","permalink":"https://lbvs86823.github.io/2015/03/03/patterns/visitor/","excerpt":"","text":"一.简介访问者模式是在不改变类层次结构的前提下，对该层次结构进行扩展。 二.结构访问者模式包含以下角色： 抽象访问者(Visitor)类 ：定义了对每个元素(Element)的访问行为，它的参数就是可以访问的元素，方法个数一般都是与元素个数相匹配 具体访问者(Concrete Visitor)类：实现抽象处理者接口，提供判断是否处理本次请求，否则将请求转给他的后继者 抽象元素(Element)类: 定义了一个接受访问者方法(accept),即每个元素都要可以被访问者访问 具体的元素(Concrete Element)类：提供接受访问者方法(accept)的具体实现，而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构：对象结构是一个抽象的表述，可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素，并且可以迭代他们，提供访问 三.实现该模式的机制包括为访问者类定义一个接口，为层次关系中的所有访问者增加一个accept()方法。accpet()方法将使用双重委派技术，将其调用委派给访问者。类层次结构中的对象可以根据其类型调用合适的visit()方法。 // 访问者 public abstract class Score { public abstract void scoreByAudience(Audience audience); public abstract void scoreByDirector(Director director); } public class Excellent extends Score { @Override public void scoreByAudience(Audience audience) { audience.setScore(95); System.out.println(&quot;观众：&quot; + audience.getName() + &quot;开始评分：&quot; + audience.getScore()); } @Override public void scoreByDirector(Director director) { director.setScore(85); System.out.println(&quot;导演：&quot; + director.getName() + &quot;开始评分：&quot; + director.getScore()); } } public class Poor extends Score { @Override public void scoreByAudience(Audience audience) { audience.setScore(45); System.out.println(&quot;观众：&quot; + audience.getName() + &quot;开始评分：&quot; + audience.getScore()); } @Override public void scoreByDirector(Director director) { director.setScore(55); System.out.println(&quot;导演：&quot; + director.getName() + &quot;开始评分：&quot; + director.getScore()); } } public abstract class Role { protected String name; protected double score; public String getName() { return name; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public abstract void accept(Score score); } public class Audience extends Role { public Audience(String name) { this.name = name; } @Override // 双重委派 public void accept(Score score) { score.scoreByAudience(this); } } public class Director extends Role { public Director(String name) { this.name = name; } @Override // 双重委派 public void accept(Score score) { score.scoreByDirector(this); } } public class Statistician { private List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); public void attach(Role role) { roleList.add(role); } public void detach(Role role) { roleList.remove(role); } public void dispay(Score scoreing) { for (Role role : roleList) { role.accept(scoreing); } } } public static void main(String[] args) { Statistician statistician = new Statistician(); statistician.attach(new Director(&quot;张艺谋&quot;)); statistician.attach(new Director(&quot;李安&quot;)); statistician.attach(new Audience(&quot;张三&quot;)); statistician.attach(new Audience(&quot;李四&quot;)); statistician.attach(new Audience(&quot;王五&quot;)); statistician.dispay(new Excellent()); System.out.println(&quot;============第二次评价=================&quot;); statistician.dispay(new Poor()); } 导演：张艺谋开始评分：85.0 导演：李安开始评分：85.0 观众：张三开始评分：95.0 观众：李四开始评分：95.0 观众：王五开始评分：95.0 ============第二次评价================= 导演：张艺谋开始评分：55.0 导演：李安开始评分：55.0 观众：张三开始评分：45.0 观众：李四开始评分：45.0 观众：王五开始评分：45.0 使用访问者模式，一般都有以下特点： 节点类型的集合时稳定的 共同发生的变化是为不同的节点添加新的功能 新功能必须适用于所有节点类型","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"visitor","slug":"visitor","permalink":"https://lbvs86823.github.io/tags/visitor/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"解释器模式","slug":"patterns/interpreter","date":"2015-03-03T01:29:59.000Z","updated":"2021-08-19T03:47:55.284Z","comments":true,"path":"2015/03/03/patterns/interpreter/","link":"","permalink":"https://lbvs86823.github.io/2015/03/03/patterns/interpreter/","excerpt":"","text":"一.简介解释器模式是让你依据事先定义好的一系列组合规则，组合可以执行对象。解释器模式创建了一个类层次，该层次中的每个类都实现或者解释了一个公共操作，并且该操作的名称与类名相同。 二.结构解释器模式包含以下角色： 抽象表达式(Abstract Expression)类 ：定义解释器的接口，约定解释器的操作，只要包含interpret()方法 终结符表达式(Terminal Expression)类：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体的终结表达式与之相对应 非终结符表达式(Nonterminal Expression)类: 也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每一条规则都对应于一个非终结符表达式 环境(Context)类：通常包含各个解释器需要的数据或者是公共的功能，一般用来传递被所有解释器共享的数据，后面解释器可以从这里获取值 客户端(Client)类： 主要任务是将需要分析的表达式转换成使用解释器对象描述的抽象语法树，让后调用解释器的解释方法，也可以通过环境类间接访问解释器的解释方法 三.实现定义语法规则：expression ::= value | plus | minusplus ::= expression ‘+’ expressionminus ::= expression ‘-‘ expressionvalue ::= int 抽象语法树（Abstract Syntax Tree AST）：简称语法树，是源代码语法结构的一种抽象表示，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。 public abstract class AbstractExpression { public abstract int interpret(Context context); } public class Var extends AbstractExpression { private String name; public Var(String name) { this.name = name; } @Override public int interpret(Context context) { return context.getValue(this); } @Override public String toString() { return name; } } public class Plus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Plus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) + right.interpret(context); } @Override public String toString() { return &quot;(&quot; + left.toString() + &quot; + &quot; + right.toString() + &quot;)&quot;; } } public class Minus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Minus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) - right.interpret(context); } @Override public String toString() { return &quot;(&quot; + left.toString() + &quot; - &quot; + right.toString() + &quot;)&quot;; } } public class Context { private Map&lt;Var, Integer&gt; cache = new HashMap&lt;&gt;(); public void assign(Var var, Integer value) { cache.put(var, value); } public int getValue(Var var) { return cache.get(var); } } public static void main(String[] args) { Context context = new Context(); Var a = new Var(&quot;a&quot;); Var b = new Var(&quot;b&quot;); Var c = new Var(&quot;c&quot;); Var d = new Var(&quot;d&quot;); Var e = new Var(&quot;e&quot;); context.assign(a, 1); context.assign(b, 2); context.assign(c, 3); context.assign(d, 4); context.assign(e, 5); AbstractExpression expression = new Minus(new Plus(d, new Plus(c, new Plus(a, b))), e); int result = expression.interpret(context); System.out.println(expression + &quot; = &quot; + result); } // 输出结果 ((d + (c + (a + b))) - e) = 5 使用场景： 当语言的文法较为简单，且执行效率不是关键问题时 当问题重复出现，且可以用一种简单语言来进行表达时 当一个语言需要解释执行，且语言中的句子可以表示为一个抽象语法树的时候","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"interpreter","slug":"interpreter","permalink":"https://lbvs86823.github.io/tags/interpreter/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"观察者模式","slug":"patterns/observer","date":"2015-03-03T00:53:55.000Z","updated":"2021-08-16T09:46:57.417Z","comments":true,"path":"2015/03/03/patterns/observer/","link":"","permalink":"https://lbvs86823.github.io/2015/03/03/patterns/observer/","excerpt":"","text":"一.简介Observer模式定义对象间的一对多的依赖关系,当一个对象（被观察者）的状态发生改变时, 所有依赖于它的对象（观察者）都得到通知并被自动更新。 二.结构观察者模式包含以下角色： 抽象主题（Subject）：抽象被观察者(Observable),把所有的观察者对象的引用保存在一个列表里；每个主题都可以有任何数量的观察者。主题提供一个接口可以加上或撤销观察者对象。 具体主题（ConcreteSubject）：具体被观察者，保存对具体观察者对象有用的内部状态；在这种内部状态改变时给其观察者发出一个通知； 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到通知时更新自己； 具体观察者（ConcreteObserver）角色：保存一个指向具体主题对象的引用；和一个与主题的状态相符的状态。具体观察者角色实现抽象观察者角色所要求的更新自己的接口，以便使本身的状态与主题的状态自恰。 三.实现 推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 //抽象观察者角色类 public interface Observer { /** * 更新接口 * @param state 更新的状态 */ public void update(String state); } //具体观察者角色类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(String state) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println(&quot;状态为：&quot;+observerState); } } //抽象主题角色 public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(&quot;Attached an observer&quot;); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer) { list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void notifyObservers(String newState) { for(Observer observer : list){ observer.update(newState); } } } //具体主题角色类 public class ConcreteSubject extends Subject { private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(&quot;主题状态为：&quot; + state); //状态发生改变，通知各个观察者 this.notifyObservers(state); } } //客户端类 public class Client { public static void main(String[] args) { //创建主题对象 ConcreteSubject subject = new ConcreteSubject(); //创建观察者对象 Observer observer = new ConcreteObserver(); //将观察者对象登记到主题对象上 subject.attach(observer); //改变主题对象的状态 subject.change(&quot;new state&quot;); } } 拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 //抽象观察者类（拉模型通常都是把主题对象当做参数传递）。 public interface Observer { /** * 更新接口 * @param subject 传入主题对象，方面获取相应的主题对象的状态 */ public void update(Subject subject); } //具体观察者类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(Subject subject) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = ((ConcreteSubject)subject).getState(); System.out.println(&quot;观察者状态为：&quot;+observerState); } } //抽象主题类(拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了)。 public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(&quot;Attached an observer&quot;); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer){ list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void notifyObservers(){ for(Observer observer : list){ observer.update(this); } } } //具体主题类(跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了)。 public class ConcreteSubject extends Subject{ private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(&quot;主题状态为：&quot; + state); //状态发生改变，通知各个观察者 this.notifyObservers(); } } 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 四 JDK中观察者模式实现在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 public interface Observer { void update(Observable o, Object arg); } Observable类被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。 第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 public class Observable { private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() { obs = new Vector(); } /** * 将一个观察者添加到观察者聚集上面 */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * 将一个观察者从观察者聚集上删除 */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } public void notifyObservers() { notifyObservers(null); } /** * 如果本对象有变化（那时hasChanged 方法会返回true） * 调用本方法通知所有登记的观察者，即调用它们的update()方法 * 传入this和arg作为参数 */ public void notifyObservers(Object arg) { Object[] arrLocal; synchronized (this) { if (!changed) return; arrLocal = obs.toArray(); clearChanged(); } for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); } /** * 将观察者聚集清空 */ public synchronized void deleteObservers() { obs.removeAllElements(); } /** * 将“已变化”设置为true */ protected synchronized void setChanged() { changed = true; } /** * 将“已变化”重置为false */ protected synchronized void clearChanged() { changed = false; } /** * 检测本对象是否已变化 */ public synchronized boolean hasChanged() { return changed; } /** * Returns the number of observers of this &lt;tt&gt;Observable&lt;/tt&gt; object. * * @return the number of observers of this object. */ public synchronized int countObservers() { return obs.size(); } } 这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的notifyObservers()方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。 //被观察者Watched类 public class Watched extends Observable{ private String data = &quot;&quot;; public String getData() { return data; } public void setData(String data) { if(!this.data.equals(data)){ this.data = data; setChanged(); } notifyObservers(); } } //观察者类 public class Watcher implements Observer{ public Watcher(Observable o){ o.addObserver(this); } @Override public void update(Observable o, Object arg) { System.out.println(&quot;状态发生改变：&quot; + ((Watched)o).getData()); } } //测试类 public class Test { public static void main(String[] args) { //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData(&quot;start&quot;); watched.setData(&quot;run&quot;); watched.setData(&quot;stop&quot;); } }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"observer","slug":"observer","permalink":"https://lbvs86823.github.io/tags/observer/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"模板方法模式","slug":"patterns/templateMethod","date":"2015-03-02T13:53:12.000Z","updated":"2021-08-16T06:51:20.224Z","comments":true,"path":"2015/03/02/patterns/templateMethod/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/templateMethod/","excerpt":"","text":"一.简介模板方法模式是基于继承的代码复用的基本技术；准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。 模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 模板方法模式中的方法 模板方法中的方法可以分为两大类：模板方法和基本方法。 模板方法一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 基本方法基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 二.结构模板方法模式包含以下角色： 抽象模板(Abstract Template)角色有如下责任：定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任：实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 三.实现//抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 public abstract class AbstractTemplate { /** * 模板方法 */ public final void templateMethod(){ //调用基本方法 abstractMethod(); hookMethod(); concreteMethod(); } /** * 基本方法的声明（由子类实现） */ protected abstract void abstractMethod(); /** * 基本方法(空方法) */ protected void hookMethod(){} /** * 基本方法（已经实现） */ private final void concreteMethod(){ //业务相关的代码 } } //具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。 public class ConcreteTemplate extends AbstractTemplate{ //基本方法的实现 @Override public void abstractMethod() { //业务相关的代码 } //重写父类的方法 @Override public void hookMethod() { //业务相关的代码 } } 在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 默认钩子方法 一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。 命名规则 命名规则是设计师之间赖以沟通的管道之一，使用恰当的命名规则可以帮助不同设计师之间的沟通。 钩子方法的名字应当以do开始，这是熟悉设计模式的Java开发人员的标准做法。在上面的例子中，钩子方法hookMethod()应当以do开头；在HttpServlet类中，也遵从这一命名规则，如doGet()、doPost()等方法。 四 模板方法模式在Servlet中的应用使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。HttpService类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。 Collections类的sort()方法也是一个典型的模板方法。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn&apos;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp); } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req,resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req,resp); } else { // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); } }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"templateMethod","slug":"templateMethod","permalink":"https://lbvs86823.github.io/tags/templateMethod/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"享元模式","slug":"patterns/flyweight","date":"2015-03-02T11:33:42.000Z","updated":"2021-08-16T03:24:59.603Z","comments":true,"path":"2015/03/02/patterns/flyweight/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/flyweight/","excerpt":"","text":"一.简介享元模式的用意就是通过共享来有效的支持大量细粒度的对象,避免相似的对象大量创建，增加系统开销，提高系统资源利用率。 享元对象必须是不可变的，可以将那些需要共享的，并且不变的部分提取出来。为了保证你的享元对象能够被共享，需要提供并强制客户对象使用享元工厂来查找享元对象。 二.结构享元模式包含以下角色： 抽象享元(Flyweight)类 ：抽象的声明公共方法，这些方法可以向外界提供享元对象的内部数据的访问方法。 具体享元(Concrete Flyweight)类：实现了抽象享元的类，即享元对象，在具体的享元类中为内部状态提供了存储空间，通常我们可以结合单例模式来设计具体的享元类，为每一个具体的享元类提供唯一的享元对象。 非享元(UnSharable Flyweight)类: 不能被共享的子类可以设计为非共享具体享元类，它能直接被实例化。 享元工厂(Flyweight Factory)：负责创建和管理享元角色，当客户需要请求一个享元对象时，工厂先检查是否已经存在，存在直接返回，不存在则创建一个新的，并且存储下来。 三.实现public abstract class Shape { public abstract String getShape(); public abstract void display(String color); } public class IShape extends Shape { @Override public String getShape() { return &quot;I&quot;; } @Override public void display(String color) { System.out.println(getShape()+ &quot;图形 显示颜色：&quot; +color); } } public class LShape extends Shape { @Override public String getShape() { return &quot;L&quot;; } @Override public void display(String color) { System.out.println(getShape()+ &quot;图形 显示颜色：&quot; +color); } } public class ShapeFactory { private static ShapeFactory factory = new ShapeFactory(); private HashMap&lt;String, Shape&gt; shapes; private ShapeFactory() { shapes = new HashMap&lt;&gt;(); shapes.put(&quot;I&quot;, new IShape()); shapes.put(&quot;T&quot;, new TShape()); shapes.put(&quot;Z&quot;, new ZShape()); shapes.put(&quot;L&quot;, new LShape()); } public static ShapeFactory getInstance() { return factory; } public Shape getShape(String type) { return shapes.get(type); } } public static void main(String[] args) { Shape shape1 = ShapeFactory.getInstance().getShape(&quot;L&quot;); Shape shape2 = ShapeFactory.getInstance().getShape(&quot;Z&quot;); shape2.display(&quot;red&quot;); Shape shape3 = ShapeFactory.getInstance().getShape(&quot;L&quot;); Shape shape4 = ShapeFactory.getInstance().getShape(&quot;Z&quot;); shape4.display(&quot;blue&quot;); System.out.println(shape2 == shape4); } 四 JDK中的 Integer类还有比如 数据库连接池， String 常量池， 缓冲池等，都是享元模式的应用。 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"flyweight","slug":"flyweight","permalink":"https://lbvs86823.github.io/tags/flyweight/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"合成模式","slug":"patterns/composite","date":"2015-03-02T08:55:41.000Z","updated":"2021-08-13T09:39:00.511Z","comments":true,"path":"2015/03/02/patterns/composite/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/composite/","excerpt":"","text":"一.简介合成模式把部分和整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由它们复合而成的合成对象同等看待。 一个文件系统就是一个典型的合成模式系统。显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。合成模式可以不提供父对象的管理方法，但是合成模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。 合成模式的实现根据所实现接口的区别分为两种形式 安全式安全模式的合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。安全式合成模式的缺点是不够透明，因为树叶类和树枝类将具有不同的接口。 透明式。透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。 二.结构合成模式包含以下角色： 抽象根节点(component)类 ：定义系统各个层次对象共有方法和属性，可以预先定义一些默认行为和属性。它可以用来管理所有的子对象，合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。 树枝节点(composite)类：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。 叶子节点(Leaf)类: 叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 三.实现//抽象构件角色类 public interface Component { /** * 输出组建自身的名称 */ public void printStruct(String preStr); } //树枝构件角色类 public class Composite implements Component { /** * 用来存储组合对象中包含的子组件对象 */ private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;(); /** * 组合对象的名字 */ private String name; /** * 构造方法，传入组合对象的名字 * @param name 组合对象的名字 */ public Composite(String name){ this.name = name; } /** * 聚集管理方法，增加一个子构件对象 * @param child 子构件对象 */ public void addChild(Component child){ childComponents.add(child); } /** * 聚集管理方法，删除一个子构件对象 * @param index 子构件对象的下标 */ public void removeChild(int index){ childComponents.remove(index); } /** * 聚集管理方法，返回所有子构件对象 */ public List&lt;Component&gt; getChild(){ return childComponents; } /** * 输出对象的自身结构 * @param preStr 前缀，主要是按照层级拼接空格，实现向后缩进 */ @Override public void printStruct(String preStr) { // 先把自己输出 System.out.println(preStr + &quot;+&quot; + this.name); //如果还包含有子组件，那么就输出这些子组件对象 if(this.childComponents != null){ //添加两个空格，表示向后缩进两个空格 preStr += &quot; &quot;; //输出当前对象的子对象 for(Component c : childComponents){ //递归输出每个子对象 c.printStruct(preStr); } } } } //树叶构件角色类 public class Leaf implements Component { /** * 叶子对象的名字 */ private String name; /** * 构造方法，传入叶子对象的名称 * @param name 叶子对象的名字 */ public Leaf(String name){ this.name = name; } /** * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字 * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进 */ @Override public void printStruct(String preStr) { // TODO Auto-generated method stub System.out.println(preStr + &quot;-&quot; + name); } } //客户端类 public class Client { public static void main(String[]args){ Composite root = new Composite(&quot;服装&quot;); Composite c1 = new Composite(&quot;男装&quot;); Composite c2 = new Composite(&quot;女装&quot;); Leaf leaf1 = new Leaf(&quot;衬衫&quot;); Leaf leaf2 = new Leaf(&quot;夹克&quot;); Leaf leaf3 = new Leaf(&quot;裙子&quot;); Leaf leaf4 = new Leaf(&quot;套装&quot;); root.addChild(c1); root.addChild(c2); c1.addChild(leaf1); c1.addChild(leaf2); c2.addChild(leaf3); c2.addChild(leaf4); root.printStruct(&quot;&quot;); } } 可以看出，树枝构件类(Composite)给出了addChild()、removeChild()以及getChild()等方法的声明和实现，而树叶构件类则没有给出这些方法的声明或实现。这样的做法是安全的做法，由于这个特点，客户端应用程序不可能错误地调用树叶构件的聚集方法，因为树叶构件没有这些方法，调用会导致编译错误。 重构成透明模式代码: //抽象构件角色类 public abstract class Component { /** * 输出组建自身的名称 */ public abstract void printStruct(String preStr); /** * 聚集管理方法，增加一个子构件对象 * @param child 子构件对象 */ public void addChild(Component child){ /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } /** * 聚集管理方法，删除一个子构件对象 * @param index 子构件对象的下标 */ public void removeChild(int index){ /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } /** * 聚集管理方法，返回所有子构件对象 */ public List&lt;Component&gt; getChild(){ /** * 缺省实现，抛出异常，因为叶子对象没有此功能 * 或者子组件没有实现这个功能 */ throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } } //树枝构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。 public class Composite extends Component { /** * 用来存储组合对象中包含的子组件对象 */ private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;(); /** * 组合对象的名字 */ private String name; /** * 构造方法，传入组合对象的名字 * @param name 组合对象的名字 */ public Composite(String name){ this.name = name; } /** * 聚集管理方法，增加一个子构件对象 * @param child 子构件对象 */ public void addChild(Component child){ childComponents.add(child); } /** * 聚集管理方法，删除一个子构件对象 * @param index 子构件对象的下标 */ public void removeChild(int index){ childComponents.remove(index); } /** * 聚集管理方法，返回所有子构件对象 */ public List&lt;Component&gt; getChild(){ return childComponents; } /** * 输出对象的自身结构 * @param preStr 前缀，主要是按照层级拼接空格，实现向后缩进 */ @Override public void printStruct(String preStr) { // 先把自己输出 System.out.println(preStr + &quot;+&quot; + this.name); //如果还包含有子组件，那么就输出这些子组件对象 if(this.childComponents != null){ //添加两个空格，表示向后缩进两个空格 preStr += &quot; &quot;; //输出当前对象的子对象 for(Component c : childComponents){ //递归输出每个子对象 c.printStruct(preStr); } } } } //树叶构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。 public class Leaf extends Component { /** * 叶子对象的名字 */ private String name; /** * 构造方法，传入叶子对象的名称 * @param name 叶子对象的名字 */ public Leaf(String name){ this.name = name; } /** * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字 * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进 */ @Override public void printStruct(String preStr) { // TODO Auto-generated method stub System.out.println(preStr + &quot;-&quot; + name); } } //客户端类的主要变化是不再区分Composite对象和Leaf对象。 public class Client { public static void main(String[]args){ Component root = new Composite(&quot;服装&quot;); Component c1 = new Composite(&quot;男装&quot;); Component c2 = new Composite(&quot;女装&quot;); Component leaf1 = new Leaf(&quot;衬衫&quot;); Component leaf2 = new Leaf(&quot;夹克&quot;); Component leaf3 = new Leaf(&quot;裙子&quot;); Component leaf4 = new Leaf(&quot;套装&quot;); root.addChild(c1); root.addChild(c2); c1.addChild(leaf1); c1.addChild(leaf2); c2.addChild(leaf3); c2.addChild(leaf4); root.printStruct(&quot;&quot;); } } 这里所说的安全性合成模式是指： 从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。这里所说的透明性合成模式是指： 从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。 如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。 对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是：让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而且对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用合成模式的时候，建议多采用透明性的实现方式。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"composite","slug":"composite","permalink":"https://lbvs86823.github.io/tags/composite/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"桥接模式","slug":"patterns/bridge","date":"2015-03-02T06:13:02.000Z","updated":"2021-08-13T08:58:25.559Z","comments":true,"path":"2015/03/02/patterns/bridge/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/bridge/","excerpt":"","text":"一.简介桥接模式的用意就是将抽象化与实现化脱耦，使得二者可以独立的变化。 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时当一个系统不希望使用继承或者因为多层次继承导致系统类的个数急剧增加时当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使他们在抽象层建立一个关联关系。 二.结构桥接模式包含以下角色： 抽象化(Abstraction)类 ：抽象化给出的定义，并保存一个对实现化对象的引用 扩展抽象化(Refined Abstraction)类：扩展抽象化类角色，改变或者修正父类对抽象化的定义 实现化(Implementor)类: 定义实现化角色的接口，供扩展抽象化角色调用 具体实现化(Concrete Implementor)：给出实现化接口的具体实现。 每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。 降低了子系统与客户之间的耦合度，使得子系统的变化不会影响调用它的客户类。对客户屏蔽了子系统的组件，减少了客户处理的对象数量，并且使得子系统使用起来更加的容易。但是它不符合开闭原则，修改起来比较复杂。 三.实现public abstract class OS { abstract public void play(String filePath); protected Video video; } public class MacOS extends OS { public MacOS(Video video) { this.video = video; } @Override public void play(String filePath) { System.out.println(&quot;MacOs play &quot; + this.video.decode(filePath)); } } public class WindowOS extends OS { public WindowOS(Video video) { this.video = video; } @Override public void play(String filePath) { System.out.println(&quot;WindowOs play &quot; + this.video.decode(filePath)); } } public abstract class Video { abstract String decode(String filePath); } public class Avi extends Video { @Override String decode(String filePath) { return filePath + &quot; avi:啦啦啦&quot;; } } public class Rmvb extends Avi { @Override String decode(String filePath) { return filePath + &quot; rmvb:哈哈哈&quot;; } } public static void main(String[] args) { OS os = new MacOS(new Avi()); os.play(&quot;邓丽君&quot;); os = new MacOS(new Rmvb()); os.play(&quot;刘德华&quot;); os = new WindowOS(new Rmvb()); os.play(&quot;张学友&quot;); } MacOs play 邓丽君 avi:啦啦啦 MacOs play 刘德华 rmvb:哈哈哈 WindowOs play 张学友 rmvb:哈哈哈 符合开闭原则： 需要增加一个操作系统的播放器可以实现OS， 需要增加一种播放格式可以实现Video, 系统在不修改原有代码的情况下获得了扩展。符合组合聚合复用原则：适当的使用了继承关系来构建两个等级结构内部的结构，并且使用聚合关系来构建两个等级结构之间的结构。 四 JDBC驱动 使用了这个桥接模式 应用系统作为一个等级结构，与JDBC驱动器这个等级结构是相对独立的，他们之间没有静态的强关联，应用系统通过委派与JDBC驱动器相互作用，这是一个典型的桥梁(桥接)模式。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"bridge","slug":"bridge","permalink":"https://lbvs86823.github.io/tags/bridge/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"职责链模式","slug":"patterns/chain","date":"2015-03-02T06:13:02.000Z","updated":"2021-08-17T07:21:41.495Z","comments":true,"path":"2015/03/02/patterns/chain/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/chain/","excerpt":"","text":"一.简介职责链模式是为了避免请求发送者与多个请求处理者耦合在一起；将所有请求的处理者通过前一个对象的引用而连成一条链；当请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 二.结构职责链模式包含以下角色： 抽象处理者(Handler)类 ：定义一个处理请求接口，包含抽象的处理方法和一个后继连接。 具体的处理者(Concrete Handler)类：实现抽象处理者接口，提供判断是否处理本次请求，否则将请求转给他的后继者。 客户(Client)类: 创建处理链，并向链头的具体处理对象提交请求，它不必关心处理细节和请求的传递过程。 三.实现public abstract class Handler { private int threshold; protected int requestDay; private Handler next; public Handler(int threshold) { this.threshold = threshold; } public void setNextHandler(Handler next) { this.next = next; } protected abstract void doHandler(); public final void submit(int requestDay) { this.requestDay = requestDay; this.doHandler(); if (requestDay &lt;= threshold) { System.out.println(&quot;审批处理流程结束&quot;); return; } if (this.next != null) { this.next.submit(requestDay); } } } public class GroupHandler extends Handler { public GroupHandler() { // 处理2天以内的请假 super(2); } @Override protected void doHandler() { System.out.println(&quot;小组长审批， 已经同意请假 &quot; + this.requestDay + &quot; 天&quot;); } } public class ManagerHandler extends Handler { public ManagerHandler() { // 处理5天以内的请假 super(5); } @Override protected void doHandler() { System.out.println(&quot;部门经理审批， 已经同意请假 &quot; + this.requestDay + &quot; 天&quot;); } } public class GeneralHandler extends Handler { public GeneralHandler() { // 处理7天以内的请假 super(7); } @Override protected void doHandler() { System.out.println(&quot;总经理审批， 已经同意请假 &quot; + this.requestDay + &quot; 天&quot;); } } public static void main(String[] args) { GeneralHandler generalHandler = new GeneralHandler(); ManagerHandler managerHandler = new ManagerHandler(); GroupHandler groupHandler = new GroupHandler(); groupHandler.setNextHandler(managerHandler); managerHandler.setNextHandler(generalHandler); groupHandler.submit(2); System.out.println(&quot;=============================&quot;); groupHandler.submit(5); System.out.println(&quot;=============================&quot;); groupHandler.submit(7); } // 输出结果 小组长审批， 已经同意请假 2 天 审批处理流程结束 ============================= 小组长审批， 已经同意请假 5 天 部门经理审批， 已经同意请假 5 天 审批处理流程结束 ============================= 小组长审批， 已经同意请假 7 天 部门经理审批， 已经同意请假 7 天 总经理审批， 已经同意请假 7 天 审批处理流程结束 四 javaWeb中的 FilterChain是职责链的典型应用下面对 FilterChain的实现进行模拟，勾勒出主要的功能代码如下： public interface Filter { void doFilter(String request, String response, FilterChain chain); } public class Filter01 implements Filter{ @Override public void doFilter(String request, String response, FilterChain chain) { System.out.println(this.getClass().getName() + &quot; 前置处理逻辑&quot;); chain.doFilter(request, response); System.out.println(this.getClass().getName() + &quot; 后置处理逻辑&quot;); } } public class Filter02 implements Filter{ @Override public void doFilter(String request, String response, FilterChain chain) { System.out.println(this.getClass().getCanonicalName() + &quot; 前置处理逻辑&quot;); chain.doFilter(request, response); System.out.println(this.getClass().getCanonicalName() + &quot; 后置处理逻辑&quot;); } } public class FilterChain { private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); private int index = 0; public void doFilter(String request, String response) { if (index == filters.size()) { System.out.println(&quot;===========filter 遍历完毕，开始返回===============&quot;); return; } Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); } public FilterChain addFilter(Filter filter) { filters.add(filter); return this; } } public static void main(String[] args) { FilterChain chain = new FilterChain(); chain.addFilter(new Filter01()).addFilter(new Filter02()); chain.doFilter(&quot;request&quot;, &quot;response&quot;); } // 运行结果 chain.Filter01 前置处理逻辑 chain.Filter02 前置处理逻辑 ===========filter 遍历完毕，开始返回=============== chain.Filter02 后置处理逻辑 chain.Filter01 后置处理逻辑","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"chain","slug":"chain","permalink":"https://lbvs86823.github.io/tags/chain/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"策略模式","slug":"patterns/strategy","date":"2015-03-02T06:13:02.000Z","updated":"2021-08-16T08:49:29.552Z","comments":true,"path":"2015/03/02/patterns/strategy/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/strategy/","excerpt":"","text":"一.简介策略模式是通过将问题的不同解决方案封装在不同的类里，使得他们可以相互替换，且算法的变化不会影响使用算法的客户，以帮助我们组织和简化代码。 二.结构策略模式包含以下角色： 抽象化策略(Strategy)类 ：给出所有策略所需的抽象化接口。 具体策略(Concrete Strategy)类：实现抽象策略接口，提供策略的具体实现。 环境(Context)类: 持有一个策略类的引用，最终给客户调用。 三.实现public interface Strategy { public int doOperation(int x, int y); } public class Add implements Strategy { @Override public int doOperation(int x, int y) { return x + y; } } public class Substract implements Strategy { @Override public int doOperation(int x, int y) { return x - y; } } public class Multiply implements Strategy { @Override public int doOperation(int x, int y) { return x*y; } } public class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int execute(int x, int y){ return strategy.doOperation(x, y); } } public static void main(String[] args) { Context context = new Context(new Add()); System.out.println(&quot;10 + 5 = &quot; + context.execute(10, 5)); context = new Context(new Subtract()); System.out.println(&quot;10 - 5 = &quot; + context.execute(10, 5)); context = new Context(new Multiply()); System.out.println(&quot;10 * 5 = &quot; + context.execute(10, 5)); } 四 JDK中的Arrays.sort(), 配合Comparator实现了策略模式 public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) { if (c == null) { sort(a); } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); } }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"strategy","slug":"strategy","permalink":"https://lbvs86823.github.io/tags/strategy/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"外观(门面)模式","slug":"patterns/facade","date":"2015-03-02T03:33:56.000Z","updated":"2021-08-12T07:55:21.357Z","comments":true,"path":"2015/03/02/patterns/facade/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/facade/","excerpt":"","text":"一.简介门面模式是，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。 二.结构外观(门面)模式包含以下角色： 门面(Facade) ：为多个子系统对外提供一个共同的接口 子系统(SubSystem)：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。 每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。 降低了子系统与客户之间的耦合度，使得子系统的变化不会影响调用它的客户类。对客户屏蔽了子系统的组件，减少了客户处理的对象数量，并且使得子系统使用起来更加的容易。但是它不符合开闭原则，修改起来比较复杂。 三.实现//子系统角色中的类 public class ModuleA { //示意方法 public void testA(){ System.out.println(&quot;调用ModuleA中的testA方法&quot;); } } public class ModuleB { //示意方法 public void testB(){ System.out.println(&quot;调用ModuleB中的testB方法&quot;); } } public class ModuleC { //示意方法 public void testC(){ System.out.println(&quot;调用ModuleC中的testC方法&quot;); } } //门面角色类 public class Facade { //示意方法，满足客户端需要的功能 public void test(){ ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); } } //客户端角色类： public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.test(); } } 四 Request,Response上使用的门面模式在StandardWrapperValue类中并没有直接将Request对象与Response对象传递给ApplicationFilterChain类的doFilter方法，传递的是RequestFacade与ResponseFacade对象；为什么这么说呢，看一下request.getRequest()与response.getResponse()方法就真相大白了。 public HttpServletRequest getRequest() { if (facade == null) { facade = new RequestFacade(this); } return facade; } public HttpServletResponse getResponse() { if (facade == null) { facade = new ResponseFacade(this); } return facade; } Request对象中的很多方法都是内部组件之间相互交互时使用的，比如setComet、setRequestedSessionId等方法（这里就不一一列举了）。这些方法并不对外部公开，但是又必须设置为public，因为还需要跟内部组件之间交互使用。最好的解决方法就是通过使用一个Facade类，将与内部组件之间交互使用的方法屏蔽掉，只提供给外部程序感兴趣的方法。如果不使用Facade类，直接传递的是Request对象和Response对象，那么熟悉容器内部运作的程序员可以分别把ServletRequest和ServletResponse对象向下转换为Request和Response，并调用它们的公共方法。比如拥有Request对象，就可以调用setComet、setRequestedSessionId等方法，这会危害安全性。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"facade","slug":"facade","permalink":"https://lbvs86823.github.io/tags/facade/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"装饰器模式","slug":"patterns/decrator","date":"2015-03-02T02:23:02.000Z","updated":"2021-08-12T07:55:46.173Z","comments":true,"path":"2015/03/02/patterns/decrator/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/decrator/","excerpt":"","text":"一.简介装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 二.结构装饰模式包含以下角色： 抽象构件(Component)类：定义一个抽象的接口以规范准备接收附加责任的对象 具体的构件(Concrete Component)类：实现抽象构件，通过装饰角色为其添加一些职责 抽象装饰(Decrator)类：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能 具体装饰(Concrete Decrator)类: 实现抽奖装饰的相关方法，并给具体构件对象添加附加的责任 三.实现// 快餐-抽象构件 public abstract class FastFood { private String name; private int num; private double unitPrice; private double totalPrice; public FastFood(String name, int num, double price) { this.name = name; this.num = num; this.unitPrice = price; this.totalPrice = this.unitPrice * this.num; } public FastFood(String name) { this(name, 0, 0d); } public void setNum(int num) { this.num = num; } public void setUnitPrice(double unitPrice) { this.unitPrice = unitPrice; } public String getName() { return name; } public int getNum() { return num; } public double getUnitPrice() { return unitPrice; } public double getTotalPrice() { this.totalPrice = this.unitPrice * this.num; return this.totalPrice; } public abstract void printOrder(); } // 煎饼-具体构件 public class Pancake extends FastFood { public Pancake() { super(&quot;煎饼果子&quot;, 1, 2.5); } @Override public void printOrder() { System.out.println(this.getName() + &quot; 数量：&quot; + this.getNum() + &quot; 份, 单价：&quot; + this.getUnitPrice() + &quot; 元, 总价：&quot; + this.getTotalPrice() + &quot; 元&quot;); } } // 炒饭-具体构件 public class FriedPrice extends FastFood { public FriedPrice() { super(&quot;炒饭&quot;, 1, 3.0); } @Override public void printOrder() { System.out.println(this.getName() + &quot; 数量：&quot; + this.getNum() + &quot; 份, 单价：&quot; + this.getUnitPrice() + &quot; 元, 总价：&quot; + this.getTotalPrice() + &quot; 元&quot;); } } // 加配菜-抽象装饰者构件 public abstract class Append extends FastFood { private FastFood fastFood; public Append(String name, FastFood fastFood) { super(name); this.fastFood = fastFood; } public Append(String name, int num, double price, FastFood fastFood) { super(name, num, price); this.fastFood = fastFood; } public FastFood getFastFood() { return fastFood; } } // 鸡蛋-具体装饰者 public class Egg extends Append{ public Egg(FastFood fastFood) { super(&quot;鸡蛋&quot;, 1, 1, fastFood); } @Override public void printOrder() { getFastFood().printOrder(); System.out.println(this.getName() + &quot; 数量：&quot; + this.getNum() + &quot; 份, 单价：&quot; + this.getUnitPrice() + &quot; 元, 总价：&quot; + this.getTotalPrice() + &quot; 元&quot;); } } // 火腿-具体装饰者 public class Ham extends Append{ public Ham(FastFood fastFood) { super(&quot;火腿&quot;, 1, 1.5, fastFood); } @Override public void printOrder() { getFastFood().printOrder(); System.out.println(this.getName() + &quot; 数量：&quot; + this.getNum() + &quot; 份, 单价：&quot; + this.getUnitPrice() + &quot; 元, 总价：&quot; + this.getTotalPrice() + &quot; 元&quot;); } } // 测试 public static void main(String[] args) { FastFood pancake = new Pancake(); pancake.printOrder(); System.out.println(&quot;------------------------------------&quot;); pancake = new Egg(pancake); pancake.setNum(3); pancake.printOrder(); System.out.println(&quot;------------------------------------&quot;); pancake = new Ham(pancake); pancake.setNum(2); pancake.printOrder(); System.out.println(&quot;====================================================&quot;); FastFood firedPrice = new FriedPrice(); firedPrice.printOrder(); System.out.println(&quot;------------------------------------&quot;); firedPrice = new Egg(firedPrice); firedPrice.printOrder(); System.out.println(&quot;------------------------------------&quot;); firedPrice = new Ham(firedPrice); firedPrice.printOrder(); System.out.println(&quot;==================常见的层层套娃的使用方式==================================&quot;); firedPrice = new Ham(new Egg(new FriedPrice())); firedPrice.printOrder(); } // 输出-------------------------------------------------------------------------- 煎饼果子 数量：1 份, 单价：2.5 元, 总价：2.5 元 ------------------------------------ 煎饼果子 数量：1 份, 单价：2.5 元, 总价：2.5 元 鸡蛋 数量：3 份, 单价：1.0 元, 总价：3.0 元 ------------------------------------ 煎饼果子 数量：1 份, 单价：2.5 元, 总价：2.5 元 鸡蛋 数量：3 份, 单价：1.0 元, 总价：3.0 元 火腿 数量：2 份, 单价：1.5 元, 总价：3.0 元 ==================================================== 炒饭 数量：1 份, 单价：3.0 元, 总价：3.0 元 ------------------------------------ 炒饭 数量：1 份, 单价：3.0 元, 总价：3.0 元 鸡蛋 数量：1 份, 单价：1.0 元, 总价：1.0 元 ------------------------------------ 炒饭 数量：1 份, 单价：3.0 元, 总价：3.0 元 鸡蛋 数量：1 份, 单价：1.0 元, 总价：1.0 元 火腿 数量：1 份, 单价：1.5 元, 总价：1.5 元 ==================常见的层层套娃的使用方式================================== 炒饭 数量：1 份, 单价：3.0 元, 总价：3.0 元 鸡蛋 数量：1 份, 单价：1.0 元, 总价：1.0 元 火腿 数量：1 份, 单价：1.5 元, 总价：1.5 元 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性，它允许系统动态的添加或者删除一个”装饰者”。继承关系则不同，它是静态的，它在系统运行前就决定了的。使用装饰模式可以比使用继承关系需要的类数量更少，但是会产生比使用继承关系更多的对象。 ####四.jdk 中的字节流(InputStream, OutputStream, )。装饰模式和适配器模式都是包装(Wrapper)模式,他们之间的区别是，适配器模式是把一个API转换成另一个API，而装饰模式是保持被包装的对象的API不变。比如我们读取一个文件输出，BufferedReader是一个装饰类，因为它实现了Reader，并且包装了一个Reader。但是它不是一个100%的装饰类，因为它提供了一个readLine()的新方法。实现的新方法越多，它离纯装饰类就越来越远。 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;test.txt&quot;))); bufferedReader.lines().forEach(s -&gt; { System.out.println(s); });","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"decrator","slug":"decrator","permalink":"https://lbvs86823.github.io/tags/decrator/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"适配器模式","slug":"patterns/adapter","date":"2015-03-02T01:43:14.000Z","updated":"2021-08-12T02:35:44.757Z","comments":true,"path":"2015/03/02/patterns/adapter/","link":"","permalink":"https://lbvs86823.github.io/2015/03/02/patterns/adapter/","excerpt":"","text":"一.简介适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 二.结构适配器模式包含以下角色： 目标(Target)类：这就是所期待得到的接口。 适配者(Adaptee)类：现在需要适配的接口。 适配器(Adapter)类：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 三.实现interface SDCard { String readSD(); void writeSD(String content); } public class SDCardImpl implements SDCard { @Override public String readSD() { return &quot;读取SD卡数据&quot;; } @Override public void writeSD(String content) { System.out.println(&quot;SD卡写入数据&quot;); } } interface TFCard { String readTF(); void writeTF(String content); } public class TFCardImpl implements TFCard { @Override public String readTF() { return &quot;读取TF卡数据&quot;; } @Override public void writeTF(String content) { System.out.println(&quot;TF卡写入数据&quot;); } } // 1. 继承实现(类适配器模式) public class TFCardAdapter01 extends TFCardImpl implements SDCard { @Override public String readSD() { return &quot;通过适配器TFCardAdapter01读取 &quot; + readTF(); } @Override public void writeSD(String content) { writeTF(&quot;通过适配器TFCardAdapter01写入 &quot; + content); } } // 2. 基于Java单继承的机制，组合实现的方式更为常见、灵活。(对象适配器模式) public class TFCardAdapter02 implements SDCard { private TFCard tfCard; public TFCardAdapter02(TFCard tfCard) { this.tfCard = tfCard; } @Override public String readSD() { return &quot;通过适配器TFCardAdapter02读取 &quot; + tfCard.readTF(); } @Override public void writeSD(String content) { tfCard.writeTF(&quot;通过适配器TFCardAdapter02写入 &quot; + content); } } public class Computer { private SDCard sdCard; public Computer(SDCard sdCard) { this.sdCard = sdCard; } public String readSD() { return sdCard.readSD(); } } public static void main(String[] args) { Computer computer = new Computer(new SDCardImpl()); String content = computer.readSD(); System.out.println(content); computer = new Computer(new TFCardAdapter01()); content = computer.readSD(); System.out.println(content); computer = new Computer(new TFCardAdapter02(new TFCardImpl())); content = computer.readSD(); System.out.println(content); } 3.2 缺省适配器模式实现在不准备实现接口中的所有方法时，就可以写一个抽象类，给出所有方法的空实现，这样，子类再继承这个抽象类时就不必实现接口的所有方法了，只需实现自己感兴趣的接口即可。比如java awt 中的 WindowAdapter 等等。 public abstract class SDCardAdapter implements SDCard { @Override public String readSD() { // 子类对自己感兴趣的方法进行重写 return null } @Override public void writeSD(String content) { // 子类对自己感兴趣的方法进行重写 } } 3.3 JDK适配器模式实现jdk 中的字节流(InputStream) 到 字符流(Reader) 就是使用的InputStreamReader适配器，它是一个字符流类型的API，它把一个InputStream类型的对象包装起来，从而把byte流的API转换成了字符流的API。InputStream 是被适配的类， Reader是适配的目标类，InputStreamReader就是适配器","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"adapter","slug":"adapter","permalink":"https://lbvs86823.github.io/tags/adapter/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"代理模式","slug":"patterns/proxy","date":"2015-03-01T00:13:34.000Z","updated":"2021-08-06T09:58:23.327Z","comments":true,"path":"2015/03/01/patterns/proxy/","link":"","permalink":"https://lbvs86823.github.io/2015/03/01/patterns/proxy/","excerpt":"","text":"一.简介代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 二.结构代理模式包含以下角色： 抽象对象：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。 代理对象：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实对象：代理角色所代表的真实对象，是我们最终要引用的对象。 三.实现3.1 静态代理实现//抽象对象角色 public abstract class AbstractObject { //操作 public abstract void operation(); } //真实对象角色 public class RealObject extends AbstractObject { @Override public void operation() { //一些操作 System.out.println(&quot;一些操作&quot;); } } //代理对象角色 public class ProxyObject extends AbstractObject{ RealObject realObject = new RealObject(); @Override public void operation() { //调用目标对象之前可以做相关操作 System.out.println(&quot;before&quot;); realObject.operation(); //调用目标对象之后可以做相关操作 System.out.println(&quot;after&quot;); } } //客户端 public class Client { public static void main(String[] args) { AbstractObject obj = new ProxyObject(); obj.operation(); } } 3.2 JDK动态代理实现java 中提供了一个动态代理类 Proxy， Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法(newProxyInstance()方法)来获取代理对象。使用JDK Proxy 代理的前提条件是要对象存在可供代理实现的接口。 否则会报错。这里的代理类是JDK动态生成的， 如果你需要查看它生成的源码，可以利用 Alibaba开源的Java诊断工具 Arthas(阿尔萨斯) 根据类class名称来获取源码进行查看。 //对象的接口 public interface TargetInterface { //操作 void operation(); } //真实对象 public class TargetClass implements TargetInterface { @Override public void operation() { //一些操作 System.out.println(&quot;一些操作&quot;); } } // 通过 TargetInterface.class 获取类加载器，和通过 new Class[]{TargetInterface.class} 自己初始化接口数组 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(TargetInterface.class.getClassLoader(), new Class[]{TargetInterface.class}, new InvocationHandler() { //invoke 代表的是执行代理对象的方法(method：代表目标对象的方法字节码对象, args:代表目标对象的响应的方法的参数) @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;------------before------------&quot;); Object result = method.invoke(new TargetClass(), args); System.out.println(&quot;------------after------------&quot;); return result; } }); proxy.operation(); // 通过 TargetClass.class 直接获取类加载器 .getClassLoader() 接口数组 .getInterfaces() proxy = (TargetInterface) Proxy.newProxyInstance(TargetClass.class.getClassLoader(), TargetClass.class.getInterfaces(), new InvocationHandler() { //invoke 代表的是执行代理对象的方法(method：代表目标对象的方法字节码对象, args:代表目标对象的响应的方法的参数) @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName()+ &quot;------------before------------&quot;); Object result = method.invoke(new TargetClass(), args); System.out.println(method.getName()+ &quot;------------after------------&quot;); return result; } }); proxy.operation(); 3.3 CGLIB 实现需要引入第三方jar包才能使用 &lt;!-- cglib包 --&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; CGLIB是一个功能强大的，高性能的代码生成包，它可以为没有实现接口的对象提供代理，是JDK动态代理的很好补充。但是 CGLiB 不能对声明为final的类或者方法进行代理，因为CGLIB的实现原理是动态生成被代理类的子类来完成代理的。 public class Target { public void operation() { //一些操作 System.out.println(&quot;一些操作&quot;); } } public class ProxyFactory { private Target target; public ProxyFactory(Target target) { this.target = target; } public Target getProxyTarget() { // 创建Enhancer对象,类似于JDK代理中的Proxy类 Enhancer enhancer = new Enhancer(); // 设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(method.getName() + &quot;------------before------------&quot;); // 执行目标对象的方法 Object result = method.invoke(target, objects); System.out.println(method.getName() + &quot;------------after------------&quot;); return null; } }); // 创建代理对象 Target targetProxy = (Target) enhancer.create(); return targetProxy; } } public static void main(String[] args) { Target target = new Target(); ProxyFactory factory = new ProxyFactory(target); Target proxyTarget = factory.getProxyTarget(); proxyTarget.operation(); }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://lbvs86823.github.io/tags/proxy/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"抽象工厂模式","slug":"patterns/abstractFactory","date":"2015-02-28T12:04:59.000Z","updated":"2021-08-06T07:11:03.263Z","comments":true,"path":"2015/02/28/patterns/abstractFactory/","link":"","permalink":"https://lbvs86823.github.io/2015/02/28/patterns/abstractFactory/","excerpt":"","text":"一.简介是一种为访问类提供一个创建一组相关或者相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法的升级版本，工厂方法只生产一个等级的产品，而抽象工厂模式可以生产多个等级的产品。抽象工厂中方法对应不同的产品类，具体工厂对应产品族。 二.结构抽象工厂模式包含以下角色： 抽象工厂角色（Abstract Factory），抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口。 具体工厂角色（Concrete Factory）具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 抽象产品角色（product）抽象创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品角色(Concrete product) 创建的具体实例对象 三.实现//抽象产品 开宝马 public abstract class BMWCar { public abstract void driving(); } //抽象产品 座奔驰 public abstract class BenzCar { public abstract void sit(); } //具体产品 宝马 5系 和 7系 public class BMW5 extends BMWCar { public BMW5() { System.out.println(&quot;创建一个 5系 的宝马 !&quot;); } @Override public void driving() { System.out.println(&quot;开宝马 5 系！&quot;); } } public class BMW7 extends BMWCar { public BMW7() { System.out.println(&quot;创建一个 7系 的宝马 !&quot;); } @Override public void driving() { System.out.println(&quot;开宝马 7 系！&quot;); } } //具体产品 奔驰E300 和 S400 public class BenzE300 extends BenzCar { public BenzE300() { System.out.println(&quot;创建一个 E300 奔驰 !&quot;); } @Override public void sit() { System.out.println(&quot;座着 E300 奔驰！&quot;); } } public class BenzS400 extends BenzCar { public BenzS400() { System.out.println(&quot;创建一个 S400 奔驰 !&quot;); } @Override public void sit() { System.out.println(&quot;座着 S400 奔驰！&quot;); } } // 抽象工厂类 public abstract class AbstractCarFactory{ public abstract BMWCar createBMW(); public abstract BenzCar createBenz(); } //具体工厂类 中档的汽车工厂, 豪华的汽车工厂 public class LowCarLowFactory extends AbstractCarFactory { public BMWCar createBMW() { return new BMW5(); } public BenzCar createBenz() { return new BenzE300(); } } public class HighCarFactory extends AbstractCarFactory { public BMWCar createBMW() { return new BMW7(); } public BenzCar createBenz() { return new BenzS400(); } } 抽象工厂方法从纵向上看，几乎没有可扩展性，假如我们想增加一个产品(“奥迪汽车”)，也就是说产品家族由原来的2个变为3个，程序将会有很大的变动，抽象工厂中就需要增加一个方法。这严重违背了开闭原则。并且抽象类是不喜欢被修改的。但是从横向上来看，却对扩展性有了很好的支持，如果我们增加一个产品等级(“搞一个入门级别的[宝马1系和奔驰C200]”)，我们只需要在写一个BasicCarFactory就可以了，这里又符合了开闭原则，有多少个产品等级就应该有多少个实现工厂类。每增加一个产品等级就相应的增加一个实现工厂类，这里的扩展性又很自然的体现出来了。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"factory","slug":"factory","permalink":"https://lbvs86823.github.io/tags/factory/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"建造者模式","slug":"patterns/builder","date":"2015-02-28T03:13:12.000Z","updated":"2021-08-06T07:12:18.888Z","comments":true,"path":"2015/02/28/patterns/builder/","link":"","permalink":"https://lbvs86823.github.io/2015/02/28/patterns/builder/","excerpt":"","text":"一.简介建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 与抽象工厂的区别：在建造者模式里，有个指挥者，由指挥者来管理建造者，用户是与指挥者联系的，指挥者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。 在什么情况下使用建造模式: 需要生成的产品对象有复杂的内部结构，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。 需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想. 在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。 二.结构建造者模式包含以下角色： 产品（Product）：产品便是建造中的复杂对象。 抽象建造者（Builder）：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。 具体建造者（ConcreteBuilder）：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。 指挥者（Director）：担任这个角色的类调用具体建造者角色以创建产品对象。它主要有2个作用：1.隔离了客户与对象的生产过程；2.负责控制产品对象的生产过程。 模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法，另一种是返还结构方法。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。 三.实现// 需要的产品 一个房子 public class Phone { private String cpu; private String memory; private String camera; private String screen; // getter setter 方法 } //抽象建造者（定义手机必须的东西） public abstract class PhoneBuilder { protected Phone phone = new Phone(); public abstract void builderCpu(); public abstract void builderMemory(); public abstract void builderCamera(); public abstract void builderScreen(); public abstract Phone builder(); } //具体建造者 三星手机建造者 public class SamsungBuilder extends PhoneBuilder { public void builderCpu() { phone.setCpu(&quot;三星cpu&quot;); } public void builderMemory() { phone.setMemory(&quot;2G&quot;); } public void builderCamera() { phone.setCamera(&quot;三星摄像头&quot;); } public void builderScreen() { phone.setScreen(&quot;三星屏幕&quot;); } public Phone builder() { return phone; } } //具体建造者 索尼手机建造者 public class SonyBuilder extends PhoneBuilder { public void builderCpu() { phone.setCpu(&quot;高通cpu&quot;); } public void builderMemory() { phone.setMemory(&quot;4G&quot;); } public void builderCamera() { phone.setCamera(&quot;索尼摄像头&quot;); } public void builderScreen() { phone.setScreen(&quot;索尼屏幕&quot;); } public Phone builder() { return phone; } } //指挥者(设计工程师) public class Director { private PhoneBuilder builder; public Director(PhoneBuilder builder){ this.builder = builder; } //指挥工人进行装配 public Phone construct() { builder.builderCpu(); builder.builderMemory(); builder.builderCamera(); builder.builderScreen(); return builder.builder(); } } // 测试 public class Client { public static void main(String[] args) { Director director = new Director(new SonyBuilder()); Phone sonyPhone = director.construct(); director = new Director(new SamsungBuilder()); Phone samsungPhone = director.construct(); } } 可以把指挥者类和抽象建造者进行结合, 这样确实简化了系统结构，但是同时也加重了抽象建造者的职责，不太符合单一职责原则， 如果builder()太过于复杂，建议还是封装到 Director 类中实现比较好。 //抽象建造者与指挥者结合 public abstract class PhoneBuilder { protected Phone phone = new Phone(); public abstract void builderCpu(); public abstract void builderMemory(); public abstract void builderCamera(); public abstract void builderScreen(); public abstract Phone builder() { this.builderCpu(); this.builderMemory(); this.builderCamera(); this.builderScreen(); return this.phone; } } 当某个类的属性非常多比如20个，利用有参构造函数往往很不方便（参数不一定都需要的时候），这个时候利用建造模式，往往是一种常见的用法。 public class Phone { private String cpu; private String memory; private String camera; private String screen; // 此处下面还有N多属性 ... // 私有化构造方法 private Phone() { } public static final class Builder { private Phone p = new Phone(); public Builder baicPhone(String cpu, String memory) { p.cpu = cpu; p.memory = memory; return this; } public Builder camera(String camera) { p.camera = camera; return this; } public Builder screen(String screen) { p.screen = screen; return this; } // 构建手机的方法 public Phone builder() { return p; } } // 很容易的随意构建对象 public static void main(String[] args) { Phone phone = new Phone.Builder().baicPhone(&quot;5.0HZ&quot;, &quot;8G&quot;) //.camera(&quot;索尼的镜头&quot;) .screen(&quot;三星的屏幕&quot;) .builder(); } } 四.JKD中的实现StringBuilder 五.模式对比工厂方法模式 VS 建造者模式： 工厂方法模式注重的是整体对象的创建方式。 建造者模式注重的是部件构建的过程，意在通过一步步的精确构建创建出一个复杂的对象。 抽象工厂模式 VS 建造者模式： 抽象工厂模式是实现对对产品家族的创建，一个产品家族是这样一系列的的产品， 具有不同维度的产品组合，采用抽象工厂模式不需要关系构建过程，只关心什么产品由什么工厂生产。 建造者模式则是要求按照指定的蓝图构建产品，它的主要目的是通过组装零配件而产生一个新的产品。如果将抽象工厂模式看成汽车配件生产的工厂，生产一个产品族的产品， 那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"builder","slug":"builder","permalink":"https://lbvs86823.github.io/tags/builder/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"工厂方法模式","slug":"patterns/factoryMethod","date":"2015-02-27T13:43:11.000Z","updated":"2021-08-05T06:29:35.269Z","comments":true,"path":"2015/02/27/patterns/factoryMethod/","link":"","permalink":"https://lbvs86823.github.io/2015/02/27/patterns/factoryMethod/","excerpt":"","text":"一.简介定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象，工厂方法使得一个产品类的实例化延迟到工厂的子类。工厂方法模式与简单工厂模式再结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了”开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。 二.结构工厂方法模式包含以下角色： 抽象工厂（Creator）：是工厂方法模式的核心，与应用程序无关。任何在模式中创建对象的工厂类必须实现这个接口。 具体工厂（Concrete Creator）：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 抽象产品（Product）：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 三.实现//产品接口 public interface Fruit { void eat(); } //具体产品 Apple public class Apple implements Fruit { public Apple() { System.out.println(&quot;create Apple !&quot;); } @Override public void eat() { System.out.println(&quot;苹果吃起来非常香甜&quot;); } } //具体产品 watermelon public class Watermelon implements Fruit { public Watermelon() { System.out.println(&quot;create Watermelon !&quot;); } @Override public void eat() { System.out.println(&quot;西瓜吃起来非常甜，解渴&quot;); } } // 抽象工厂方法 public interface FruitFactory { public Fruit createFruit() ; } //具体工厂方法 苹果工厂 public class AppleFactory implements FruitFactory { public Fruit createFruit() { return new Apple(); } } //具体工厂方法 西瓜工厂 public class WatermelonFactory implements FruitFactory { public Fruit createFruit() { return new Watermelon(); } } 四.JKD中的实现集合获取迭代器的方法就使用了工厂方法模式 Collection 抽象工厂类 ArrayList 是具体的工厂类Iterator 抽象产品类 ArrayList 是具体的工厂类中创建了私有内部类 Itr 的具体产品，在ArrayList 是具体的工厂类的iterator() 方法中创建了 具体的商品类 Itr 的对象。","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"factory","slug":"factory","permalink":"https://lbvs86823.github.io/tags/factory/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"原型模式","slug":"patterns/prototype","date":"2015-02-27T13:43:11.000Z","updated":"2021-08-05T07:43:26.917Z","comments":true,"path":"2015/02/27/patterns/prototype/","link":"","permalink":"https://lbvs86823.github.io/2015/02/27/patterns/prototype/","excerpt":"","text":"一.简介通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是原型模式的用意。原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。 1.1 原型模式的优点: 原型模式允许在运行时动态改变具体的实现类型。 原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型， 看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。 1.2 原型模式的缺点: 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。 二.结构原型模式包含以下角色： 客户(Client)：客户类提出创建对象的请求。 抽象原型(Prototype)：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。 具体原型（Concrete Prototype）：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。 三.实现//抽象原型角色 public interface Prototype{ /** * 克隆自身的方法 * @return 一个从自身克隆出来的对象 */ public Object clone(); } //具体原型角色 public class ConcretePrototype1 implements Prototype { public Prototype clone(){ //最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了 Prototype prototype = new ConcretePrototype1(); return prototype; } } public class ConcretePrototype2 implements Prototype { public Prototype clone(){ //最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了 Prototype prototype = new ConcretePrototype2(); return prototype; } } //客户端角色 public class Client { /** * 持有需要使用的原型接口对象 */ private Prototype prototype; /** * 构造方法，传入需要使用的原型接口对象 */ public Client(Prototype prototype){ this.prototype = prototype; } public void operation(){ //需要创建原型接口的对象 Prototype copyPrototype = prototype.clone(); } } 四.JKD中的实现Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份。 Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。 4.1 克隆满足的条件：clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足以下的描述： 对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。 对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。 如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。 在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。 4.2 浅克隆和深克隆无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。 浅度克隆: 只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。 深度克隆:除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。 换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。 因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。 4.3 利用序列化实现深度克隆把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。 在Java语言里深度克隆一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的拷贝）写到一个流里（序列化），再从流里读回来（反序列化），便可以重建对象。 public Object deepClone() throws IOException, ClassNotFoundException{ //将对象写到流里 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); //从流里读回来 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); } 这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。 浅度克隆显然比深度克隆更容易实现，因为Java语言的所有类都会继承一个clone()方法，而这个clone()方法所做的正是浅度克隆。有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用。 五.Spring中创建bean的实现在spring中创建bean 可以配置2中方式(prototype: 原型模式， singleton：单例模式)","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"factory","slug":"factory","permalink":"https://lbvs86823.github.io/tags/factory/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"单例模式","slug":"patterns/singleton","date":"2015-02-27T13:43:11.000Z","updated":"2021-08-05T07:46:31.567Z","comments":true,"path":"2015/02/27/patterns/singleton/","link":"","permalink":"https://lbvs86823.github.io/2015/02/27/patterns/singleton/","excerpt":"","text":"1.简介单例模式有一下特点： 单例类只能有一个实例。 单例类必须自己自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例；Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。) 2.实现2.1 饿汉式-静态常量//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton { //私有的默认构造子 private Singleton() {} //已经自行实例化 private static final Singleton instance = new Singleton(); //静态工厂方法 public static Singleton getInstance() { return instance; } } 2.2 饿汉式-静态代码块//饿汉式单例类.在类初始化时，已经自行实例化，只是将类的实例化过程放到静态代码块中 public class singleton { //私有的默认构造子 private singleton() {} //静态属性 这里没有final private static singleton instance; static { instance = new Singleton(); } //静态工厂方法 public static Singleton getInstance() { return instance; } } 2.3 懒汉式-线程不安全//懒汉式单例类.在第一次调用的时候实例化 public class Singleton { //私有的默认构造子 private Singleton() {} //注意，这里没有final private static Singleton instance; //静态工厂方法(多线程下，可能返回多个实例对象) public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2.4 懒汉式-线程安全//懒汉式单例类.在第一次调用的时候实例化 public class Singleton { //私有的默认构造子 private Singleton() {} //注意，这里没有final private static Singleton instance; //静态工厂方法(加同步锁，保证多线程下，线程安全，但是同步方法效率低下) public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2.5 懒汉式-线程安全(同步代码块)//懒汉式单例类.在第一次调用的时候实例化 public class Singleton { //私有的默认构造子 private Singleton() {} //注意，这里没有final private static Singleton instance; //静态工厂方法(加同步锁，保证多线程下，线程安全，但是同步方法效率低下) public static Singleton getInstance() { synchronized(Singleton.class){ if (instance == null) { instance = new Singleton(); } } return instance; } } 2.6 懒汉式-线程安全(同步代码块双重检查)(推荐)//懒汉式单例类.在第一次调用的时候实例化 public class Singleton { //私有的默认构造子 private Singleton() {} //注意 volatile 多线程变量改变可见性 private static volatile Singleton instance; //静态工厂方法(同步代码块双重检查, 解决线程安全问题，同时解决懒加载问题) public static Singleton getInstance() { if (instance == null) { synchronized(Singleton.class) { if(instance == null){ instance = new Singleton(); } } } return instance; } } 2.7 懒汉式-静态内部类(推荐)//懒汉式单例类.外部类被装载时，内部类不会被装载，调用时才装载 public class Singleton { //私有的默认构造子 private Singleton() {} // 静态内部类 利用jvm一个类只加载一次的机制来保证线程安全 private static class Inner { private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return Inner.instance; } } 2.8 懒汉式-枚举方式(推荐)借助jdk1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 //懒汉式单例类. 枚举 public enum Singleton { instance; public void method1() { // 方法 ... } } 2.9 登记式单例登记式单例类:是为了克服饿汉式单例类及懒汉式单例类均不可继承的缺点而设计的。当单例类需要被继承时适用.类似Spring里面的方法，将类名注册，下次从里面直接获取。 import java.util.HashMap; import java.util.Map; public class Singleton { private static Map&lt;String, Singleton&gt; map = new HashMap&lt;String, Singleton&gt;(); static{ Singleton single = new Singleton(); map.put(single.getClass().getName(), single); } //保护的默认构造子(注意此处是保护行的，不是私有的) protected Singleton(){} //静态工厂方法,返还此类惟一的实例 public static Singleton getInstance(String name) { if(name == null) { name = Singleton.class.getName(); System.out.println(&quot;name == null&quot; + &quot;---&gt;name=&quot; + name); } if(map.get(name) == null) { try { map.put(name, (Singleton) Class.forName(name).newInstance()); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } return map.get(name); } //一个示意性的商业方法 public String about() { return &quot;Hello, I am RegSingleton.&quot;; } public static void main(String[] args) { Singleton single3 = Singleton.getInstance(null); System.out.println(single3.about()); } } 登记式单例类的子类 import java.util.HashMap; public class SingletonChild extends Singleton { //开放构造函数为公有的 public SingletonChild() {} //静态工厂方法 public static SingletonChild getInstance(){ return (SingletonChild) Singleton.getInstance(&quot;SingletonChild&quot;); } //一个示意性的商业方法 public String about() { return &quot;Hello, I am RegSingleton Child.&quot;; } } 在GoF 原始的例子中，并没有getInstance()方法，这样得到子类必须调用的getInstance(String name)方法并传入子类的名字，因此很不方便。在登记式单例类子类的例子里，加入了getInstance() 方法，这样做的好处是SingletonChild 可以通过这个方法，返还自已的实例。而这样做的缺点是，由于数据类型不同，无法在Singleton 提供这样一个方法。由于子类必须允许父类以构造方法调用产生实例，因此，它的构造方法必须是公开的。这样一来，就等于允许了以这样方式产生实例而不在父类的登记中。这是登记式单例类的一个缺点。 3. jdk中的单例模式比如 Runtime 类 package java.lang; import java.io.*; import java.util.StringTokenizer; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; public class Runtime { private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() { return currentRuntime; } private Runtime() {} // 省略方法代码 ... } 4. 破坏单例模式(单例类实现了序列化接口)可以通过序列化和返序列化破坏单例模式，也可以通过反射破坏单例模式。枚举除外(由于枚举没有构造方法) public class Singleton implements Serializable { private Singleton() {} private static class Inner { private static final Singleton2 instance = new Singleton(); } public static Singleton getInstance() { return Inner.instance; } public static void main(String[] args) throws Exception { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); // 单例是同一个对象 System.out.println(s1 == s2); // true // 序列化单例对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;singleton.txt&quot;)); out.writeObject(s1); out.close(); // 反序列化单例对象 ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;singleton.txt&quot;)); Singleton s3 = (Singleton) in.readObject(); in.close(); // 反序列化单例对象 ObjectInputStream in2 = new ObjectInputStream(new FileInputStream(&quot;singleton.txt&quot;)); Singleton s4 = (Singleton) in2.readObject(); in2.close(); // 这里已经不是同一个对象了 System.out.println(s3 == s4); // false // 反射方式破坏单例 Class clazz = Class.forName(Singleton.class.getName()); Singleton s5 = (Singleton) clazz.newInstance(); Singleton s6 = (Singleton) clazz.newInstance(); // 这里已经不是同一个对象了 System.out.println(s5 == s6); // false } } 5. 解决方案(单例模式容易被破坏)解决反序列化破坏单例模式的问题: public class Singleton implements Serializable { private Singleton() {} private static class SingletonHolder { private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } // 定义该方法可以解决反序列化破坏单例模式的问题 // 在 ObjectInputStream.readObject() 实现中 当进行反序列化时，如果存在，会自动调用该方法，将该方法的返回值直接返回，否则会生成一个新的对象 public Object readResolve(){ return SingletonHolder.instance; } public static void main(String[] args) throws Exception { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2); // true ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;singleton.txt&quot;)); out.writeObject(s1); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;singleton.txt&quot;)); Singleton s3 = (Singleton) in.readObject(); in.close(); ObjectInputStream in2 = new ObjectInputStream(new FileInputStream(&quot;singleton.txt&quot;)); Singleton s4 = (Singleton) in2.readObject(); in2.close(); //此处还是同一个对象 System.out.println(s3 == s4); // true } } 解决反射破坏单例模式的问题: public class Singleton { private static volatile boolean isInit = false; private Singleton() { // 保证构造方法只能运行一次 synchronized (Singleton.class) { if (isInit) { throw new RuntimeException(&quot;单例模式多次实例化异常&quot;); } isInit = true; } } private static class SingletonHolder { private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } public static void main(String[] args) throws Exception { Class clazz = Class.forName(Singleton.class.getName()); Singleton s5 = (Singleton) clazz.newInstance(); // 下面语句将抛出异常 Singleton s6 = (Singleton) clazz.newInstance(); } }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"singleton","slug":"singleton","permalink":"https://lbvs86823.github.io/tags/singleton/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"UML类图","slug":"patterns/uml","date":"2015-02-27T12:53:21.000Z","updated":"2021-08-05T09:31:19.437Z","comments":true,"path":"2015/02/27/patterns/uml/","link":"","permalink":"https://lbvs86823.github.io/2015/02/27/patterns/uml/","excerpt":"","text":"一.类的表示法1.1 类的表示使用 PlantUML 语法表述如下： @startuml title &quot;类图&quot; abstract abstractA abstract class &quot;abstractB&quot; annotation annotation interface interface class classA enum enum entity entity circle circleA () &quot;circleB&quot; diamond &quot;diamondA(菱形)&quot; &lt;&gt; diamondB @enduml 对应的UML图如下： 1.2 类属性和方法的可见性属性的完整表示方式： 可见性 名称 ： 类型 [ = 缺省值] 方法的完整表示方式： 可见性 名称(参数列表) [ ：返回类型] [] 中的内容是可选的。 也有将类型放在变量名前面，返回值类型放在方法名前面的。 使用 PlantUML 语法表述如下： @startuml title &quot;类图&quot; skinparam classAttributeIconSize 0 class Class { - fieldA : String # fieldB : int ~ fieldC : Double + fieldD : Long {static} String fieldE -- 静态属性 - methodA() : void # methodB() : void ~ methodC() : void + methodD() : void {static} methodD() : void --静态方法 {abstract} methodE() : void --抽象方法(斜体字) } @enduml 对应的UML图如下： 二.类与类之间的关系2.1 关联关系（Association) 表示类与类之间的连接，对象之间的一种引用关系，使得一个类知道另外一个类的属性和方法。 关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头 自身关联，特殊的关联关系 关联关系体现的是两个类，或者类与接口之间的强依赖关系，这种关系很强烈，比依赖更强，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系。 带普通箭头的实心线，指向被拥有者 使用 PlantUML 语法表述如下： @startuml title 关联关系 class Country { - president : President } class President{ } Country &quot;1&quot; -right-&gt; &quot;1&quot; President class Customer { - addressList : List&lt;Address&gt; } class Address Customer &quot;1&quot; -right-&gt; &quot;n&quot; Address class Teacher { - students : List&lt;Student&gt; } class Student { - teachers : List&lt;Teacher&gt; } Teacher &quot;n&quot; -down- &quot;n&quot; Student : 关联 class Node { - childrenNode : Node } Node --&gt; Node @enduml 对应的UML图如下： 2.2 聚合关系（Aggregation） 是整体与部分的关系, 且部分可以离开整体而单独存在,即has-a的关系。 如车和轮胎是整体和部分的关系, 轮胎离开车仍然可以存在. 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 带空心菱形的实心线，菱形指向整体 使用 PlantUML 语法表述如下： @startuml title 聚合关系 class Car { - wheels : List&lt;Wheel&gt; } class Wheel Car &quot;1&quot; o-right- &quot;n&quot; Wheel : 聚合 @enduml 对应的UML图如下： 2.3 组合关系(Composition) 是整体与部分的关系, 但部分不能离开整体而单独存在.体现的是一种contains-a的关系。如公司和部门是整体和部分的关系, 没有公司就不存在部门. 组合关系是关联关系的一种，是强的关联关系； 带实心菱形的实线，菱形指向整体 使用 PlantUML 语法表述如下： @startuml title 组合关系 class Person { - hands ： List&lt;Hand&gt; } class Hand Person &quot;1&quot; *-right- &quot;n&quot; Hand : 组合 @enduml 对应的UML图如下： 2.4 依赖关系(Dependency) 是一种使用的关系, 即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖. 这种使用关系是具有偶然性的、临时性的、非常弱的关系， 比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖 几种关系所表现的强弱程度依次为：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 带箭头的虚线，指向被使用者 使用 PlantUML 语法表述如下： @startuml title 依赖关系 class Driver { - name : String + driving(Car car): void } class Car { + move(): void } Driver ..&gt; Car : 依赖 @enduml 对应的UML图如下： 2.5 泛化关系(继承关系 generalization） 指一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，并可以增加它自己新功能的能力，继承是类与类或者接口与接口最常见的关系 带三角箭头的实线，箭头指向父类 使用 PlantUML 语法表述如下： @startuml title 继承关系 class Fruit class Apple extends Fruit class Banana extends Fruit class Orange Fruit &lt;|-- Orange @enduml 对应的UML图如下： 2.6 实现关系(realization） 指一个class实现interface接口（一个或者多个），表示类具备了某种能力，实现是类与接口中最常见的关系 带三角箭头的虚线，箭头指向接口 使用 PlantUML 语法表述如下： @startuml title 实现关系 interface Mouth { + eat() : void } class Human implements Mouth { + eat() : void } class Duck implements Mouth { + eat() : void } class Cat { + eat() : void } Mouth &lt;|..Cat @enduml 对应的UML图如下： 更多语法可以参考UML画图文档 PlantUML","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"uml","slug":"uml","permalink":"https://lbvs86823.github.io/tags/uml/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"简单工厂模式","slug":"patterns/simpleFactory","date":"2015-02-27T10:22:54.000Z","updated":"2021-08-06T07:14:37.015Z","comments":true,"path":"2015/02/27/patterns/simpleFactory/","link":"","permalink":"https://lbvs86823.github.io/2015/02/27/patterns/simpleFactory/","excerpt":"","text":"一.简介简单工厂不是一种设计模式，反而比较像一种编程习惯。 二.结构简单工厂包含以下角色： 抽象产品：定义产品的规范，描述产品的主要特性和功能 具体产品：实现或者继承抽象产品的子类 具体工厂：提供创建产品的方法，调用者通过该方法来获取产品 三.实现//产品接口 public interface Fruit { void eat(); } //具体产品 Apple watermelon public class Apple implements Fruit { public Apple() { System.out.println(&quot;create Apple !&quot;); } @Override public void eat() { System.out.println(&quot;苹果吃起来非常香甜&quot;); } } public class Watermelon implements Fruit { public Watermelon() { System.out.println(&quot;create Watermelon !&quot;); } @Override public void eat() { System.out.println(&quot;西瓜吃起来非常甜，解渴&quot;); } } // 简单工厂类 public class FruitFactory { public Fruit createFruit(String type) { if ( &quot;Apple&quot;.equals(type) ) { return new Apple(); } if ( &quot;Watermelon&quot;.equals(type) ) { return new Watermelon(); } else return null; } } 简单工厂模式把对象的创建和业务逻辑层分开，封装了创建对象的过程，避免了修改客户端的代码。简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好，违背了开闭原则。 四.静态工厂在开发中有人将工厂类的工厂方法定义为静态的，即静态工厂模式，也不是23中设计模式中的，算是一种实践。 // 简单工厂类 public class FruitFactory { public static Fruit createFruit(String type) { if ( &quot;Apple&quot;.equals(type) ) { return new Apple(); } if ( &quot;Watermelon&quot;.equals(type) ) { return new Watermelon(); } else return null; } } 五.模式扩展(简单工厂+配置文件解耦)在工厂类中加载配置文件的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。 // bean.properties key=类的全路径名称 Apple=Apple Watermelon=Watermelon // 简单工厂类 public class FruitFactory { // 定义容器对象用于存储对象 private static HashMap&lt;String, Fruit&gt; map = new HashMap&lt;&gt;(); // 加载配置文件 static { Properties prop = new Properties(); InputStream in = FruitFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); try { prop.load(in); Set&lt;Object&gt; keys = prop.keySet(); for(Object key : keys){ String className = prop.getProperty((String) key); Class zz = Class.forName(className); Fruit f = (Fruit)zz.newInstance(); map.put((String) key, f); } } catch(IOException e){ e.printStackTrace(); } } public Fruit createFruit(String type) { return map.get(type); } }","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"factory","slug":"factory","permalink":"https://lbvs86823.github.io/tags/factory/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"设计模式","slug":"patterns/pattern","date":"2015-02-26T01:29:59.000Z","updated":"2021-08-20T09:15:45.083Z","comments":true,"path":"2015/02/26/patterns/pattern/","link":"","permalink":"https://lbvs86823.github.io/2015/02/26/patterns/pattern/","excerpt":"","text":"一.设计原则 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则 迪米特法则 组合聚合复用原则 二.设计分类 创建型 单例模式(Singleton) 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 建造模式（Builder） 原型模式（Prototype） 结构型 代理模式（Proxy） 适配器模式（Adapter） 装饰模式（Decrator） 门面模式（Facade） 组合模式（Composite） 桥模式（Bridge） 享元式（Flyweight） 行为型 观察者模式（Observer） 迭代器模式（Iterator） 模板方法模式（Template Method） 责任链模式（Chain of Responsibility） 策略模式（Strategy） 访问者模式（Visitor） 备忘录模式（Memento） 解释器模式（Interpreter） 命令模式（Command） 状态模式（State） 中介者模式（Mediator）","categories":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}],"tags":[{"name":"pattern","slug":"pattern","permalink":"https://lbvs86823.github.io/tags/pattern/"}],"keywords":[{"name":"patterns","slug":"patterns","permalink":"https://lbvs86823.github.io/categories/patterns/"}]},{"title":"EAI简介","slug":"others/eai","date":"2015-01-27T12:53:21.000Z","updated":"2020-03-20T06:27:43.660Z","comments":true,"path":"2015/01/27/others/eai/","link":"","permalink":"https://lbvs86823.github.io/2015/01/27/others/eai/","excerpt":"","text":"1.EAI架构简介企业的业务流程会同时涉及到多个应用系统，因此要求这些系统能够协同，但接口、架构的不统一往往使得这些本应紧密集成的应用系统成为了一个个“信息孤岛”。于是，企业应用集成（Enterprise Application Integration，EAI）技术应运而生，它可以通过中间件作为粘合剂来连接企业内外各种业务相关的异构系统、应用以及数据源，从而满足 E-Commerce、ERP、CRM、SCM、OA、数据库、数据仓库等 重要系统之间无缝共享和交换数据的需要。 2.EAI 的基本特征EAI 的核心是使用中间件连接企业应用。有多种不同类型的中间件可以提供 EAI 的功能。在选择 EAI 中间件时需注意以下的基本特征： 通过中间件将不同的应用连接起来，保证应用的独立性，在不需要修改应用自身的业务逻辑的同时，又解决了数据共享问题。 对核心共享业务数据模型的处理与支持。 实现业务流程自动化。确保各个部门在采用不同的系统的同时可以协同完成同一个工作。 支持应用架构的不断变更。可以方便地重新配制以增加或去除系统而不会影响其它系统。 能够提供实时接口和批处理接口，能够提供同步和异步接口。 必须保证数据的安全，只有目的应用可以读取。 良好的性能和数据吞吐量，并且具有灵活的可扩展性以适应企业的发展。 必须具备恢复机制，当数据传输过程中发生连接中断等异常时可以确保数据的恢复。 对流程管理提供预定义的通用模型与行业模型。 3.EAI 的五大层面一个完整的 EAI 解决方案应当包含以下五个层面： 用户交互：实现应用用户界面统一的接入与安全机制，利用门户技术进行构建。 应用连接：通过 HUB 或总线架构，实现应用与应用之间的连接，完成相关的数据路由与数据格式转换。 业务流程整合：实现业务流程管理，包括工作流管理和自动化流程两个方面。 构建整合：这个层面包含两个部分，一部分是构建与现有应用兼容的新应用，另一部分是对现有资源进行重用以适应新环境的需要。 信息集成：实现数据集成，在异构的数据源之间实现数据层的直接整合。 4.EAI 的相关技术EAI 解决方案通常涉及到 JCA、JMS、Web 服务以及 XML 等多种企业级技术。这些技术都已经成为业界的标准，从而可以最大化地保护客户投资。这些技术既可以被包含在相关产品中供用户透明地使用， 也可以由用户自己在应用程序中加以调用。此外，SOA（面向服务的架构）随着各大厂商的追捧而变得炙手可热。虽然 SOA 本身不是一个全新的概念， 但由于 Web 服务以及网格计算等技术的成熟，SOA 具备了更好的发展条件。对于 EAI 来说，基于 SOA 的企业应用系统可以随着企业业务的变化而逐渐变化，能够实现“柔性化”的软件系统，从而降低实施 EAI 的成本和风险，因此我们可以说 SOA 的兴起给了 EAI 厂商一个新的机会。","categories":[{"name":"others","slug":"others","permalink":"https://lbvs86823.github.io/categories/others/"}],"tags":[{"name":"EAI","slug":"EAI","permalink":"https://lbvs86823.github.io/tags/EAI/"},{"name":"ERP","slug":"ERP","permalink":"https://lbvs86823.github.io/tags/ERP/"},{"name":"OA","slug":"OA","permalink":"https://lbvs86823.github.io/tags/OA/"},{"name":"CRM","slug":"CRM","permalink":"https://lbvs86823.github.io/tags/CRM/"}],"keywords":[{"name":"others","slug":"others","permalink":"https://lbvs86823.github.io/categories/others/"}]},{"title":"Digester 规则介绍","slug":"digester/digester_rule","date":"2015-01-16T04:13:34.000Z","updated":"2020-03-20T06:27:43.616Z","comments":true,"path":"2015/01/16/digester/digester_rule/","link":"","permalink":"https://lbvs86823.github.io/2015/01/16/digester/digester_rule/","excerpt":"","text":"Digester 规则介绍(0)参数实体声明：rule-elements参数声明： &lt;!ENTITY % rule-elements &quot;bean-property-setter-rule | call-method-rule | call-param-rule | object-param-rule | node-create-rule | factory-create-rule | object-create-rule | set-properties-rule | set-nested-properties-rule | set-property-rule | set-top-rule | set-next-rule | set-root-rule&quot; &gt; (1) 模式匹配规则：pattern语法格式： &lt;!ELEMENT pattern (pattern | include | %rule-elements; )*&gt; &lt;!ATTLIST pattern value CDATA #REQUIRED&gt; value : 匹配的标签模式 创建对象 (2) 创建对象规则：object-create-rule [ObjectCreateRule]语法格式： &lt;!ELEMENT object-create-rule EMPTY&gt; &lt;!ATTLIST object-create-rule pattern CDATA #IMPLIED classname CDATA #REQUIRED attrname CDATA #IMPLIED paramtypes CDATA #IMPLIED params CDATA #IMPLIED&gt; pattern : 匹配的模式标签 classname : 创建对象的类名(全路径) attrname : 标签属性名称(指定特殊的实例类替代classname) paramtypes : 参数的类型 params : 参数 利用指定类的默认构造函数，创建该类的一个对象，并把对象压入栈。当元素处理结束时，对象被弹出。被实例化的类可通过class对象或类的全称给出。 例子：数据文件如下： &lt;product&gt; &lt;/product&gt; 对应的规则文件如下： &lt;digester-rules&gt; &lt;object-create-rule pattern=&quot;product&quot; classname=&quot;demo.lesson04.Product&quot;/&gt; &lt;/digester-rules&gt; (3) 用工厂创建对象规则：factory-create-rule [FactoryCreateRule]语法格式： &lt;!ELEMENT factory-create-rule EMPTY&gt; &lt;!ATTLIST factory-create-rule pattern CDATA #IMPLIED classname CDATA #REQUIRED attrname CDATA #IMPLIED ignore-exceptions CDATA #IMPLIED&gt; pattern : 匹配的模式标签 classname : 创建对象的类名(全路径) attrname : 标签属性名称(指定特殊的实例类替代classname) ignore-exceptions ：表明是否忽略在创建类的过程中忽略抛出的exception。 利用指定的工厂类创建一个对象，把对象压入栈。对于没有提供默认构造函数的类，这一规则很有用。用于该规则的工厂类必须实现org.apache.commons.digester.ObjectCreationFactory接口。 设置对象属性 (4) set-property-rule [SetPropertyRule]语法格式： &lt;!-- SetPropertyRule --&gt; &lt;!ELEMENT set-property-rule EMPTY&gt; &lt;!ATTLIST set-property-rule pattern CDATA #IMPLIED name CDATA #IMPLIED value CDATA #IMPLIED&gt; pattern : 匹配模式标签 name : 指定bean的属性名称 value : 指定bean的属性名称的取值所对应名称 设置顶层Bean的一个属性。无论是Bean属性的名称，还是赋予该属性的值，都在当前XML元素中以属性的形式指定.当begin()方法被调用时，digester调用栈顶对象的一个特定的属性设置方法(property setter)并传给它特定的值(property和值分别由两个attribute命名)。这对XML需要遵循一个指定的DTD时比较有用，你可以设置 一个特别的属性(property)，虽然在指定DTD没有attribute与其相对应。利用指定名称和指定名称对应值名称的XML元素属性值，设置顶层Bean的一个或者多个指定名称的属性。 例子：数据文件如下： &lt;product pid=&quot;id&quot; pidValue=&quot;001&quot; pWeight=&quot;weight&quot; pWeightValue=&quot;2kg&quot;&gt; &lt;/product&gt; 对应的规则文件如下： &lt;digester-rules&gt; &lt;pattern value=&quot;product&quot;&gt; &lt;object-create-rule classname=&quot;demo.lesson04.Product&quot;/&gt; &lt;set-property-rule name=&quot;pId&quot; value=&quot;pIdValue&quot;/&gt; &lt;/pattern&gt; &lt;set-property-rule pattern=&quot;product&quot; name=&quot;pWeight&quot; value=&quot;pWeightValue&quot;/&gt; &lt;/digester-rules&gt; (5) 标签属性设置Bean属性规则: set-properties-rule [SetPropertiesRule]语法格式： &lt;!-- SetPropertiesRule --&gt; &lt;!ELEMENT set-properties-rule (alias)*&gt; &lt;!ATTLIST set-properties-rule pattern CDATA #IMPLIED&gt; pattern : 匹配模式标签 当begin()方法被调用时，digester使用标准的Java Relection API来识别JavaBean的属性设置方法(setter method)，这些方法名称中包含属性（property）的名字，这些属性与XML元素的属性(attribute)匹配，于是这些方法被调用并将相 应的属性值(attribute value)传给它们。利用指定名称的XML元素属性值，设置顶层Bean的一个或者多个指定名称的属性。 例子：数据文件如下： &lt;product name=&quot;康师傅方便面&quot; date=&quot;2015/01/15&quot;&gt; &lt;/product&gt; 对应的规则文件如下： &lt;digester-rules&gt; &lt;pattern value=&quot;product&quot;&gt; &lt;object-create-rule classname=&quot;demo.lesson04.Product&quot;/&gt; &lt;set-properties-rule/&gt; &lt;/pattern&gt; &lt;/digester-rules&gt; (6) Bean属性设置规则: bean-property-setter-rule [BeanPropertySetterRule]语法格式： &lt;!-- Bean Property Setter Rule --&gt; &lt;!ELEMENT bean-property-setter-rule EMPTY&gt; &lt;!ATTLIST bean-property-setter-rule pattern CDATA #IMPLIED propertyname CDATA #IMPLIED propertynameFromAttribute CDATA #IMPLIED&gt; pattern : 匹配模式标签 propertyname : 指定属性名字 propertynameFromAttribute : 指定标签属性的名字 把顶层Bean的指定名称的属性设置成当前XML元素包含的字符数据。 例子：数据文件如下： &lt;product&gt; &lt;name&gt;九阳豆浆机&lt;/name&gt; &lt;date&gt;2014/10/20&lt;/date&gt; &lt;/product&gt; 对应的规则文件如下： &lt;digester-rules&gt; &lt;pattern value=&quot;product&quot;&gt; &lt;object-create-rule classname=&quot;demo.lesson04.Product&quot;/&gt; &lt;bean-property-setter-rule pattern=&quot;name&quot; /&gt; &lt;bean-property-setter-rule pattern=&quot;date&quot; /&gt; &lt;/pattern&gt; &lt;/digester-rules&gt; (7) Bean属性设置规则: set-nested-properties-rule [BeanPropertySetterRule]语法格式： &lt;!-- SetNestedPropertiesRule --&gt; &lt;!ELEMENT set-nested-properties-rule (alias)*&gt; &lt;!ATTLIST set-nested-properties-rule pattern CDATA #IMPLIED allow-unknown-child-elements CDATA #IMPLIED&gt; pattern : 匹配模式标签 allow-unknown-child-elements : 指定属性名字 把标签嵌套的子标签设置成Bean的属性。 例子：数据文件如下： &lt;product&gt; &lt;name&gt;九阳豆浆机&lt;/name&gt; &lt;date&gt;2014/10/20&lt;/date&gt; &lt;/product&gt; 对应的规则文件如下： &lt;digester-rules&gt; &lt;pattern value=&quot;product&quot;&gt; &lt;object-create-rule classname=&quot;demo.lesson04.Product&quot;/&gt; &lt;set-nested-properties-rule /&gt; &lt;/pattern&gt; &lt;/digester-rules&gt; 管理父/子关系 #####（8）set-next-rule [SetNextRule]语法格式： &lt;!-- SetNextRule --&gt; &lt;!ELEMENT set-next-rule EMPTY&gt; &lt;!ATTLIST set-next-rule pattern CDATA #IMPLIED methodname CDATA #REQUIRED paramtype CDATA #IMPLIED exactMatch CDATA #IMPLIED fireOnBegin CDATA #IMPLIED&gt; pattern : 匹配模式标签 methodname : 指定属性名字 paramtype : exactMatch : fireOnBegin : 当end()方法被调用时，digester分析第二栈顶元素，寻找一个特定属性(property)的设置方法(setter method)，并接着调用这个方法，以栈顶的元素作参数。这个规则通常用来在两个对象间建立1对多的关系，所用的方法也常被叫做addChild什么的。 #####（9）set-top-rule [SetTopRule]语法格式： &lt;!-- SetTopRule --&gt; &lt;!ELEMENT set-top-rule EMPTY&gt; &lt;!ATTLIST set-top-rule pattern CDATA #IMPLIED methodname CDATA #REQUIRED paramtype CDATA #IMPLIED exactMatch CDATA #IMPLIED fireOnBegin CDATA #IMPLIED&gt; pattern : 匹配模式标签 methodname : 指定属性名字 paramtype : exactMatch : fireOnBegin : 当end()方法被调用时，digester分析栈 顶元素，寻找一个特定属性(property)的设置方法(setter method)，并接着调用这个方法，以第二栈顶的元素作参数。这个规则通常用来在两个对象间建立1对多的关系，所用的方法也常被叫做setParent 什么的。 #####（10）set-root-rule [SetRootRule]语法格式： &lt;!-- SetRootRule --&gt; &lt;!ELEMENT set-root-rule EMPTY&gt; &lt;!ATTLIST set-root-rule pattern CDATA #IMPLIED methodname CDATA #REQUIRED paramtype CDATA #IMPLIED exactMatch CDATA #IMPLIED fireOnBegin CDATA #IMPLIED&gt; pattern : 匹配模式标签 methodname : 指定属性名字 paramtype : exactMatch : fireOnBegin : 调用栈底对象的一个方法，并把栈顶的对象作为参数传入。 调用任意方法 #####（11）call-method-rule [CallMethodRule]语法格式： &lt;!-- CallMethodRule - Note that paramtypes is ignored unless paramcount is defined. --&gt; &lt;!ELEMENT call-method-rule EMPTY&gt; &lt;!ATTLIST call-method-rule pattern CDATA #IMPLIED targetoffset CDATA #IMPLIED methodname CDATA #REQUIRED paramcount CDATA #IMPLIED paramtypes CDATA #IMPLIED usingElementBodyAsArgument CDATA #IMPLIED useExactMatch CDATA #IMPLIED&gt; pattern : 匹配模式标签 targetoffset : methodname : 指定属性名字 paramcount : paramtypes : usingElementBodyAsArgument : useExactMatch : 调用顶层Bean的指定名称的方法。被调用的方法可以有任意多个参数，参数的值通过后继的CallParamRule给出。 #####（12）call-param-rule [CallParamRule]语法格式： &lt;!-- CallParamRule attrname - set param from attribute value (cannot be combined with from-stack or stack-index) from-stack - select an object from the current digester stack to pass as the parameter value. stack-index - select an object from the current digester stack to pass as a parameter value. If this is defined then from-stack is implicitly true. If from-stack is defined but this is not defined then this has an implicit value of zero, ie the top object on the stack is passed as the parameter. --&gt; &lt;!ELEMENT call-param-rule EMPTY&gt; &lt;!ATTLIST call-param-rule pattern CDATA #IMPLIED paramnumber CDATA #REQUIRED attrname CDATA #IMPLIED from-stack CDATA #IMPLIED stack-index CDATA #IMPLIED&gt; pattern : 匹配模式标签 paramnumber : attrname : from-stack : stack-index : 表示方法调用的参数。参数的值或者取自指定名称的XML元素的属性，或者是当前元素包含的原始字符数据。这个规则要求用一个整数指定它在参数列表中的位置。","categories":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/categories/Digester/"}],"tags":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/tags/Digester/"},{"name":"Rule","slug":"Rule","permalink":"https://lbvs86823.github.io/tags/Rule/"}],"keywords":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/categories/Digester/"}]},{"title":"Digester框架简介","slug":"digester/digester","date":"2015-01-15T14:53:21.000Z","updated":"2020-03-20T06:27:43.615Z","comments":true,"path":"2015/01/15/digester/digester/","link":"","permalink":"https://lbvs86823.github.io/2015/01/15/digester/digester/","excerpt":"","text":"1.Digester框架简介Jakarta的Digester框架从Struts框架发展而来，原先被用来处理struts-config.xml配置文件。但很快人们认识到它有着更广泛的用途，把它转入了Jakarta Commons项目。 Digester框架允许开发者指定一组动作，当解析器在XML文档中发现某些特定的简单模式时动作被执行。注意使用Digester框架时，Bean类必须定义成public。 Digester框架以模式（Pattern）和规则（Rule）为基础处理输入的XML。模式必须与XML元素匹配，包括其名字和在文档树内的位置。描述匹配模式的语法类似于XPath匹配模式。 2.Digester的几个重要概念(1)元素匹配模式:元素匹配模式将处理规则与XML元素联系起来。 (2)处理规则处理规则定义了发现匹配的模式时产生的行为.Digester模块已经预定了不少处理规则，自定义的处理规则可以通过扩展 org.apache.commons.digester.Rule类来实现。 (3)对象栈对象栈用来保存处理规则所要处理的对象。对象可以由人为或处理规则压入和弹出对象栈。 3.Digester的模式Digester框架以模式（Pattern）和规则（Rule）为基础处理输入的XML。模式必须与XML元素匹配，包括其名字和在文档树内的位置。描述匹配模式的语法类似于XPath匹配模式。 当Digester发现一个指定的模式，它就执行关联的任务。由此可见，Digester框架显然与SAX解析器有着密切的关系（实际上，Digester类实现了org.xml.sax.ContentHandler，并维护着解析栈）。 首先说一下基本的匹配模式，有三种： Parent Match（可以理解为匹配子元素的精确父匹配）： a/b/c/? */a/b/c/? Ancester Match(可以理解为匹配那种出身自一个精确序列元素的元素)： a/b/* */a/b/* Universal Wildcard Match(可以理解为通配符匹配，都以！开头): !*a/b !a/b/? !*a/b/? !a/b/* !*/a/b/* Wild Match (可以理解为更通用更模糊的通配符匹配): ？代表直接子元素 * 代表任意的父或子元素 ! 代表以什么什么为开头 4.Digester的规则所有在Digester中使用的规则必须继承自org.apache.commons.digester.Rule抽象类，它提供了一些类似于SAX的ContentHandler回调函数的方法。 void begin(String namespace, String name, Attributes attributes) void body(String namespace, String name, String text) void end(String namespace, String name) void finish() Digester getDigester() String getNamespaceURI() void setDigester(Digester digester) void setNamespaceURI(String namespaceURI) 当遇到匹配元素的开始标记和结束标记时，begin()方法和end()方法将分别被调用。一旦遇到匹配元素的内容，body()方法被调用；最后被调用的方法是finish()，这个方法在匹配元素的结束标记处理完毕之后被调用，用来执行可能需要的事后清理任务。然而，大多数时候我们不必关注这些方法，因为框架提供的标准规则很可能已经提供了所有必需的功能。 添加规则([1]通过程序硬编码 [2]通过规则文件配置)：[1]通过程序硬编码配置规则：你可以直接调用digester的addRule方法，该方法会将一个rule对象和它所匹配的模式添加到digester对象中。 void addRule(String pattern, Rule rule) Digester类的addRule方法的实现如下： public void addRule(String pattern, Rule rule) { rule.setDigester(this); getRules().add(pattern, rule); } 查看Digester类的addObjectCreate方法的重载实现如下(创建对象规则)： public void addObjectCreate(String pattern, String className) { addRule(pattern, new ObjectCreateRule(className)); } public void addObjectCreate(String pattern, Class clazz) { addRule(pattern, new ObjectCreateRule(clazz)); } public void addObjectCreate(String pattern, String className, String attributeName) { addRule(pattern, new ObjectCreateRule(className, attributeName)); } public void addObjectCreate(String pattern, String attributeName, Class clazz) { addRule(pattern, new ObjectCreateRule(attributeName, clazz)); } 这四个重载的方法都调用了addRule方法，ObjectCreateRule类是Rule的子类，该类的实例可作为addRule方法的第二个参数使用。 向digester对象中添加rule还可以调用addRuleSet方法，方法签名如下： void addRuleSet(RuleSet ruleSet) org.apache.commons.digester.RuleSet接口类表示了rule对象的集合。该接口定义了两个方法addRuleInstance和getNamespaceURI，方法签名如下： void addRuleInstances(Digester digester) String getNamespaceURI() addRuleInstance方法会添加rule集合到digester对象中。getNamespaceURI方法返回命名空间uri，该uri会匹配到RuleSet中所有的rule对象。因此，创建了digester对象后，可以创建一个RuleSet对象，然后将RuleSet对象传给digester的addRuleSet方法。 RuleSetBase类实现了RuleSet接口，RuleSetBase是一个虚类，提供了getNamespaceURI方法的实现，使用者只需要提供addRuleInstance方法的实现即可。 digester还定义了一个规则的容器接口Rules(抽象类)，这个抽象类接口容器容纳规则，并定义了规则匹配的模式，digester实现了一个基本的匹配模式RulesBase. 同时，对这些规则，digester还定义了一个规则的容器接口Rules(抽象类)，这个抽象类接口容器容纳规则，并定义了规则匹配的模式，digester实现了一个基本的匹配模式RulesBase。 其中AbstractRulesModule是对RulesModule的封装，原本需要通过cinfigure传进的RulesBinder来设置规则，经过封装直接调用相应的方法就可以设置规则了。 public class EmpRuleModule extends AbstractRulesModule { @Override protected void configure() { System.out.println(&quot;type&quot;); //根据具体类创建对象 forPattern(&quot;emp&quot;).createObject().ofType(Emp.class);//.then().setProperties();//要一条龙的写法则通过then方法！ //设置标签上的全部对应属性 forPattern(&quot;emp&quot;).setProperties(); //将子节点set到其父节点 forPattern(&quot;emp/name&quot;).setBeanProperty(); forPattern(&quot;emp/id&quot;).setBeanProperty(); } } 以上基本实现只是digester默认匹配规则，如果你要更换自己的规则匹配模式，则只需要继承org.apache.commons.digester.Rules接口，定义自己的匹配方式，digester同时还给我们提供了一个比较复杂，不过非常常用的匹配模式，那就是通配符匹配模式，引入了”!“、”*“、”?“三个符号进行通配的匹配模式，这个类就是org.apache.commons.digester.ExtendsBaseRules。 而digester缺省定义了许多有效的常用规则，每个规则都实现这个接口, 如果没有什么特殊需求，一般这些规则是够用了。 下面简要说明所有标准规则(10个标准规则)：创建: ObjectCreateRule：利用指定类的默认构造函数，创建该类的一个对象，并把对象压入栈。当元素处理结束时，对象被弹出。被实例化的类可通过class对象或类的全称给出。 FactoryCreateRule：利用指定的工厂类创建一个对象，把对象压入栈。对于没有提供默认构造函数的类，这一规则很有用。用于该规则的工厂类必须实现org.apache.commons.digester.ObjectCreationFactory接口。 设置属性: SetPropertiesRule：利用指定名称的XML元素属性值，设置顶层Bean的一个或者多个指定名称的属性。XML元素的属性名称和Bean的属性名称以String[]数组形式传入该规则（通常用来处理之类的结构）。 BeanPropertySetterRule：把顶层Bean的指定名称的属性设置成当前XML元素包含的字符数据。（通常用来处理10之类的结构）。 SetPropertyRule：设置顶层Bean的一个属性。无论是Bean属性的名称，还是赋予该属性的值，都在当前XML元素中以属性的形式指定，例如：。 管理父/子关系: SetNextRule：弹出栈顶的对象，把它传递给紧接其下的另一个对象的指定名称的方法。通常用来把一个已经初始化的Bean插入到父对象。 SetTopRule：把栈里面上数第二的对象传递给顶层的对象。当子对象提供了一个setParenet方法时，这一规则很有用。 SetRootRule：调用栈底对象的一个方法，并把栈顶的对象作为参数传入。 调用任意方法: CallMethodRule：调用顶层Bean的指定名称的方法。被调用的方法可以有任意多个参数，参数的值通过后继的CallParamRule给出。 CallParamRule：表示方法调用的参数。参数的值或者取自指定名称的XML元素的属性，或者是当前元素包含的原始字符数据。这个规则要求用一个整数指定它在参数列表中的位置。 其他规则： NodeCreateRule：ObjectParamRule：指定对象作为指定索引的值，配合CallMethodRule使用。PathCallParamRule：提供当前匹配的模式路径作为方法调用所需要的参数，配合CallMethodRule使用。SetNestedPropertiesRule：当前匹配模式的直接子元素和对应bean的属性之间的映射. [2]通过规则文件配置规则在前面的内容中，我们用程序代码的方式指定模式和规则，这些模式和规则都是在编译的时候就已经确定，虽然从概念上来讲比较简单，但却不能说尽善尽美：Digester框架的总体目标是在运行时识别和处理各种数据结构，但如果我们用编程的方法指定模式和规则，则所有行为在编译时已经固定！如果Java源程序中包含了大量固定的字符串，通常意味着程序在执行某些配置操作，这部分操作可以被（或许是应该被）延迟到运行时进行。 org.apache.commons.digester.xmlrules包解决了这个问题。这个包提供了一个DigesterLoader类，它能够从XML文档读取模式/规则对，返回配置好的Digester对象。用来配置Digester对象的XML文档必须遵从digester-rules.dtd，这个DTD是xmlrules包的一部分。 首先，模式可以用两种方式指定：或者使用元素，或者通过代表规则的XML元素的属性。这两种办法可以混合使用，且元素是可以嵌套的。 其次，元素和一起使用，用来把XML属性映射到Bean属性。 最后，就当前发行的Digester软件包而言，我们不能在配置文件中指定BeanPropertySetterRule，正如前面所介绍的，我们用CallMethodRule来达到同样的目标。 其中一个在这里忽略的主题是XML名称空间：Digester允许把规则定义成只能对某一个名称空间内定义的元素起作用。 classLoader 类加载器，当使用ObjectCreateRule 和 FactoryCreateRule规则时使用classLoader加载规则需要的类。如果不设置程序会调用线程类加载器或者使用加载Digester时所使用的加载器。 errorHandler 定义自己的SAX ErrorHandler，默认的把所有解析错误输出到日志，但是Digester会继续进行解析。 namespaceAware 是否使用xml命名空间 ruleNamespaceURI 命名空间位置 rules 匹配规则 useContextClassLoader 是否使用上下文类加载器 validating 是否进行特点规则校验，默认执行格式良好校验 5.Digster的对象栈Digester公开一个堆栈当xml元素满足某个模式是，就会调用注册的方法去创建一个对象，并放入对象堆栈中。常用的堆栈操作方法有：clear() 清理堆栈peek() 获取栈顶的对象pop() 栈顶的对象出栈push() 对象入栈 6.Digester库的主类org.apache.commons.digester.Digester类是Digester库的主类。该类可用于解析xml文件，对与xml文档中的每个元素，Digester对象都会检查是否要做事先预定义的事件。 创建对象:若想要digester根据找到的模式创建相应的对象，则可以调用addObjectCreate方法。该方法有四个重载版本: void addObjectCreate(String pattern, Class&lt;?&gt; clazz) 模式名 类对象 void addObjectCreate(String pattern, String className) 模式名 类的完整类名 void addObjectCreate(String pattern, String attributeName, Class&lt;?&gt; clazz) 模式名 节点属性名 类对象 void addObjectCreate(String pattern, String className, String attributeName) 模式名 类的完整类名 节点属性名 创建的对象会被存储在一个栈中，可以用pop，push等方法对栈进行操作。如果包含attributeName属性名，则默认就采用这个attributeName所对应的值来加载实例。 工厂类创建对象: void addFactoryCreate(String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz) void addFactoryCreate(String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz, boolean ignoreCreateExceptions) void addFactoryCreate(String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz, String attributeName) void addFactoryCreate(String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz, String attributeName, boolean ignoreCreateExceptions) void addFactoryCreate(String pattern, ObjectCreationFactory&lt;?&gt; creationFactory) void addFactoryCreate(String pattern, ObjectCreationFactory&lt;?&gt; creationFactory, boolean ignoreCreateExceptions) void addFactoryCreate(String pattern, String className) void addFactoryCreate(String pattern, String className, boolean ignoreCreateExceptions) void addFactoryCreate(String pattern, String className, String attributeName) void addFactoryCreate(String pattern, String className, String attributeName, boolean ignoreCreateExceptions) ignoreCreateExceptions:表明是否忽略在创建类的过程中忽略抛出的exception。这里的attributeName参数，这个参数跟ObjectCreationRule规则中的attributeName雷同，不同的是这个属性的值必须是实现了ObjectCreationFactory接口的类。 设置属性:addSetProperties，使用该方法可以为创建的对象设置属性。 void addSetProperties(String pattern) void addSetProperties(String pattern, String[] attributeNames, String[] propertyNames) void addSetProperties(String pattern, String attributeName, String propertyName) void addSetProperty(String pattern, String name, String value) 调用方法:Digester类允许通过添加一个rule的方式来调用栈顶对象的方法。该方法签名如下： void addCallMethod(String pattern, String methodName) void addCallMethod(String pattern, String methodName, int paramCount) void addCallMethod(String pattern, String methodName, int paramCount, Class&lt;?&gt;[] paramTypes) void addCallMethod(String pattern, String methodName, int paramCount, String[] paramTypes) CallParamRule用来定义传递给被调用函数的参数值，参数值可以从当前XML元素的命名的属性获取，也可以从当前元素包含的原始字符数据获取. 创建对象之间的关系: Digester对象中包含有一个内部栈，用于临时存储创建的对象。当使用addObjectCreate方法创建一个对象时，生成的对象会存储在这个栈中。addSetNext方法用于创建栈中两个对象之间的关系，实际上，这两个对象是xml文件中两个具有父子关系的标签所对应的对象。方法签名如下： void addSetNext(String pattern, String methodName) 参数pattern是子元素对应的模式，参数methodName是父元素添加子元素时使用的方法名。 void addSetNext(String pattern, String methodName, String paramType) 验证xml文档:Digester对象解析的xml文档的有效性可通过schema进行验证，然后将结果记录与Digester对象的validating属性中，该属性默认为false。setValidating方法用于设置是否要对xml文件进行验证，方法签名如下： void setValidating(boolean validating)","categories":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/categories/Digester/"}],"tags":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/tags/Digester/"},{"name":"Rule","slug":"Rule","permalink":"https://lbvs86823.github.io/tags/Rule/"}],"keywords":[{"name":"Digester","slug":"Digester","permalink":"https://lbvs86823.github.io/categories/Digester/"}]},{"title":"git 命令手册","slug":"tools/git_command","date":"2012-03-08T06:25:31.000Z","updated":"2021-06-01T07:28:30.009Z","comments":true,"path":"2012/03/08/tools/git_command/","link":"","permalink":"https://lbvs86823.github.io/2012/03/08/tools/git_command/","excerpt":"","text":"1、初始化仓库git init 2、将文件添加到仓库git add 文件名 # 将工作区的某个文件添加到暂存区 git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件 git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件 git add . # 将当前工作区的所有文件都加入暂存区 git add -i # 进入交互界面模式，按需添加文件到缓存区 3、将暂存区文件提交到本地仓库git commit -m &quot;提交说明&quot; # 将暂存区内容提交到本地仓库 git commit -a -m &quot;提交说明&quot; # 跳过缓存区操作，直接把工作区内容提交到本地仓库 4、查看仓库当前状态git status 5、比较文件异同git diff # 工作区与暂存区的差异 git diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名 git diff HEAD # 工作区与HEAD指针指向的内容差异 git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异 git diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached) git diff 版本TAG # 查看从某个版本后都改动内容 git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG) git diff 分支A...分支B # 比较两分支在分开后各自的改动 # 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数 6、查看历史记录git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明) git log -p -次数 # 查看最近多少次的提交记录 git log --stat # 简略显示每次提交的内容更改 git log --name-only # 仅显示已修改的文件清单 git log --name-status # 显示新增，修改，删除的文件清单 git log --oneline # 让提交记录以精简的一行输出 git log –graph –all --online # 图形展示分支的合并历史 git log --author=作者 # 查询作者的提交记录(和grep同时使用要加一个--all--match参数) git log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录 git log -S查询内容 # 和--grep类似，S和查询内容间没有空格 git log fileName # 查看某文件的修改记录，找背锅专用 7、代码回滚git reset HEAD^ # 恢复成上次提交的版本 git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数 git reflog git reset --hard 版本号 # 可以把暂存区的修改撤销掉（unstage），重新放回工作区 --soft：只是改变HEAD指针指向，缓存区和工作区不变； --mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变； --hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态； 8、同步远程仓库git push -u origin master 9、删除版本库文件git rm 文件名 10、版本库里的版本替换工作区的版本git checkout -- test.txt 11、本地仓库内容推送到远程仓库git remote add origin git@github.com:帐号名/仓库名.git 12、从远程仓库克隆项目到本地git clone git@github.com:git帐号名/仓库名.git 13、创建分支git checkout -b dev # -b 表示(以当前所在版本分支)创建并切换分支 上面一条命令相当于一面的二条： git branch dev # 创建分支 git checkout dev # 切换分支 14、查看分支，远程分支，本地分支，创建/设置 跟踪关系git branch # 查看分支 git branch -vv # 查看当前本地所有分支对应的上游分支 当我们从1个远程分支切出（创建）一个本地分支时:该本地分支就叫跟踪分支（tracking branch）,而远程分支叫上游分支（upstream branch）。把本地分支关联到远程仓库的上游分支，为每个更新(pull)或推送(push)的分支设置远程引用，否则：若本地分支未绑定远程分支，git pull 或 git push 时将无法正常执行。 创建/设置 跟踪关系git checkout -b 本地分支a分支 远端主机别名B/远程分支名c #从远程分支(远端主机B上的c分支)切出/创建新的本地分支a分支 git checkout --track 远端主机别名B/远程分支名c # 当然也可不指定本地分支名，直接使用远程分支(同名) git branch -u 远端主机别名B/远程分支名c # 指明当前本地分支跟踪某远端主机B的远程分支c (u=upstream-branch) git push --set-upstream origin &lt;远程分支名&gt; # 把本地分支关联到远程主分支；为每个更新或推送的分支设置远程引用，若远程仓库没有&lt;远程分支名&gt;时，会自动创建该分支名 (使用 -u 与 --set-upstream 参数等同) 例子：git checkout -b localDev origin/dev # 从远程分支(远端主机origin上的dev分支)切出/创建新的本地分支localDev分支 git push --set-upstream origin dev # 把本地分支关联到远程主分支dev若远程仓库没有则创建 git push -u origin dev # 把本地分支关联到远程主分支dev若远程仓库没有则创建 15、合并分支git merge dev # 用于合并指定分支到当前分支 git merge --no-ff -m &quot;merge with no-ff&quot; dev # 加上--no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并 16、删除分支git branch -d dev 17、查看分支合并图git log --graph --pretty=oneline --abbrev-commit 18、查看远程库信息git remote # -v 显示更详细的信息 git remote -v # 显示远程库的详细信息 git remote add repositoryA 远程仓库地址 # 增加一个远程仓库，并取名叫 &quot;repositoryA&quot; 比如: 一般的我们会显示如下信息, 表示我们有一个远程仓库名字叫 “origin”， Git默认创建的名字(当然可以叫其他的)。 git remote -v # 你可以看到如下信息 origin http://192.168.16.253:8080/gitblit/r/repository.git (fetch) origin http://192.168.16.253:8080/gitblit/r/repository.git (push) git remote add repoA https://github.com/xxxxx/repository.git # 增加远程仓库 repoA git remote -v # 你可以看到如下信息 origin http://192.168.16.253:8080/gitblit/r/repository.git (fetch) origin http://192.168.16.253:8080/gitblit/r/repository.git (push) repoA https://github.com/xxxxx/repository.git (fetch) repoA https://github.com/xxxxx/repository.git (push) 19、git相关配置# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)： git config --global user.name &quot;用户名&quot; # 设置用户名 git config --global user.email &quot;用户邮箱&quot; #设置邮箱 git config --global user.name # 查看用户名是否配置成功 git config --global user.email # 查看邮箱是否配置 # 其他查看配置相关 git config --global --list # 查看全局设置相关参数列表 git config --local --list # 查看本地设置相关参数列表 git config --system --list # 查看系统配置参数列表 git config --list # 查看所有Git的配置(全局+本地+系统) git config --global color.ui true //显示git相关颜色 20、撤消某次提交git revert HEAD # 撤销最近的一个提交 git revert 版本号 # 撤销某次commit 21、拉取远程分支到本地仓库git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支 git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout git branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接 22、标签命令git tag 标签 # 打标签命令，默认为HEAD git tag # 显示所有标签 git tag 标签版本号 # 给某个commit版本添加标签 git show 标签 # 显示某个标签的详细信息 23、同步远程仓库更新git fetch origin master # 从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。 git fetch比git pull更加安全 24、其他git stash list ：查看所有的现场列表 git stash ：可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 git stash apply stash@{0} ： 恢复现场， 不删除现场 git stash drop stash@{0} ： 删除现场 git stash pop stash@{0} ：恢复现场的同时删除现场 git remote -v ：查看远程库的信息 git push origin &lt;name&gt; 把name分支上的所有本地提交推送到远程库 git pull : 拉取远程最新的版本 git branch --set-upstream-to=origin/dev dev ：指定本地dev分支与远程origin/dev分支链接起来 工作区（Working Directory） 版本库（Repository） 暂存区（Stage）","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lbvs86823.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://lbvs86823.github.io/tags/github/"},{"name":"gitLab","slug":"gitLab","permalink":"https://lbvs86823.github.io/tags/gitLab/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"HashMap实现原理解析","slug":"javacore/hashMap","date":"2011-06-29T04:53:49.000Z","updated":"2020-03-20T06:27:43.625Z","comments":true,"path":"2011/06/29/javacore/hashMap/","link":"","permalink":"https://lbvs86823.github.io/2011/06/29/javacore/hashMap/","excerpt":"","text":"一，HashMap的概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。既然是实现原理解析，我们就会从已经下几个方面对其进行阐述： 它内部的数据结构是怎么样的？ 它是怎么初始化的？ 它是如何对Key-Value键值对进行增删改查的？ 既然是HashMap那么它的Hash算法是怎样的？ 它的扩容机制是怎样的？ 它的并发同步问题等？ 二，HashMap的数据结构：要知道hashMap是什么，首先要搞清楚它的数据结构，在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。HashMap主要是用数组来存储数据的，我们都知道它会对key进行哈希运算，哈系运算会有重复的哈希值，对于哈希值的冲突，HashMap采用链表来解决的。所以Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。 从图中我们可以看到一个HashMap就是一个数组结构，当新建一个HashMap的时候，就会初始化一个数组；一个链表结构，用来解决Hash冲突，那么在代码层面他们是如何实现的呢？进入HashMap的源码里可以看到如下的代码: -----------数组结构------------------- transient Entry&lt;K,V&gt;[ ] table; -----------链表实现类------------------ static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; //保存当前元素的下一个元素 Entry&lt;K,V&gt; next; int hash; //构造方法 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; key = k; hash = h; } //后面代码...... } 从上面的代码可以看出，HashMap存储数据所用的类就是Entry&lt;K,V&gt;。 然而在HashMap中为了解决哈希冲突的问题，它自身实现时，多个了next 元素，当有存在冲突的元素时，就会用来处理冲突的问题。 三，HashMap的初始化：先来看看几个代码中的关键属性： //默认的初始化容量 static final int DEFAULT_INITIAL_CAPACITY = 16; //最大的容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //扩容阀值 int threshold; //加载因子 final float loadFactor; 接下来看看它的几个构造函数： //以默认容量16，默认加载因子0.75进行初始化 public HashMap() { this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); } //以指定容量，默认加载因子0.75进行初始化 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } //以指定容量，指定加载因子进行初始化 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 设置初始化容量为一个大于你设置容量的2的幂值(为什么？后面会解释) int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; //扩容阀值的计算方式 threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); //这是一个空的方法，为子类提供自己的初始化动作的一个钩子。 init(); } //以另外一个Map作为参数进行初始化 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { //首先根据传入参数map的容量进行初始化容量的设置，减少扩容带来的性能损耗 this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); putAllForCreate(m); } 四，HashMap的操作：存储操作代码如下： public V put(K key, V value) { //专门处理存放空值的情况(实际上就是把将value放置在数组第一个位置) if (key == null) return putForNullKey(value); //对key做hash处理 int hash = hash(key); //根据hash和数组(桶)的长度确定存放位置 int i = indexFor(hash, table.length); //取出指定位置的桶，遍历该桶存储的列表 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; // 如果key的hash值相同并且key相同则认为已经存在该元素，进行更新操作。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; //这个方法提供给子类实现特定的逻辑 e.recordAccess(this); return oldValue; } } //运行到这里表明还没有存储过该key值...... //(对map进行结构上的修改，那么此计数器就会加1) modCount++; //添加一个key-value值 addEntry(hash, key, value, i); return null; } 我们细看下(putForNullKey)他们对key空值的处理代码： private V putForNullKey(V value) { //默认取出数值的第一个桶里的链表进行遍历 for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { //如果已经存在空的key，那么就把原来的对应的值进行更新 if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //运行到这里表明还没有存储过该key值...... //(对map进行结构上的修改，那么此计数器就会加1) modCount++; //添加一个key为null的 key-value值Entry对象 addEntry(0, null, value, 0); return null; } 我们在看下新增一个key非null的key-value值Entry对象是怎么处理的： //根据桶在数组中的索引位置进行添加 void addEntry(int hash, K key, V value, int bucketIndex) { //存数据之前，先检查当前数据量是否超过了阀值，并对其进行扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } //新创建一个key-value的Entry值放入桶中 void createEntry(int hash, K key, V value, int bucketIndex) { Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //HashMap的存放数据大小 +1 size++; } 根据上面的分析，HashMap的初始默认容量是16，默认加载因子是0.75，也就是说，如果采用HashMap的默认构造函数，当增加数据时，数据实际容量超过阀值(threshold):16 * 0.75=12时，HashMap就扩容(扩容为原来数组的2倍)，扩容带来一系列的运算，新建一个是原来容量2倍的数组，对原有元素全部重新哈希，如果你的数据有几千几万个，而用默认的HashMap构造函数，那结果是非常悲剧的，因为HashMap不断扩容，不断哈希，在使用HashMap的场景里，不会是多个线程共享一个HashMap,除非对HashMap包装并同步，由此产生的内存开销和cpu开销在某些情况下可能是致命的。 获取操作代码如下： public V get(Object key) { if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); } //获取key为null的值的方法 private V getForNullKey() { for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } //获取key不为null的Entry对象的方法 final Entry&lt;K,V&gt; getEntry(Object key) { int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; } 删除操作代码如下： public V remove(Object key) { Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); } //根据key 删除一个Entry对象 final Entry&lt;K,V&gt; removeEntryForKey(Object key) { int hash = (key == null) ? 0 : hash(key); //根据key的hash找出桶在数组中的位置 int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; //遍历该桶里的链表，找出key对应的Entry对象 while (e != null) { Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { //(对map进行结构上的修改，那么此计数器就会加1) modCount++; //对应存储数量减1 size--; //如果恰好是第一个，则桶指向下一个元素 if (prev == e) table[i] = next; else //否则，将上一个元素的next指向下一个元素 prev.next = next; //提供给子类使用的空方法 e.recordRemoval(this); return e; } prev = e; e = next; } return e; } 从上面的三个操作可以看出，一个查找指定key对应的Entry对象时都有如下的一段代码： if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { //相关代码。。。。。。 } 于是，我们可以看出所谓的key相同，包括得满足e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)) 为true。如果你hash值相等，而我们重写的equls方法判定不为true还是算key不同的。所以，小心设计你key的这两个方法吧。 在改写equals方法的时候，需要满足以下三点：(1) 自反性：就是说a.equals(a)必须为true。(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。 五，HashMap的hash函数实现：我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速的方法呢？看看JDK里面的代码是如何实现的： //计算hash值 int hash = (key == null) ? 0 : hash(key); //根据key的hash值，找出桶在数组中的位置 int i = indexFor(hash, table.length); 这个hash方法的设计原则就是要：低重码率，高性能。所以我们看下他们是如何实现的： //计算key的hash值 final int hash(Object k) { int h = 0; if (useAltHashing) { if (k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h = hashSeed; } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); } //根据hash值和数组的长度确定桶在数组中的位置 static int indexFor(int h, int length) { return h &amp; (length-1); } 从这段代码可以看出，当length总是2的n次方时，h &amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。为了保证这种高效的算法实现，我们可以很清楚的明白为什么会对HashMap的构造函数中的initialCapacity初始容量参数做如下的处理了： int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。 六，HashMap的扩容机制：下面我们来看看HashMap的扩容方法是如何扩容的： void resize(int newCapacity) { //先保存原来的数组 Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //根据扩容后的长度新建一个数组 Entry[] newTable = new Entry[newCapacity]; boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() &amp;&amp; (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; //这里将原来老的数据根据hash值重新放入新的数组中 transfer(newTable, rehash); //将扩容后的新数组指向原数组 table = newTable; //重新计算扩容的阀值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } //转移所有的老数据 void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) { while(null != e) { Entry&lt;K,V&gt; next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } } } 六，HashMap的并发同步线程安全性问题：Fail-Fast机制：我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。 这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; { Entry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry&lt;K,V&gt; current; // current entry HashIterator() { //迭代器初始化过程中会将这个值赋 expectedModCount = modCount; if (size &gt; 0) { // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } } public final boolean hasNext() { return next != null; } final Entry&lt;K,V&gt; nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); } current = e; return e; } public void remove() { if (current == null) throw new IllegalStateException(); //如果在使用迭代器的过程中有其他线程修改,导致修改数量发生变化，抛出异常，删除操作失败 if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; } } 由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。 HashMap是线程不安全的，如果被多个线程共享的操作，将会引发不可预知的问题，据sun的说法，在扩容时，会引起链表的闭环，在get元素时，就会无限循环，后果是cpu100%。","categories":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lbvs86823.github.io/tags/java/"},{"name":"Map","slug":"Map","permalink":"https://lbvs86823.github.io/tags/Map/"},{"name":"HashMap","slug":"HashMap","permalink":"https://lbvs86823.github.io/tags/HashMap/"}],"keywords":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}]},{"title":"Java enum 的用法详解","slug":"javacore/enum","date":"2011-06-27T14:03:19.000Z","updated":"2020-03-20T06:27:43.623Z","comments":true,"path":"2011/06/27/javacore/enum/","link":"","permalink":"https://lbvs86823.github.io/2011/06/27/javacore/enum/","excerpt":"","text":"Java Enum 原理Java Enum类型的语法结构尽管和java类的语法不一样，应该说差别比较大。但是经过编译器编译之后产生的是一个class文件。该class文件经过反编译可以看到实际上是生成了一个final类，该类继承了java.lang.Enum. (1) 构造器只是在构造枚举值的时候被调用。 (2) 构造器只能私有private，绝对不允许有public构造器。 (3) 所有枚举类都继承了Enum的方法。 下面我们详细介绍Enum的这些方法： ordinal()方法: 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。 Color.RED.ordinal(); //返回结果：0 Color.BLUE.ordinal(); //返回结果：1 compareTo()方法: Enum实现了java.lang.Comparable接口，因此可以比较象与指定对象的顺序。Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。 Color.RED.compareTo(Color.BLUE); //返回结果 -1 values()方法：静态方法，返回一个包含全部枚举值的数组。 Color[] colors=Color.values(); for(Color c:colors){ System.out.print(c + &quot;,&quot;); }//返回结果：RED,BLUE,BLACK YELLOW,GREEN, toString()方法：返回枚举常量的名称。 Color c=Color.RED; System.out.println(c);//返回结果: RED valueOf()方法：这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。 Color.valueOf(“BLUE”); //返回结果: Color.BLUE equals()方法：比较两个枚举类对象的引用。 1.常量定义在JDK1.5 之前，我们定义常量都是： public static fianl…. 。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。用常量的好处是显而易见的，不仅可以保证单例，且比较时候可以用”==”来替换equals，是一种好的习惯。JDK1.5之前没有Enum这个类型，那时候一般用接口常量来替代。有了Java Enum 之后，可以更贴近的表示这种常量。 案例： public enum Color { RED, GREEN, BLANK, YELLOW } 2.switch 状态转换JDK1.6之前的switch语句只支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。 案例： enum Signal { GREEN, YELLOW, RED } public class TrafficLight { Signal color = Signal.RED; public void change() { switch (color) { case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; } } } 3.向枚举中添加自定义方法如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。 案例： public enum Color { RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } // 普通方法 public static String getName(int index) { for (Color c : Color.values()) { if (c.getIndex() == index) { return c.name; } } return null; } // get set 方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } } 4.覆盖枚举的方法案例： public class Test { public enum Color { RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } // 覆盖方法 @Override public String toString() { return this.index + &quot;_&quot; + this.name; } } public static void main(String[] args) { System.out.println(Color.RED.toString()); } } 5.实现接口所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。 案例 public interface Behaviour { void print(); String getInfo(); } public enum Color implements Behaviour { RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } // 接口方法 @Override public String getInfo() { return this.name; } // 接口方法 @Override public void print() { System.out.println(this.index + &quot;:&quot; + this.name); } } 6.使用接口组织枚举案例 public interface Food { enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO } enum Dessert implements Food { FRUIT, CAKE, GELATO } } 7.枚举集合的使用java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复;EnumMap中的 key是enum类型，而value则可以是任意类型。 8.枚举和常量定义的区别通常定义常量方法如下： public class Light { /* 红灯 */ public final static int RED = 1; /* 绿灯 */ public final static int GREEN = 3; /* 黄灯 */ public final static int YELLOW = 2; } 枚举类型定义常量方法如下： public enum Light { RED, GREEN, YELLOW; } 我们只能够表示出红灯、绿灯和黄灯，但是具体的值我们没办法表示出来。别急，既然枚举类型提供了构造函数，我们可以通过构造函数和覆写toString方法来实现。首先给Light枚举类型增加构造方法，然后每个枚举类型的值通过构造函数传入对应的参数，同时覆写toString方法，在该方法中返回从构造函数中传入的参数，改造后的代码如下： public enum Light { // 利用构造函数传参 RED(1), GREEN(3), YELLOW(2); // 定义私有变量 private int nCode; // 构造函数，枚举类型只能为私有 private Light(int _nCode) { this.nCode = _nCode; } @Override public String toString() { return String.valueOf(this.nCode); } } 9.杂谈public class State { public static final int ON = 1; public static final Int OFF= 0; } 有什么不好了，大家都这样用了很长时间了，没什么问题啊。首先，它不是类型安全的。你必须确保是int其次，你还要确保它的范围是0和1最后，很多时候你打印出来的时候，你只看到 1 和 0但其没有看到代码的人并不知道你的企图，抛弃你所有旧的public static final常量吧！ 可以创建一个enum类，把它看做一个普通的类。除了它不能继承其他类了。(java是单继承，它已经继承了Enum),可以添加其他方法，覆盖它本身的方法。 switch()参数可以使用enum了. values()方法是编译器插入到enum定义中的static方法，所以，当你将enum实例向上转型为父类Enum是，values()就不可访问了。解决办法：在Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法，我们仍然可以通过Class对象取得所有的enum实例. 无法从enum继承子类，如果需要扩展enum中的元素，在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组。达到将枚举元素进行分组。 使用EnumSet代替标志。enum要求其成员都是唯一的，但是enum中不能删除添加元素。 EnumMap的key是enum，value是任何其他Object对象。 enum允许程序员为eunm实例编写方法。所以可以为每个enum实例赋予各自不同的行为。 使用enum的职责链(Chain of Responsibility) .这个关系到设计模式的职责链模式。以多种不同的方法来解决一个问题。然后将他们链接在一起。当一个请求到来时，遍历这个链，直到链中的某个解决方案能够处理该请求。 使用enum的状态机 使用enum多路分发","categories":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lbvs86823.github.io/tags/Java/"},{"name":"enum","slug":"enum","permalink":"https://lbvs86823.github.io/tags/enum/"}],"keywords":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}]},{"title":"Spring oauth2 相关概念解释","slug":"spring/oauth2.0","date":"2011-06-15T02:21:20.000Z","updated":"2020-03-20T06:27:43.674Z","comments":true,"path":"2011/06/15/spring/oauth2.0/","link":"","permalink":"https://lbvs86823.github.io/2011/06/15/spring/oauth2.0/","excerpt":"","text":"协议的参与者:OAuth的参与实体至少有如下三个： RO (resource owner): 资源所有者，对资源具有授权能力的人。如用户Alice RS (resource server): 资源服务器，它存储资源，并处理对资源的访问请求。如Google资源服务器，它所保管的资源就是用户Alice的照片。 Client: 第三方应用，它获得RO的授权后便可以去访问RO的资源。（照片打印商） 此外，为了支持开放授权功能以及更好地描述开放授权协议，OAuth引入了第四个参与实体： AS (authorization server): 授权服务器，它认证RO的身份，为RO提供授权审批流程，并最终颁发授权令牌(Access Token)。注意，为了便于协议的描述，这里只是在逻辑上把AS与RS区分开来；在物理上，AS与RS的功能可以由同一个服务器来提供服务。 客户端的授权模式客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 授权码模式:客户端申请认证的URI，包含以下参数： response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值 (用于抵制CSRF攻击)。 请求中还可以包含access_type和approval_prompt参数。当approval_prompt=force时，AS将提供交互页面，要求RO必须显式地批准（或拒绝）Client的此次请求。 如果没有approval_prompt参数，则默认为RO批准此次请求。 当access_type=offline时，AS将在颁发access_token时，同时还会颁发一个refresh_token。因为access_token的有效期较短（如3600秒），为了优化协议执行流程，offline方式将允许Client直接持refresh_token来换取一个新的access_token。 客户端向认证服务器申请令牌的HTTP请求，包含以下参数：grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。code：表示上一步获得的授权码，必选项。redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。client_id：表示客户端ID，必选项。 认证服务器发送的HTTP回复，包含以下参数：access_token：表示访问令牌，必选项。token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 简化模式:客户端发出的HTTP请求，包含以下参数：response_type：表示授权类型，此处的值固定为”token”，必选项。client_id：表示客户端的ID，必选项。redirect_uri：表示重定向的URI，可选项。scope：表示权限范围，可选项。state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 认证服务器回应客户端的URI，包含以下参数：access_token：表示访问令牌，必选项。token_type：表示令牌类型，该值大小写不敏感，必选项。expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 密码模式:客户端发出的HTTP请求，包含以下参数： grant_type：表示授权类型，此处的值固定为”password”，必选项。 username：表示用户名，必选项。 password：表示用户的密码，必选项。 scope：表示权限范围，可选项。 认证服务器向客户端发送访问令牌,包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token : 表示更新令牌，用来获取下一次的访问令牌，可选项。 客户端模式:客户端发出的HTTP请求，包含以下参数： granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 scope：表示权限范围，可选项。 认证服务器向客户端发送访问令牌,包含以下参数： “access_token”:”2YotnFZFEjr1zCsicMWpAA”, “token_type”:”example”, “expires_in”:3600, “example_parameter”:”example_value” 更新令牌:如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。客户端发出更新令牌的HTTP请求，包含以下参数：granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。refresh_token：表示早前收到的更新令牌，必选项。scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。 ===================================================================== 1XX - informational 2XX - success 3XX - redirection 4XX - client error 5XX - server error =====================================================================spring-security-oauth2的项目地址为 https://github.com/spring-projects/spring-security-oauth/tree/master/spring-security-oauth2spring-security-oauth2的demo 地址为 https://github.com/spring-projects/spring-security-oauth/tree/master/samples/oauth2OAuth 2.0 协议 http://www.rfcreader.com/#rfc6749http://www.open-open.com/lib/view/open1412731740452.htmlhttp://projects.spring.io/spring-security-oauth/docs/oauth2.html","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"security","slug":"security","permalink":"https://lbvs86823.github.io/tags/security/"},{"name":"auth2","slug":"auth2","permalink":"https://lbvs86823.github.io/tags/auth2/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"Spring Security 中涉及到的核心类介绍","slug":"spring/spring security","date":"2011-06-12T04:59:20.000Z","updated":"2020-03-20T06:27:43.678Z","comments":true,"path":"2011/06/12/spring/spring security/","link":"","permalink":"https://lbvs86823.github.io/2011/06/12/spring/spring security/","excerpt":"","text":"##Spring Security 中涉及到的核心类介绍： SecurityContextHolder是用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限…这些都被保存在SecurityContextHolder中。SecurityContextHolder默认使用ThreadLocal 策略来存储认证信息。 Principal是位于java.security包中的接口: 用来标识一个已经认证的安全实体 Authentication [认证对象]是spring security包中的接口, 直接继承自Principal类, 是spring security中是最高级别的身份/认证的抽象。由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。 Java安全中使用术语主体（Subject）来表示访问请求的来源。一个主体可以是任何的实体。一个主体可以有多个不同的身份标识（Principal）。比如一个应用的用户这类主体，就可以有用户名、身份证号码和手机号码等多种身份标识。除了身份标识之外，一个主体还可以有公开或是私有的安全相关的凭证（Credential），包括密码和密钥等。http://www.infoq.com/cn/articles/cf-java-security/ getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。getCredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。getPrincipal()，最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类，也是框架中的常用接口之一。 AuthenticationManager[接口]是认证相关的核心接口，也是发起认证的出发点! 只有一个方法(认证方法):Authentication authenticate(Authentication authentication) throws AuthenticationException; 因为在实际需求中，我们可能会允许用户使用用户名+密码登录，同时允许用户使用邮箱+密码，手机号码+密码登录，甚至，可能允许用户使用指纹登录.所以说AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类ProviderManager 内部会维护一个List列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名+密码（UsernamePasswordAuthenticationToken），邮箱+密码，手机号码+密码登录则对应了三个AuthenticationProvider。在默认策略下，只需要通过一个AuthenticationProvider的认证，即可被认为是登录成功。 ProviderManager是AuthenticationManager的实现类，它内部会维护一个List列表，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则ProviderManager 会抛出一个ProviderNotFoundException异常。 AuthenticationProvider 是鉴权提供者的抽象接口，该接口提供了鉴权和是否支持该类型的鉴权两个方法: DaoAuthenticationProvider 是最常用的一个实现便是DaoAuthenticationProvider。顾名思义，Dao正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。 UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已，记住这一点，可以避免走很多弯路。 UserDetails 这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。它和Authentication接口很类似，比如它们都拥有username，authorities，区分他们也是本文的重点内容之一。Authentication的getCredentials()与UserDetails中的getPassword() 需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。 Spring Security是如何完成身份认证的？1 用户名和密码被过滤器获取到，封装成Authentication,通常情况下是UsernamePasswordAuthenticationToken这个实现类。2 AuthenticationManager 身份管理器负责验证这个Authentication3 认证成功后，AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。4 SecurityContextHolder安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。 常见的一些过滤器SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。过滤器一般负责核心的处理流程，而具体的业务实现，通常交给其中聚合的其他实体类，这在Filter的设计中很常见，同时也符合职责分离模式。例如存储安全上下文和读取安全上下文的工作完全委托给了HttpSessionSecurityContextRepository去处理HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。LogoutFilter 顾名思义，处理注销的过滤器UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的APIAnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它与UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。spirng Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"security","slug":"security","permalink":"https://lbvs86823.github.io/tags/security/"},{"name":"auth2","slug":"auth2","permalink":"https://lbvs86823.github.io/tags/auth2/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"Java thread类的用法详解","slug":"javacore/thread","date":"2011-05-16T13:43:29.000Z","updated":"2020-03-20T06:27:43.627Z","comments":true,"path":"2011/05/16/javacore/thread/","link":"","permalink":"https://lbvs86823.github.io/2011/05/16/javacore/thread/","excerpt":"","text":"java 线程：在同一进程内运行的并发任务称之为线程。 在Java中，我们有2个方式创建线程： 通过直接继承thread类，然后覆盖run()方法。 构建一个实现Runnable接口的类, 然后创建一个thread类对象并传递Runnable对象作为构造参数 如果初始线程（执行main()方法的主线程）运行结束，其他的线程还是会继续执行直到执行完成。 但是如果某个线程调用System.exit()指示终结程序，那么全部的线程都会结束执行。 创建一个Thread类的对象不会创建新的执行线程。同样，调用实现Runnable接口的 run()方法也不会创建一个新的执行线程。只有调用start()方法才能创建一个新的执行线程。 Thread类的对象中保存了一些属性信息能够帮助我们来辨别每一个线程，知道它的状态，调整控制其优先级。 这些属性是： ID: 每个线程的独特标识。 Name: 线程的名称。 Priority: 线程对象的优先级。优先级别在1-10之间，1是最低级，10是最高级。不建议改变它们的优先级，但是你想的话也是可以的。 Status: 线程的状态。在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated. 一个多个线程在执行的Java程序，只有当其全部的线程执行结束时（更具体的说，是所有非守护线程结束或者某个线程调用System.exit()方法的时候），它才会结束运行。 中断线程：Thread 类还有一个boolean类型的属性来表明线程是否被中断。当你调用线程的interrupt() 方法，就代表你把这个属性设置为 true。 而isInterrupted() 方法仅返回属性值。isInterrupted()和interrupted() 方法有着很重要的区别。第一个不会改变interrupted属性值，但是第二个会设置成false。interrupted() 方法是一个静态方法，建议使用isInterrupted()方法。 在调用sleep() 方法后，当时间结束时，当JVM安排他们CPU时间，线程会继续按指令执行，另一种可能是使用一个有TimeUnit列举元素的sleep() 方法，使用线程类的 sleep() 方法让当前线程睡眠，但是它接收的参数单位是表示并转换成毫秒的。 Java 并发 API 有另一种方法能让线程对象离开 CPU。它是 yield() 方法, 它向JVM表示线程对象可以让CPU执行其他任务。JVM 不保证它会遵守请求。通常，它只是用来试调的。 我们使用Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。 Java有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序。JAVA中最典型的这种类型代表就是垃圾回收器。只能在start() 方法之前可以调用 setDaemon() 方法。一旦线程运行了，就不能修改守护状态。可以使用 isDaemon() 方法来检查线程是否是守护线程（方法返回 true) 或者是使用者线程 (方法返回 false)。 The Thread 类有其他相关方法可以处理未捕获的异常。静态方法 setDefaultUncaughtExceptionHandler() 为应用里的所有线程对象建立异常 handler 。 当一个未捕捉的异常在线程里被抛出，JVM会寻找此异常的3种可能潜在的处理者（handler）。 首先, 它寻找这个未捕捉的线程对象的异常handle，如果这个handle 不存在，那么JVM会在线程对象的ThreadGroup里寻找非捕捉异常的handler，如果此方法不存在，那么 JVM 会寻找默认非捕捉异常handle。如果没有一个handler存在, 那么 JVM会把异常的 stack trace 写入操控台并结束任务。 各个线程的属性不会被共享。 Java 并发 API提供了一个很清楚的机制叫本地线程变量。Java 并发 API 包括 InheritableThreadLocal 类提供线程创建线程的值的遗传性 。如果线程A有一个本地线程变量，然后它创建了另一个线程B，那么线程B将有与A相同的本地线程变量值。 你可以覆盖 childValue() 方法来初始子线程的本地线程变量的值。 它接收父线程的本地线程变量作为参数。 Java并发 API里有个有趣的方法是把线程分组。这个方法允许我们按线程组作为一个单位来处理。Java 提供 ThreadGroup 类来组织线程。 ThreadGroup 对象可以由 Thread 对象组成和由另外的 ThreadGroup 对象组成,生成线程树结构。 线程对象抛出异常的处理机制:会发现线程对象是如何抛出异常和其他被中断的。当一个非捕捉异常在线程内抛出，JVM会为这个异常寻找3种可能handlers。首先, 它寻找这个未捕捉的线程对象的异常handle，如果这个handle 不存在，那么JVM会在线程对象的ThreadGroup里寻找非捕捉异常的handler，如果此方法不存在，那么 JVM 会寻找默认非捕捉异常handle。如果没有 handlers存在, 那么 JVM会把异常的 stack trace 写入控制台并结束任务。 临界区:临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。 Java提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界 区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界 区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。 Java语言提供的两种基本的同步机制: 关键字synchronized Lock接口及其实现 数据缓冲区:在并发编程中的一个经典问题是生产者与消费者问题，我们有一个数据缓冲区，一个或多个数据的生产者在缓冲区存储数据，而一个或多个数据的消费者，把数据从缓冲区取出。 由于缓冲区是一个共享的数据结构，我们必须采用同步机制，比如synchronized关键字来控制对它的访问。但是我们有更多的限制因素，如果缓冲区是满的，生产者不能存储数据，如果缓冲区是空的，消费者不能取出数据。 对于这些类型的情况，Java在Object对象中提供wait()，notify()，和notifyAll() 方法的实现。一个线程可以在synchronized代码块中调用wait()方法。如果在synchronized代码块外部调用wait()方法，JVM会抛出IllegalMonitorStateException异常。当线程调用wait()方法，JVM让这个线程睡眠，并且释放控制 synchronized代码块的对象，这样，虽然它正在执行但允许其他线程执行由该对象保护的其他synchronized代码块。为了唤醒线程，你必 须在由相同对象保护的synchronized代码块中调用notify()或notifyAll()方法。 读写锁:锁所提供的最重要的改进之一就是ReadWriteLock接口和唯一 一个实现它的ReentrantReadWriteLock类。这个类提供两把锁，一把用于读操作和一把用于写操作。同时可以有多个线程执行读操作，但只有一个线程可以执行写操作。当一个线程正在执行一个写操作，不可能有任何线程执行读操作。 Condition接口:Condition接口提供一种机制，阻塞一个线程和唤醒一个被阻塞的线程。所 有Condition对象都与锁有关，并且使用声明在Lock接口中的newCondition()方法来创建。使用condition做任何操作之前， 你必须获取与这个condition相关的锁的控制。所以，condition的操作一定是在以调用Lock对象的lock()方法为开头，以调用相同 Lock对象的unlock()方法为结尾的代码块中。 Condition接口提供不同版本的await()方法，如下： await(long time, TimeUnit unit):这个线程将会一直睡眠直到： 1.它被中断 2.其他线程在这个condition上调用singal()或signalAll()方法 3.指定的时间已经过了 4.TimeUnit类是一个枚举类型如下的常量：DAYS,HOURS, MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS,SECONDS awaitUninterruptibly():这个线程将不会被中断，一直睡眠直到其他线程调用signal()或signalAll()方法 awaitUntil(Date date):这个线程将会一直睡眠直到： 1.它被中断 2.其他线程在这个condition上调用singal()或signalAll()方法 3.指定的日期已经到了 你可以在一个读/写锁中的ReadLock和WriteLock上使用conditions。 Java并发API提供一个类，可以用来实现拥有锁和信号量特征的同步机制。它就是AbstractQueuedSynchronizer，正如其名，它是一个抽象类。它提供控制临界区的访问和管理正在阻塞等待访问临界区的线程队列的操作。这些操作是基于以下两个抽象方法： tryAcquire()：尝试访问临界区时，调用这个方法。如果线程调用这个方法可以访问临界区，那么这个方法返回true，否则，返回false。 tryRelease()：尝试翻译临界区的访问，调用这个方法。如果线程调用这个方法可以释放临界区的访问，那么这个方法返回true，否则，返回false. 基本上，当多个并发任务共享一个资源时就称为同步，例如：一个对象或者一个对象的属性。访问这个资源的代码块称为：临界区。","categories":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lbvs86823.github.io/tags/Java/"},{"name":"thread","slug":"thread","permalink":"https://lbvs86823.github.io/tags/thread/"}],"keywords":[{"name":"javacore","slug":"javacore","permalink":"https://lbvs86823.github.io/categories/javacore/"}]},{"title":"spring session 相关代码详解","slug":"spring/spring session","date":"2011-04-16T12:41:20.000Z","updated":"2020-03-20T06:27:43.678Z","comments":true,"path":"2011/04/16/spring/spring session/","link":"","permalink":"https://lbvs86823.github.io/2011/04/16/spring/spring session/","excerpt":"","text":"Could JWT(json web token) csrf又称跨域请求伪造，攻击方通过伪造用户请求访问受信任站点。 跨域资源共享CORS（跨域资源共享，Cross-Origin Resource Sharing） HttpSessionCsrfTokenRepository ———————————————————————————————- DEFAULT_CSRF_PARAMETER_NAME = &quot;_csrf&quot;; DEFAULT_CSRF_HEADER_NAME = &quot;X-CSRF-TOKEN&quot;; DEFAULT_CSRF_TOKEN_ATTR_NAME = &quot;org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.CSRF_TOKEN&quot;; parameterName = &quot;_csrf&quot;; headerName = &quot;X-CSRF-TOKEN&quot;; JdbcTokenStore ————————————————————————————————————– private static final String DEFAULT_ACCESS_TOKEN_INSERT_STATEMENT = &quot;insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?)&quot;; private static final String DEFAULT_ACCESS_TOKEN_SELECT_STATEMENT = &quot;select token_id, token from oauth_access_token where token_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKEN_AUTHENTICATION_SELECT_STATEMENT = &quot;select token_id, authentication from oauth_access_token where token_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKEN_FROM_AUTHENTICATION_SELECT_STATEMENT = &quot;select token_id, token from oauth_access_token where authentication_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKENS_FROM_USERNAME_AND_CLIENT_SELECT_STATEMENT = &quot;select token_id, token from oauth_access_token where user_name = ? and client_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKENS_FROM_USERNAME_SELECT_STATEMENT = &quot;select token_id, token from oauth_access_token where user_name = ?&quot;; private static final String DEFAULT_ACCESS_TOKENS_FROM_CLIENTID_SELECT_STATEMENT = &quot;select token_id, token from oauth_access_token where client_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKEN_DELETE_STATEMENT = &quot;delete from oauth_access_token where token_id = ?&quot;; private static final String DEFAULT_ACCESS_TOKEN_DELETE_FROM_REFRESH_TOKEN_STATEMENT = &quot;delete from oauth_access_token where refresh_token = ?&quot;; private static final String DEFAULT_REFRESH_TOKEN_INSERT_STATEMENT = &quot;insert into oauth_refresh_token (token_id, token, authentication) values (?, ?, ?)&quot;; private static final String DEFAULT_REFRESH_TOKEN_SELECT_STATEMENT = &quot;select token_id, token from oauth_refresh_token where token_id = ?&quot;; private static final String DEFAULT_REFRESH_TOKEN_AUTHENTICATION_SELECT_STATEMENT = &quot;select token_id, authentication from oauth_refresh_token where token_id = ?&quot;; private static final String DEFAULT_REFRESH_TOKEN_DELETE_STATEMENT = &quot;delete from oauth_refresh_token where token_id = ?&quot;; private String insertAccessTokenSql = &quot;insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?)&quot;; private String selectAccessTokenSql = &quot;select token_id, token from oauth_access_token where token_id = ?&quot;; private String selectAccessTokenAuthenticationSql = &quot;select token_id, authentication from oauth_access_token where token_id = ?&quot;; private String selectAccessTokenFromAuthenticationSql = &quot;select token_id, token from oauth_access_token where authentication_id = ?&quot;; private String selectAccessTokensFromUserNameAndClientIdSql = &quot;select token_id, token from oauth_access_token where user_name = ? and client_id = ?&quot;; private String selectAccessTokensFromUserNameSql = &quot;select token_id, token from oauth_access_token where user_name = ?&quot;; private String selectAccessTokensFromClientIdSql = &quot;select token_id, token from oauth_access_token where client_id = ?&quot;; private String deleteAccessTokenSql = &quot;delete from oauth_access_token where token_id = ?&quot;; private String insertRefreshTokenSql = &quot;insert into oauth_refresh_token (token_id, token, authentication) values (?, ?, ?)&quot;; private String selectRefreshTokenSql = &quot;select token_id, token from oauth_refresh_token where token_id = ?&quot;; private String selectRefreshTokenAuthenticationSql = &quot;select token_id, authentication from oauth_refresh_token where token_id = ?&quot;; private String deleteRefreshTokenSql = &quot;delete from oauth_refresh_token where token_id = ?&quot;; private String deleteAccessTokenFromRefreshTokenSql = &quot;delete from oauth_access_token where refresh_token = ?&quot;; JdbcTokenRepositoryImpl —————————————————————————————————– public static final String CREATE_TABLE_SQL = &quot;create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)&quot;; public static final String DEF_TOKEN_BY_SERIES_SQL = &quot;select username,series,token,last_used from persistent_logins where series = ?&quot;; public static final String DEF_INSERT_TOKEN_SQL = &quot;insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)&quot;; public static final String DEF_UPDATE_TOKEN_SQL = &quot;update persistent_logins set token = ?, last_used = ? where series = ?&quot;; public static final String DEF_REMOVE_USER_TOKENS_SQL = &quot;delete from persistent_logins where username = ?&quot;; private String tokensBySeriesSql = &quot;select username,series,token,last_used from persistent_logins where series = ?&quot;; private String insertTokenSql = &quot;insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)&quot;; private String updateTokenSql = &quot;update persistent_logins set token = ?, last_used = ? where series = ?&quot;; private String removeUserTokensSql = &quot;delete from persistent_logins where username = ?&quot;; FotorRememberMeServices——————————————————————————————————– refreshTokenValiditySeconds = 2592000; //spring默认一个月 public static final int TWO_WEEKS_S = 1209600; private int tokenValiditySeconds = TWO_WEEKS_S; DEFAULT_TOKEN_LENGTH = 16; cookieName =&quot;remember-me&quot;; parameter= &quot;rememberMe&quot;; tokensBySeriesSql = &quot;select username,series,token,last_used from persistent_logins where series = ?&quot;; updateTokenSql = &quot;update persistent_logins set token = ?, last_used = ? where series = ?&quot;; selectAccessTokenAuthenticationSql = &quot;select token_id, authentication from oauth_access_token where token_id = ?&quot;; redis-cli keys &apos;spring:session:sessions:*&apos; Spring Session定义了如下核心接口：Session、ExpiringSession以及SessionRepository，针对不同的数据存储，它们需要分别实现。 org.springframework.session.Session接口定义了session的基本功能，如设置和移除属性。这个接口并不关心底层技术，因此能够比servlet HttpSession适用于更为广泛的场景中。org.springframework.session.ExpiringSession扩展了Session接口，它提供了判断session是否过期的属性。RedisSession是这个接口的一个样例实现。org.springframework.session.SessionRepository定义了创建、保存、删除以及检索session的方法。将Session实例真正保存到数据存储的逻辑是在这个接口的实现中编码完成的。例如，RedisOperationsSessionRepository就是这个接口的一个实现，它会在Redis中创建、存储和删除session。 1) “spring:session:sessions:expires:c1c1dc64-138d-41b6-ba95-bcfe3a7e96df” 【这个是个字符串】2) “spring:session:expirations:1502267400000” 【这个是一个set集合】3) “spring:session:sessions:c1c1dc64-138d-41b6-ba95-bcfe3a7e96df” 【这个是一个hash键值对映射 存储了：maxInactiveInterval creationTime lastAccessedTime】 hgetall spring:session:sessions:c1c1dc64-138d-41b6-ba95-bcfe3a7e96df存储了：maxInactiveInterval creationTime lastAccessedTime smembers spring:session:expirations:15022674000001) “\\xac\\xed\\x00\\x05t\\x00,expires:c1c1dc64-138d-41b6-ba95-bcfe3a7e96df” get spring:session:sessions:expires:c1c1dc64-138d-41b6-ba95-bcfe3a7e96df","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"},{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"session","slug":"session","permalink":"https://lbvs86823.github.io/tags/session/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"DTD文档类型定义简介","slug":"others/dtd","date":"2011-01-14T09:11:16.000Z","updated":"2020-03-20T06:27:43.660Z","comments":true,"path":"2011/01/14/others/dtd/","link":"","permalink":"https://lbvs86823.github.io/2011/01/14/others/dtd/","excerpt":"","text":"1.DTD文档类型定义简介DTD全称为Decument Type Definition，它是文档类型定义，其中规定XML文档中的元素、属性、标记、文档中的实体及其相互关系。DTD为XML文档结构制定了一套规则。 DTD采用了非XML的语法描述语义约束，可以提供如下功能： DTD可以为应用程序提供一种统一的XML文档格式 DTD有助于数据交流与共享 DTD可以使用脱离实际数据就能知道文档的逻辑结构 DTD可以验证数据的有效性 通过使用DTD可以让每个XML文件带有一个有关其自身的格式描述 不同的公司、组织可一致的使用某个标准的DTD来交换数据 应用程序也可以使用某个标准的DTD验证所介绍的XML文档是否符合语义约束 开发者可以使用DTD来验证所创建的XML文档 DTD约束包括以下几个方面: 定义XML的根元素、内容和结构 定义XML文档中可以接受哪些元素 定义XML文档里每个元素接受的合法内容,包括是否可以为空、是否可以是文本、可以接受哪些子元素、子元素出现的顺序及子元素出现的次数等 定义XML文档中每个元素能接受哪些属性 定义XML文档中每个属性的类型、能接受哪些值以及元素对属性的约束等 定义属性的固定值和默认值 定义XML文档以及DTD文档中可以使用的实体 注：一个合法的文档必须符合DTD指定的约束条件，而且它的基本元素必须是在文档类型声明中指定的。只有符合DTD规则的XML文档才是有效地文档。 2.DTD的文档结构DTD的文档结构如下： 第一行是DTD声明部分该声明与xml文档的生命语法格式相同 0到多个注释部分,DTD注释与xml文档的注释完全相同(&lt;!-- 注释内容 --&gt;) 0到多个&lt;!ENTITY…..&gt;定义，每个它就是一个实体 0到多个&lt;!ELEMENT…..&gt;定义，每个它就是一个xml元素 0到多个&lt;!ATTLIST…..&gt;定义，每个它就是一个xml元素的属性 0到多个&lt;!NOTATION…..&gt;定义，每个它定义一个符号 注：彼此之间完全独立，无须相互嵌套。 DTD的四种标记声明: ELEMENT xml元素类型声明 ATTLIST 特定元素类型可设置的属性&amp;属性的允许值声明 ENTITY 可重用的内容声明 NOTATION 不要解析的外部内容的格式声明。 一、 定义元素元素类型的定义的全称是:Element Type Defintion,简称ETD,它不但会定义每个文件中可能存在的元素给定名称,而且会定义元素的具体类型。 元素类型描述主要有5种： 任意类型(可以是以下四种类型) 语法格式: &lt;!ELEMENT 元素名 ANY&gt; 字符串值 语法格式：&lt;!ELEMENT 元素名 (#PCDATA)&gt; 空元素() 语法格式：&lt;!ELEMENT 元素名 EMPTY&gt; 包含子元素 语法格式：（name1 | name2) 或者 (name3，name4，name5） 混合类型 语法格式：#PCDATA 以它开头的是混合类型 定义任意类型: &lt;!--任意类型 无效的XML文档 但是 格式良好的XML文档--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book ANY&gt; ]&gt; 定义字符串内容的元素: 格式：&lt;!ELEMENT 元素名 (#PCDATA)&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (book_name,price,author)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; 定义空元素： &lt;!--空元素 有效的XML文档--&gt; 格式：&lt;!ELEMENT 元素名 EMPTY&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book EMPTY&gt; ]&gt; 定义子元素： 1. 有序的子元素(,) 逗号(,)用于分隔有序的子元素 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (book_name,price,author)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; ]&gt; &lt;book&gt; &lt;computer&gt; &lt;book_name&gt;JavaWeb开发&lt;/book_name&gt; &lt;price&gt;30.0&lt;/price&gt; &lt;author&gt;redarmychen&lt;/author&gt; &lt;/computer&gt; &lt;computer&gt; &lt;book_name&gt;CSS应用程序的开发&lt;/book_name&gt; &lt;price&gt;1000&lt;/price&gt; &lt;author&gt;redarmy_Chen&lt;/author&gt; &lt;/computer&gt; &lt;/book&gt; 解析：book_name、price、author三者之间的循序不能颠倒。 2. 互斥的子元素，用(|)符号分隔互斥的子元素互斥的子元素表明一系列的子元素中只能出现其中之一。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (book_name|price|author)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; ]&gt; &lt;book&gt; &lt;computer&gt; &lt;book_name&gt;JavaWeb开发&lt;/book_name&gt; &lt;/computer&gt; &lt;computer&gt; &lt;price&gt;30&lt;/price&gt; &lt;/computer&gt; &lt;computer&gt; &lt;author&gt;redarmy_Chen&lt;/author&gt; &lt;/computer&gt; &lt;/book&gt; 解析：book_name、price、author只能出现一个 3. 子元素出现的频率 +: 一次或多次 (书+) ?: 0次或一次 (书?) *: 0次或多次 (书*) 注意：混合类型的频率只能安如下方式加： &lt;!ELEMENT computer (#PCDATA|book_name|price|author)*&gt; //#PCDATA 以它开头的是混合类型,频率只能在最后加 4. 组合子元素 &lt;!ELEMENT computer (book_name|price|author)&gt; 5. 无序的子元素 定义混合内容： &lt;!--定义混合内容--&gt; 格式：&lt;!ELEMENT 父元素名(#PCDATA|子元素1|子元素2|子元素3|........)*&gt; 注： 1. #PCDATA必须放在最前面 2. #PCDATA只能用|与各个子元素分隔 3. 不要试图在各个子元素之后添加?、*、+等表示频率的修饰符 综合案例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (#PCDATA|book_name|price|author)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; ]&gt; &lt;book&gt; &lt;computer&gt; &lt;book_name&gt;JavaWeb开发&lt;/book_name&gt; &lt;price&gt;30.0&lt;/price&gt; &lt;author&gt;redarmy_chen&lt;/author&gt; &lt;/computer&gt; &lt;computer&gt; &lt;book_name&gt;CSS应用程序的开发&lt;/book_name&gt; &lt;price&gt;1000&lt;/price&gt; &lt;author&gt;redarmy_Chen&lt;/author&gt; &lt;/computer&gt; &lt;/book&gt; 二、 定义属性语法格式： &lt;!ATTLIST属性所属元素 属性名 属性类型[元素对属性的约束][默认值]&gt; 元素对属性的约束,默认值是可选的对于它们的使用有如下的情况： 在没有指定”元素对属性的约束”时,必须为该属性增加默认值。 在元素对属性的约束是:#REQUIRED时，不能为该属性指定默认值。 在元素对属性的约束是:#IMPLIED时，不能为该属性指定默认值 在元素对属性的约束是:#FIXED时，必须为该属性指定默认值 属性约束 #REQUIRED：必须的属性 #IMPLIED：可有可无 #FIXED：固定值 属性类型 类型 说明 CDATA 字符串数据 character data enumerated 列出该属性的取值范围，一次只能有一个属性值能够赋予属性 nmtoken 表示属性值只能由字母、数字、下划线、. 、：、-这些符号组成 nmtokens 表示属性值能够由多个nmtoken组成，每个nmtoken之间用空格隔开 (e1|e2|e3) 该属性是一系列枚举值之一 ID Id必须是唯一的 IDREF 引用自己已经定义的id IDREFS 空格区分多个id ENTITY 是一个外部的实体 ENTITIES 多个外部实体,多个外部实体之间用空格分隔 notation 属性值是在dtd中声明过的notation（声明用什么应用软件解读某些二进制文件，如图片） Xml: 预定义的xml值 比如：在XML的规范中，还规定了两个内定的属性，即：xml:space和xml:lang ，内定的属性名称以xml:开头，而你自己定义的属性名不能以xml:开头，否则在解析时会发生错误。 案例三&lt;水果 品名=”苹果” 颜色=”绿色”&gt;关于水果的元素&lt;/水果&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE 购物车[ &lt;!ELEMENT 购物车 (肉*,水果*,玩具)&gt; &lt;!ELEMENT 肉 EMPTY&gt; &lt;!ELEMENT 水果 EMPTY&gt; &lt;!ELEMENT 玩具 EMPTY&gt; &lt;!ATTLIST 肉 类型 (鸡肉|牛肉|狗肉) #REQUIRED&gt; &lt;!ATTLIST 水果 类型 (苹果|梨|香蕉) #IMPLIED&gt; &lt;!ATTLIST 玩具 类型 CDATA #FIXED &quot;魔方&quot;&gt; ]&gt; &lt;购物车&gt; &lt;肉 类型=&quot;狗肉&quot;/&gt; &lt;水果/&gt; &lt;玩具 类型=&quot;地雷&quot;/&gt; &lt;/购物车&gt; 案例解析：魔方为固定的不可改变的不写也行，水果中的元素可有可无，而肉中的元素必须有其中之一。 三、 定义实体所谓实体就是用一个字符串代替另一个字符串。其作用如下： 提高代码复用、方便修改 使用某些特殊的符号 减少字符输入量 预定义实体: &lt; &amp;it; &gt; &amp;gt; &amp; &amp;amp; &apos;(单引号) &amp;apos; &quot;(双引号) &amp;quot; 引用实体: 内部形式: &lt;!ENTITY 实体名 “实体值”&gt; 外部形式: &lt;!ENTITY 实体名 SYSTEM &quot;外部文本的URL地址&quot;&gt; 注：使用 引用实体 的语法格式为: &amp;实体名; (引用实体必须以“&amp;“符号开始，以“;”结束)当实体引用在解析过程中被替换为置换文本时，其结果必须是正规的xml格式属性值中不能引用可解析的外部实体，实体不能包含直接或间接的对自身的引用 参数实体: 仅仅在DTD中使用的解析实体称为参数实体。 这样能够简便的引用或修改DTD中常用的结构。但是扩展结构时，仍然需要编辑DTD。 参数实体声明:ENTITY关键字、百分号、名称和替换字。 内部形式: &lt;!ENTITY % 实体名 “实体值”&gt; 外部形式: &lt;!ENTITY % 实体名 SYSTEM &quot;外部文本的URL地址&quot;&gt; 在DTD中，所有参数实体必须在引用之前进行声明。所以DTD内部子集不能引用在外部子集中声明的参数实体，因为解析器首先读取内部子集。参数实体遵循文档规则，用置换文本取代实体引用后，要复合文档规则。参数实体的置换文本也可以位于外部文本中。 &lt;!ENTITY % peopleParameters &quot;age CDATE #IMPLIED weight CDATA #IMPLIED height CDATA #REQUIRED&quot;&gt; &lt;!ENTITY % myParam SYSTEM &quot;http://www.worx.com/Wroxdecls.ent&quot;&gt; 使用 参数实体 的语法格式为: %实体名; (引用实体必须以“%“符号开始，以“;”结束) &lt;!ATTLIST InsuredPerson %peopleParameters; carrier CDATA #REQUIRED&gt; 以上代码等价于 &lt;!ATTLIST InsuredPerson age CDATA #IMPLIED weight CDATA #IMPLIED height CDATA #REQUIRED carrier CDATA #REQUIRED&gt; 案例四包含DTD的outherdtd.dtd文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ELEMENT books (book*)&gt; &lt;!ELEMENT book (book_name,author,price,state)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT state (#PCDATA)&gt; &lt;!ENTITY % boolean &quot;yes|no|true|false&quot;&gt; &lt;!ATTLIST state islast (%boolean;) #IMPLIED&gt; &lt;!ENTITY javaname &quot;JAVA编程精炼的最好的世界最牛书&quot;&gt; &lt;!ENTITY outer SYSTEM &quot;test.txt&quot;&gt; 拥有外部DTD的XML文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE books SYSTEM &quot;outerdtd.dtd&quot;&gt; &lt;books&gt; &lt;book&gt; &lt;book_name&gt;&amp;javaname;&lt;/book_name&gt; &lt;author&gt;乔峰&lt;/author&gt; &lt;price&gt;&amp;outer;&lt;/price&gt; &lt;state&gt;暂无销售&lt;/state&gt; &lt;/book&gt; &lt;/books&gt; 案例解析：引用了外部dtd文件 &javaname; 相当于dtd文件中javaname 的值即”JAVA编程精炼的最好的世界最牛书 参数实体：语法格式： &lt;!ENTITY %实体名 “实体值”&gt; 另一种格式： &lt;!ENTITY % 实体值名称 SYSYTEM “外部XML文档的URL”&gt; 案例五 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE books[ &lt;!ELEMENT books (book*)&gt; &lt;!ELEMENT book (book_name,author,price,state)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT state (#PCDATA)&gt; &lt;!ENTITY %boolean &quot;yes|no|true|false&quot;&gt; &lt;!ATTLIST state islast (%boolean;) #IMPLIED&gt; &lt;!ENTITY javaname &quot;JAVA编程精炼的最好的世界最牛书&quot;&gt; ]&gt; &lt;books&gt; &lt;book&gt; &lt;book_name&gt;JAVA编程精炼的最好的世界最牛书&lt;/book_name&gt; &lt;author&gt;redarmy_chen&lt;/author&gt; &lt;price&gt;1&lt;/price&gt; &lt;state&gt;暂无销售&lt;/state&gt; &lt;/book&gt; &lt;book&gt; &lt;book_name&gt;&amp;javaname;&lt;/book_name&gt; &lt;author&gt;m_j&lt;/author&gt; &lt;price&gt;1000&lt;/price&gt; &lt;state islast=&quot;yes&quot;&gt;10000&lt;/state&gt; &lt;/book&gt; &lt;book&gt; &lt;book_name&gt;&lt;/book_name&gt; &lt;author&gt;&lt;/author&gt; &lt;price&gt;&lt;/price&gt; &lt;state&gt;&lt;/state&gt; &lt;/book&gt; &lt;/books&gt; 案例解析：&lt;!ENTITY % boolean “yes|no|true|false”&gt; 表示实体值为yes、no、true、false&lt;!ATTLIST state islast (%boolean;) #IMPLIED&gt; 含义是引用实体表示书是不是最后一本，#IMPLIED表示可有可无。 3.DTD的使用(引入方式) 内部引用方式 外部引用方式 其中外部引用方式可划分为两种即SYSYTEM引用方式、PUBLIC引用方式。 内部DTD方式：DTD语义约束与xml文档的内容放在同一个XML文档中。内部DTD紧跟在XML声明和处理指令之后，以”&lt;!DOCTYPE “开始,以”]&gt;”结束。其语法格式如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE 根元素名[ 元素描述[DTD的内容] ]&gt; XML文档主体部分 案例一: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; &lt;!DOCTYPE book[ &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (book_name,price,author)&gt; &lt;!ELEMENT book_name(#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; ]&gt; &lt;book&gt; &lt;computer&gt; &lt;author&gt;张三丰&lt;/author&gt; &lt;book_name&gt;JavaWeb开发&lt;/book_name&gt; &lt;price&gt;30.0&lt;/price&gt; &lt;/computer&gt; &lt;computer&gt; &lt;book_name&gt;CSS应用程序的开发&lt;/book_name&gt; &lt;price&gt;1000&lt;/price&gt; &lt;author&gt;张无忌&lt;/author&gt; &lt;/computer&gt; &lt;/book&gt; 案例分析：第一行 XML声明语句中的standalone属性取”yes”值表示所有必须的实体声明都包含的文档中,说明该文档是独立文档。第二行 声明DTD约束第三行 定义book元素有多个相同的元素即 computer元素第四行 定义computer元素中有三个元素：book_name、price、author第五行 定义book_name元素为 #PCDATA类型第六行 定义price元素为 #PCDATA 类型第七行 定义author元素为 #PCDATA 类型第八行 为声明的结束标志第九行 后面是描述book信息的XML文档 外部DTD方式：1、SYSTEM引用方式语法格式表示如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE 根元素名 SYSTEM &quot;外部的DTD的URL地址&quot;&gt; XML文档主体部分 注：SYSYTEM, DOCTYPE 是关键字必须要大写, URL 路径可以是相对路径也可以是绝对路径,该语句必须出现在XML文档的序言区。 案例二：包含DTD的book.dtd文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ELEMENT book (computer)*&gt; &lt;!ELEMENT computer (book_name,price,author)&gt; &lt;!ELEMENT book_name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ELEMENT author (#PCDATA)&gt; 拥有外部DTD的XML文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE book SYSTEM &quot;book.dtd&quot;&gt; &lt;book&gt; &lt;computer&gt; &lt;book_name&gt;JavaWeb开发&lt;/book_name&gt; &lt;price&gt;30.0&lt;/price&gt; &lt;author&gt;redarmychen&lt;/author&gt; &lt;/computer&gt; &lt;computer&gt; &lt;book_name&gt;CSS应用程序的开发&lt;/book_name&gt; &lt;price&gt;1000&lt;/price&gt; &lt;author&gt;redarmy_Chen&lt;/author&gt; &lt;/computer&gt; &lt;/book&gt; 案例分析：book.dtd 文件与案例一大似相同在此不作讲解。XML中standalone的值设置为”no”, 这是因为XML文档不是独立的需要外部的实体声明。 2、PUBLIC引用方式语法格式表示如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE 根元素名 PUBLIC &quot;DTD的标识名&quot; &quot;公用的DTD的URL地址&quot;&gt; XML文档主体部分 注：PUBLIC为关键字 必须大写并表明该外部DTD具有 名称”DTD的标识名”为XML文档所引用的外部公共DTD的名称“公用的DTD的URL地址”为外部DTD文件的路径，含义与SYSTEM引用方式中的”DTD_URL”一致该语句必须出现在XML文档的序言区。 4.Schema简介DTD的语法相当复杂，并且它不符合XML文件的标准，自成一个体系。上面的介绍也仅仅是作了一个简介，目的是帮助大家能读懂DTD文件以及在必要时创建简单的DTD文件，因为现在很多的XML应用是建立在DTD之上的。 另外，一个代替DTD的就是W3C定义的Schema，Schema相对于DTD的明显好处是XML Schema文档本身也是XML文档，而不是像DTD 一样使用自成一体的语法。这就方便了用户和开发者，因为可以使用相同的工具来处理XML Schema和其他XML信息，而不必专门为Schema使用特殊工具。 Schema简单易懂，懂得XML语法、规则的人都可以立刻理解它。Schema 的概念提出已久，但W3C的标准最近才出来，相应的应用支持尚 未完善，但采用Schema已成为XML发展的一个趋势。 案例： DTD定义区: &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; ?&gt; &lt;!DOCTYPE 参考资料 [ &lt;!ELEMENT 参考资料 (书籍)&gt; &lt;!ELEMENT 书籍 (名称,作者,价格)&gt; &lt;!ELEMENT 名称 (#PCDATA)&gt; &lt;!ELEMENT 作者 (#PCDATA)&gt; &lt;!ELEMENT 价格 (#PCDATA)&gt; &lt;!ATTLIST 价格 货币单位 CDATA #REQUIRED&gt; ]&gt; xml文档数据区： &lt;参考资料&gt; &lt;书籍&gt; &lt;名称&gt;XML入门精解&lt;/名称&gt; &lt;作者&gt;张三&lt;/作者&gt; &lt;价格 货币单位=&quot;人民币&quot;&gt;20.00&lt;/价格&gt; &lt;/书籍&gt; &lt;书籍&gt; &lt;名称&gt;XML语法&lt;/名称&gt; &lt;!-- 即将出版 --&gt; &lt;作者&gt;李四&lt;/作者&gt; &lt;价格 货币单位=&quot;人民币&quot;&gt;18.00&lt;/价格&gt; &lt;/书籍&gt; &lt;/参考资料&gt;","categories":[{"name":"others","slug":"others","permalink":"https://lbvs86823.github.io/categories/others/"}],"tags":[{"name":"dtd","slug":"dtd","permalink":"https://lbvs86823.github.io/tags/dtd/"},{"name":"xml","slug":"xml","permalink":"https://lbvs86823.github.io/tags/xml/"}],"keywords":[{"name":"others","slug":"others","permalink":"https://lbvs86823.github.io/categories/others/"}]},{"title":"cron 表达式","slug":"spring/cron_trigger","date":"2011-01-10T13:49:39.000Z","updated":"2020-03-20T06:27:43.672Z","comments":true,"path":"2011/01/10/spring/cron_trigger/","link":"","permalink":"https://lbvs86823.github.io/2011/01/10/spring/cron_trigger/","excerpt":"","text":"cron 表达式详解 序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 or JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 empty 或 1970-2099 , - * / 通配符说明:表示所有值. 例如:在分的字段上设置 ““,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?- 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。, 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发/用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五” W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“).# 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同； 常用示例: 0 0 12 ? 每天12点触发 0 15 10 ? 每天10点15分触发 0 15 10 ? 每天10点15分触发 0 15 10 ? * 每天10点15分触发 0 15 10 ? 2005 2005年每天10点15分触发 0 14 * ? 每天下午的 2点到2点59分每分触发 0 0/5 14 ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) 0 0/5 14,18 ? 每天下午的 2点到2点59分、18点到18点59分(整点开始，每隔5分触发) 0 0-5 14 ? 每天下午的 2点到2点05分每分触发 0 10,44 14 ? 3 WED 3月分每周三下午的 2点10分和2点44分触发 0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发 0 15 10 15 * ? 每月15号上午10点15分触发 0 15 10 L * ? 每月最后一天的10点15分触发 0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发 0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发 0 15 10 ? * 6#3 每月的第三周的星期五开始触发 0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次 0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://lbvs86823.github.io/tags/quartz/"},{"name":"cronTrigger","slug":"cronTrigger","permalink":"https://lbvs86823.github.io/tags/cronTrigger/"},{"name":"schedule","slug":"schedule","permalink":"https://lbvs86823.github.io/tags/schedule/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"quartz整合spring用法详解","slug":"spring/quartz","date":"2011-01-09T11:49:39.000Z","updated":"2020-03-20T06:27:43.675Z","comments":true,"path":"2011/01/09/spring/quartz/","link":"","permalink":"https://lbvs86823.github.io/2011/01/09/spring/quartz/","excerpt":"","text":"##一，cron表达式格式介绍Cron 表达式包括以下 7 个字段： 秒分小时月内日期月周内日期年【可选字段】 Cron 触发器利用一系列特殊字符(组合形成定时任务)： /表示增量，比如：5/10 如果放在秒字段，表示从 第 5 秒开始，每 15 秒一次。 ?表示这个字段不包含具体值,并且只有在月内日期和周内日期字段中可用。 比如： ?放在周内日期字段中，表示内日期值无关紧要。 L它是单词(last)的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L”表示安排在当月的最后一个星期日执行。 W表示把执行任务安排在最靠近指定值的工作日，比如：1W 放在月内日期字段中，表示把执行安排在当月的第一个工作日内。 #给定月份指定具体的工作日实例，比如：MON#2 放在周内日期字段中，表示把任务安排在当月的第二个星期一。 *通配字符，表示该字段可以接受任何可能的值。 每个字段都只能允许指定的特殊字符 秒 0-59 , - /分 0-59 , - /小时 0-23 , - /日期 1-31 , - ? / L W C月份 1-12 或者 JAN-DEC , - /星期 1-7 或者 SUN-SAT , - ? / L C #年（可选） 留空, 1970-2099 , - * / 常见的一些表达式的案例： “0 0 12 ?” 每天中午12点触发“0 15 10 ? “ 每天上午10:15触发“0 15 10 ?” 每天上午10:15触发“0 15 10 ? “ 每天上午10:15触发“0 15 10 ? 2005” 2005年的每天上午10:15触发“0 14 ?” 在每天下午2点到下午2:59期间的每1分钟触发“0 0/5 14 ?” 在每天下午2点到下午2:55期间的每5分钟触发“0 0/5 14,18 ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发“0 0-5 14 ?” 在每天下午2点到下午2:05期间的每1分钟触发“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发“0 15 10 ? MON-FRI” 周一至周五的上午10:15触发“0 15 10 15 ?” 每月15日上午10:15触发“0 15 10 L ?” 每月最后一日的上午10:15触发“0 15 10 ? 6L” 每月的最后一个星期五上午10:15触发“0 15 10 ? 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发“0 15 10 ? 6#3” 每月的第三个星期五上午10:15触发 ##二，quartz整合Spring案例 首先编写一个任务Bean如下： public class QuartzJob { public static final Logger log = LoggerFactory.getLogger(QuartzJob.class); public void work() { log.info(&quot;我的定时任务开始工作了................&quot;); } } 下面就可以直接配置定时任务了 首先配置任务Bean： &lt;bean id=&quot;iJob&quot; class=&quot;com.lbvs.springdemo.QuartzJob&quot;/&gt; 让后配置定时任务的调度方法： &lt;bean id=&quot;jobTask&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot; p:targetObject-ref=&quot;iJob&quot; p:targetMethod=&quot;work&quot;/&gt; 接下来配置任务的调度方式： spring3.2.4 以下 + quartz1.8 以下 的配置方式： &lt;bean id=&quot;iJobTrigger1.x&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt; &lt;property name=&quot;jobDetail&quot;&gt; &lt;ref bean=&quot;jobTask&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;cronExpression&quot;&gt;0/5 * * * * ?&lt;/property&gt; &lt;/bean&gt; spring3.2.4 以上 + quartz2.x 的配置方式： &lt;bean id=&quot;iJobTrigger2.x&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot; p:jobDetail-ref=&quot;jobTask&quot; p:cronExpression=&quot;0/5 * * * * ?&quot;/&gt; 配置定时任务队列： &lt;bean id=&quot;startQuertz&quot; lazy-init=&quot;false&quot; autowire=&quot;no&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;iJobTrigger2.x&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;","categories":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/tags/spring/"},{"name":"quartz","slug":"quartz","permalink":"https://lbvs86823.github.io/tags/quartz/"},{"name":"cron","slug":"cron","permalink":"https://lbvs86823.github.io/tags/cron/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://lbvs86823.github.io/categories/spring/"}]},{"title":"Shiro 第五章 Session Management","slug":"shiro/shiro_05","date":"2010-12-20T11:31:58.000Z","updated":"2020-03-20T06:27:43.671Z","comments":true,"path":"2010/12/20/shiro/shiro_05/","link":"","permalink":"https://lbvs86823.github.io/2010/12/20/shiro/shiro_05/","excerpt":"","text":"1.Session Management 概述：Apache Shiro 提供安全框架界独一无二的东西:一个完整的企业级 Session 解决方案,从最简单的命令行及智能手机 应用到最大的集群企业 Web 应用程序。 这对许多应用有着很大的影响——直到 Shiro 出现,如果你需要 session 支持,你需要部署你的应用程序到 Web 容 器或使用 EJB 有状态会话 Bean。Shiro 的 Session 支持比这两种机制的使用和管理更为简单,而且它在适用于任何程 序,不论容器。 下面是一个 Shiro 的 Session 支持的最可取的功能列表:Features POJO/J2SE based(IoC friendly) - Shiro 的一切(包括所有 Session 和 Session Management 方面)都是基于接口和POJO 实现。这可以让你轻松地配置所有拥有任何 JavaBeans 兼容配置格式(如 JSON,YAML,Spring XML 或类 似的机制)的会话组件。你也可以轻松地扩展 Shiro 的组件或编写你自己所需的来完全自定义 session management。 Easy Custom Session Storage - 因为 Shiro 的 Session 对象是基于 POJO 的,会话数据可以很容易地存储在任意 数量的数据源。这允许你自定义你的应用程序会话数据的确切位置——例如,文件系统,联网的分布式缓存, 关系数据库,或专有的数据存储。 Container-Independent Clustering! - Shiro 的会话可以很容易地聚集通过使用任何随手可用的网络缓存产品,像 Ehcache + Terracotta,Coherence,GigaSpaces,等等。这意味着你可以为 Shiro 配置会话群集一次且仅一次, 无论你部署到什么容器中,你的会话将以相同的方式聚集。不需要容器的具体配置! Heterogeneous Client Access - 与 EJB 或 web 会话不同,Shiro 会话可以被各种客户端技术“共享”。例如,一 个桌面应用程序可以“看到”和“共享”同一个被使用的物理会话通过在 Web 应用程序中的同一用户。我们 不知道除了 Shiro 以外的其他框架能够支持这一点。 Event Listeners - 事件监听器允许你在会话生命周期监听生命周期事件。你可以侦听这些事件和对自定义应用 程序的行为作出反应——例如,更新用户记录当他们的会话过期时。 Host Address Retention - Shiro Sessions 从会话发起地方保留 IP 地址或主机名。这允许你确定用户所在,并作 出相应的反应(通常是在 IP 分配确定的企业内部网络环境)。 Inactivity/Expiration Support - 由于不活动导致会话过期如预期的那样,但它们可以延续很久通过 touch()方法 来保持它们“活着”,如果你希望的话。这在 RIA(富互联网应用)环境非常有用,用户可能会使用桌面应用程 序,但可能不会经常与服务器进行通信,但该服务器的会话不应过期。 Transparent Web Use - Shiro 的网络支持,充分地实现和支持关于 Sessions(HttpSession 接口和它的所有相关 的 API)的 Servlet2.5 规范.这意味着你可以使用在现有 Web 应用程序中使用 Shiro 会话,并且你不需要改变任 何现有的 Web 代码。 Can be used for SSO - 由于 Shiro 会话是基于 POJO 的,它们可以很容易地存储在任何数据源,而且它们可以跨 程序“共享”如果需要的话。我们称之为”poor man’s SSO”,并它可以用来提供简单的登录体验,由于共享的 会话能够保留身份验证状态。 2.Using Sessions几乎与所有其他在 Shiro 中的东西一样,你通过与当前执行的 Subject 交互来获取 Session: Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;, someValue); subject.getSession()方法是调用 currentUser.getSubject(true)的快捷方式。对于那些熟悉 HttpServletRequest API 的,Subject.getSession(boolean create)方法与 HttpServletRequest.getSession(boolean create)方法有着异曲同工之效。 如果该 Subject 已经拥有一个 Session,则 boolean 参数被忽略且 Session 被立即返回。 如果该 Subject 还没有一个 Session 且 create 参数为 true,则创建一个新的会话并返回该会话。 如果该 Subject 还没有一个 Session 且 create 参数为 false,则不会创建新的会话且返回 null。 当你获取了一个 Subject 的 Session 后,你可以用它来做许多事情,像设置或取得 attribute,设置其超时时间等。 3.Session Timeout默认地,Shiro 的 SessionManager 实现默认是 30 分钟会话超时。也就是说,如果任何 Session 创建后闲置(未被使 用,它的上次访问时间未被更新)的时间超过了 30 分钟,那么该 Session 就被认为是过期的,且不允许再被使用。你可以设置 SessionManager 默认实现的 globalSessionTimeout 属性来为所有的会话定义默认的超时时间。 4.Session ListenersShiro 支持 SessionListener 概念来允许你对发生的重要会话作出反应。你可以实现 SessionListener 接口(或扩展易用 的 SessionListenerAdapter)并与相应的会话操作作出反应。由于默认的 SessionManager sessionListeners 属性是一个集合,你可以对 SessionManager 配置一个或多个 listener 实现。 5.Session Storage每当一个会话被创建或更新时,它的数据需要持久化到一个存储位置以便它能够被稍后的应用程序访问。同样地, 当一个会话失效且不再被使用时,它需要从存储中删除以便会话数据存储空间不会被耗尽。SessionManager 实现委 托这些 Create/Read/Update/Delete(CRUD)操作为内部组件,同时,SessionDAO,反映了数据访问对象(DAO)设计模式。 SessionDAO 的权力是你能够实现该接口来与你想要的任何数据存储进行通信。这意味着你的会话数据可以驻留在内 存中,文件系统,关系数据库或 NoSQL 的数据存储,或其他任何你需要的位置。你得控制持久性行为。 6.EHCache SessionDAOEHCache 默认是没有启用的,但如果你不打算实现你自己的 SessionDAO,那么强烈地建议你为 Shiro 的 SessionManagerment 启用 EHCache 支持。EHCache SessionDAO 将会在内存中保存会话,并支持溢出到磁盘,若内存 成为制约。这对生产程序确保你在运行时不会随机地“丢失”会话是非常好的。 7.Custom Session IDsShiro 的 SessionDAO 实现使用一个内置的 SessionIdGenerator 组件来产生一个新的 Session ID 当每次创建一个新的会 话的时候。该 ID 生成后,被指派给新近创建的 Session 实例,然后该 Session 通过 SessionDAO 被保存下来。默认的 SessionIdGenerator 是一个 JavaUuidSessionIdGenerator,它能产生基于 Java UUIDs 的 String IDs。该实现能够 支持所有的生产环境。如果它不符合你的需要,你可以实现 SessionIdGenerator 接口并在 Shiro 的 SessionDAO 实例上配置该实现。 9.Session Validation &amp; SchedulingSessions 必须被验证,这样任何无效(过期或停止)的会话能够从会话数据存储中删除。这保证了数据存储不会由于不 能再次使用的会话而导致写入超时。由于性能上的原因,仅仅在 Sessions 被访问(也就是 subject.getSession())时验证它们是否停止或过期。这意味着, 如果没有额外的定期验证,Session orphans(孤儿)将会开始填充会话数据存储。 11.Default SessionValidationScheduler默认可用的 SessionValidationScheduler 在所有环境中都是 ExecutorServiceSessionValidationScheduler,它使用 JDK ScheduledExecutorService 来控制验证频率。默认地,该实现每小时执行一次验证。你可以通过指定一个新的 ExecutorServiceSessionValidationScheduler 实例并指 定不同的间隔(以毫秒为单位)改变速率来更改验证频率 12.Disabling Session Validation在某些情况下,你可能希望禁用会话验证项,由于你建立了一个超出了 Shiro 控制的进程来为你执行验证。例如, 也许你正在使用一个企业的 Cache 并依赖于缓存的 Time To Live 设置来自动地去除旧的会话。或者也许你已经制定 了一个计划任务来自动清理一个自定义的数据存储。在这些情况下你可以关掉 session validation scheduling: securityManager.sessionManager.sessionValidationSchedulerEnabled = false 当会话从会话数据存储取回数据时它仍然会被验证,但这会禁用掉 Shiro 的定期验证。","categories":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/tags/shiro/"},{"name":"SecurityManager","slug":"SecurityManager","permalink":"https://lbvs86823.github.io/tags/SecurityManager/"},{"name":"Session","slug":"Session","permalink":"https://lbvs86823.github.io/tags/Session/"}],"keywords":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}]},{"title":"Shiro 第四章 Realms","slug":"shiro/shiro_04","date":"2010-12-18T01:41:09.000Z","updated":"2020-03-20T06:27:43.670Z","comments":true,"path":"2010/12/18/shiro/shiro_04/","link":"","permalink":"https://lbvs86823.github.io/2010/12/18/shiro/shiro_04/","excerpt":"","text":"1.Realm 概述：Realm 是一个能够访问应用程序特定的安全数据(如用户、角色及权限)的组件。Realm 将应用程序特定的数据转 换成一种 Shiro 能够理解的格式,这样 Shiro 能够提供一个单一的易理解的 Subject 编程 API Realm 通常和数据源是一对一的对应关系,如关系数据库,LDAP 目录,文件系统,或其他类似资源。因此,Realm 接口的实现使用数据源特定的 API 来展示授权数据(角色,权限等),如 JDBC,文件 IO,Hibernate 或 JPA,或其他 数据访问 API。 Realm 实质上就是一个特定安全的 DAO 因为这些数据源大多通常存储身份验证数据(如密码的凭证)以及授权数据(如角色或权限),每个 Shiro Realm 能够执行身份验证和授权操作。 2.Realm 配置如果使用 Shiro 的 INI 配置文件,你能够自定义及引用 Realm,就像在[main]项中的任何其他对象一样,但它们在 securityManager 中采用两种方法之一进行配置:显式或隐式。 Explicit Assignment基于迄今的 INI 配置知识,这是一个显示的配置方法。在定义一个或多个 Realm 后,你将它们作为 securityManager 对象的集合属性。例如: fooRealm = com.company.foo.Realm barRealm = com.company.another.Realm bazRealm = com.company.baz.Realm securityManager.realms = $fooRealm, $barRealm, $bazRealm 显式分配是确定的——你控制具体使用哪一个 Realm 及它们用于身份验证和授权的顺序。Realm 顺序的作用在Authentication 章的 Authentication Sequence 节进行了详细的介绍。 Implicit Assignment Not Preferred(不推荐)这种方法可能引发意想不到的行为,如果你改变 realm 定义的顺序的话。建议你避免使用此方法,并使用显式分配, 它拥有确定的行为。该功能很可能在未来的 Shiro 版本中被废弃或移除。 3.Realm Authentication当你理解了 Shiro 的主要 Authentication 工作流后,了解在一个授权尝试中当 Authenticator 与 Realm 交互时到底发 生了什么是很重要的。 4.Supporting AuthenticationTokens在 authentication sequence 中已经提到,当在 Realm 被访问来执行一个授权尝试之前,它的 supports 方法被调用。 如果返回值为 true,则只有这样它的 getAuthenticationInfo(token)方法才会被调用。 5.Handling supported AuthenticationTokens若 Realm 支持一个提交的 AuthenticationToken,那么 Authenticator 将会调用该 Realm 的 getAuthenticationInfo(token) 方法。这有效地代表了一个与 Realm 的后备数据源的授权尝试。该方法按以下方法进行: 为主要的识别信息(帐户识别信息)检查 token。 基于 principal 在数据源中寻找相吻合的帐户数据。 确保 token 支持的 credentials 匹配那些存储在数据源的。 若 credentials 匹配,返回一个封装了 Shiro 能够理解的帐户数据格式的 AuthenticationInfo 实例。 若 credentials 不匹配,则抛出 AuthenticationException 异常。 这是对所有 Realm getAuthenticationInfo 实现的最高级别的工作流。在此方法中,Realm 可以自由地做任何它们想做 的,如记录在审计日志的尝试,更新数据记录,或任何其他可以对该数据存储的身份验证尝试有意义的东西。 直接实现 Realm 接口可能导致时间消耗及错误。大多数人民选择 AuthorizingRealm 抽象类的子类而不是从头开始。 这个类实现了常用的 authentication 及 authorization 工作流来节省你的时间和精力。 6.Realm Credentials Matching这是每个 Realm 的责任,去匹配提交的 credentials 和那些存储在 Realm 后备数据存储中的 credentials,而不是 Authenticator 的责任。每个 Realm 拥有有关私人信息的 credentials 格式,存储及能够执行详细的 credentials 匹配, 然而 Authenticator 只是一个普通的工作量组件。 credentials 的匹配过程在所有应用程序中几乎一样,通常不一样的是进行比较的数据。为了确保该过程是可插入及 可定制的如果需要的话,AuthenticatingRealm 及它的子类支持 CredentialsMatcher 来执行 credentials 对比的概念。 Shiro 拥有某些可以让你立即使用的 CredentialsMatcher 实现,如 SimpleCredenticalsMatcher 和 HashedCredentialsMatcher,但如果你想为自定义的逻辑配置一个自定义的实现,你可以像下面一样直接做: Realm myRealm = new com.company.shiro.realm.MyRealm(); CredentialsMatcher customMatcher = new com.company.shiro.realm.CustomCredentialsMatcher(); myRealm.setCredentialsMatcher(customMatcher); 所有 Shiro 立即可用的 Realm 的实现默认使用 SimpleCredentialsMatcher。SimpleCredentialsMatcher 执行一个普通的 直接平等检查,关于存储的帐户 credentials 与在 AuthenticationToken 所提交的之间的检查。 7.Hashing Credentials并非是存储 credentials 在其原始的 form 及执行原始/普通的比较,一个更安全的方式存储终端用户的 credential(s 如, 密码)是在存储它们到数据存储之前将它们单向散列化。 为了支持这些首选的加密哈希策略,Shiro 提供了 HashedCredentialsMatcher 的实现配置在 realm 上而不是上述 SimpleCredentialsMatcher。 8.Disabling Authentication如果出于某些原因,你不想用 Realm 对数据源执行身份验证(也许是由于你只想 Realm 执行授权),你可以彻底地 禁用 Realm 对身份验证的支持通过从 Realm 的 support 方法返回 false。然后你的 realm 在身份验证尝试中永远不会 被访问到。 当然,至少需要一个能够支持 AuthenticationTokens 且已配置的 Realm,如果你想验证 Subjects。","categories":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/tags/shiro/"},{"name":"SecurityManager","slug":"SecurityManager","permalink":"https://lbvs86823.github.io/tags/SecurityManager/"},{"name":"Realms","slug":"Realms","permalink":"https://lbvs86823.github.io/tags/Realms/"}],"keywords":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}]},{"title":"Shiro 第三章 身份授权","slug":"shiro/shiro_03","date":"2010-12-17T11:02:22.000Z","updated":"2020-03-20T06:27:43.669Z","comments":true,"path":"2010/12/17/shiro/shiro_03/","link":"","permalink":"https://lbvs86823.github.io/2010/12/17/shiro/shiro_03/","excerpt":"","text":"1.授权：授权,又称作为访问控制,是对资源的访问管理的过程。换句话说,控制谁有权限在应用程序中做什么。授权检查的例子是:该用户是否被允许访问这个网页,编辑此数据,查看此按钮,或打印到这台打印机?这些都是 决定哪些是用户能够访问的。 2.授权的要素：Apache Shiro 中的权限代表着安全政策中最基础的元素。它们从根本上作出了对行为的声明,并明确表示可以在应 用程序中做什么。一个格式良好的权限声明基本上描述了资源以及当 Subject 与这些资源进行交互时可能出现的行 为。权限语句的一些例子: 打开一个文件; 查看’/user/list’网页; 打印文档; 删除用户’jsmith’。 大多数资源将支持典型的 CRUD(创建,读取,更新,删除)操作,但任何对特定资源有意义的行为都是可以的。基本的概念是,最小的许可声明是基于资源和行为的。在查看权限时,最重要的可能是认识到许可声明没有谁可以执行代表行为的表现形式。它们仅仅只是在一个应用程 序中能做什么的声明语句。 3.权限粒度以上所有权限例子详细说明了在某一资源类型(入口,文件,客户等等)的行为(打开,阅读,删除等等)。在某些情况下,它们甚至可以指定非常细粒度的实例级的行为——例如,“删除”(行为)用户名为”jsm”的“用户” (资源类型)。 在 Shiro,你有能力来定义这些声明能够达到的精确粒度。 4.角色角色是一个命名的实体,通常代表一组行为或职责。这些行为演化为你在一个软件应用中能或者不能做的事情。角色通常是分配给用户帐户的,因此,通过分配,用户能够“做”的事情可以归属于各种角色。 有两种有效类型的角色,并且 Shiro 支持这两个概念: 隐式角色:大多数人使用的角色作为一个隐式的构造:你的应用程序仅仅基于一个角色名就蕴含了一组行为 (也就是权限)。有了隐式角色,在软件级别上没有说“角色 X 被允许执行行为 A,B 和 C”。行为已被一个单独的名字所蕴含。 显式角色:一个显式角色本质上是一个实际许可声明的命名集合。在这种形式下,应用程序(以及 Shiro)确 切地知道有没有一个特定的角色意味着什么。因为它是已知能不能够被执行的确切行为,没有猜测或暗示一 个特定的角色能或不能做什么。 Shiro 团队提倡使用权限和显式角色,而不是陈旧的隐式方法。你将会拥有更多的控制应用程序的安全经验。 Resource-Based Access Control(基于资源的访问控制) 新的RBAC:基于资源的访问控制, 其中包括深入使用权限和显式角色(以及它们在源代码上产生的积极影响)而不是陈旧的隐式方法的好处。 5.Users(用户)用户实质上是指与应用程序有关的人。然而正如我们已经讨论的,Subject 才是 Shiro 的“用户”概念。允许用户(Subjects)在你的应用程序中执行某些操作,是通过与他们的角色相关联或授予直接的权限。你的应用 程序的数据模型定义了 Subject 是如何被允许做某事或不的。 例如,在你的数据模型中,也许你有一个实际的 User 类,而且你直接分配权限给 User 实例。或者,你也许只分配 权限给角色,然后分配角色给用户,通过关联,用户延伸“有”的权限分配给自己的角色。或者你用”Group”的概 念来代替这些东西。这些都随便你——使用什么使得你的程序有意义。 你的数据模型定义授权究竟是如和工作的。Shiro 依靠 Realm 来实现转换你的数据模型使其细节关联到一种 Shiro 能 够理解的格式。 6.Authorizing Subjects(授权的 Subjects)在 Shiro 中执行授权可以有 3 种方式: 编写代码——你可以在你的 Java 代码中用像 if 和 else 块的结构执行授权检查。 JDK 的注解——你可以添加授权注解给你的 Java 方法。 JSP/GSP 标签库——你可以控制基于角色和权限的 JSP 或者 GSP 页面输出。 Programmatic Authorization(编程授权)也许最简单和最常见的方式来执行授权是直接以编程方式与当前 Subject 实例交互。 Role-Based Authorization(基于角色的授权)如果你想进行基于简单/传统的隐式角色名来控制访问,你可以执行角色检查: (1)Role checks(角色检查)如果你只是简单的想检查当前的 Subject 是否拥有一个角色,你可以在 Subject 实例上调用变体的 hasRole*方法。 例如,判断一个 Subject 是否拥有一个特别的(单一的)角色,你可以通过调用 subject.hasRole 方法,并作出相应的反应: Subject 方法 描述 hasRole(String roleName) 返回 true 如果 Subject 被分配了指定的角色,否则返回 false。 hasRole(List\\&lt;String> roleNames) 返回 true 如果 Subject 被分配了所有指定的角色,否则返回 false。 hasAllRoles(Collection\\&lt;String> roleNames) 返回一个与方法参数中目录一致的 hasRole 结果的数组。有性能的提高如果许多角 色需要执行检查(例如,当自定义一个复杂的视图)。 (2)Role Assertions(角色断言)另一种方法通过检查布尔值来判断 Subject 是否拥有一个角色,你可以简单地断言它们有一个预期的角色在逻辑被 执行之前。如果 Subject 没有预期的角色,AuthorizationException 将会被抛出。如果它们有预期的角色,断言将悄悄 地执行,并且逻辑将如预期般继续。 Subject 方法 描述 checkRole(String roleName) 安静地返回,如果 Subject 被分配了指定的角色,不然的话就抛出AuthorizationException。 checkRoles(Collection\\&lt;String> roleNames) 安静地返回,如果 Subject 被分配了所有的指定的角色,不然的话就抛出 AuthorizationException。 checkRoles(String… roleNames) 与上面的 checkRoles 方法的效果相同,但允许 Java5 的 var-args 类型的参数。 Permission-Based Authorization(基于权限的授权)基于权限的授权,由于 它与你的应用程序的原始功能(以及应用程序核心资源上的行为)紧密的关联在一起的,基于权限的授权源代码会 在你的功能改变时改变,而不是在安全政策改变时改变。 Permission Checks(权限检查)如果你想进行检查,看一个 Subject 是否被允许做某事,你可以调用各种 isPermitted*方法的变种。检查权限主要有 两个方式——基于对象的权限实例或代表权限的字符串。 ####### (1)Object-based Permission Checks(基于对象的权限检查)执行权限检查的一个可行方法是实例化 org.apache.shiro.authz.Permission 接口的一个实例,并把它传递给接收权限 实例的*isPermitted 方法。 基于对象的权限是很有用的,如果: * 你想编译时类型安全 * 你想保证权限被描述和使用是正确的 * 你想显式控制许可解析逻辑(被称作许可蕴含的逻辑,基于权限接口的 implies 方法)是如何执行的。 * 你想保证权限反映到应用程序资源是准确的(例如,也许权限类可以在能够基于项目的域模型的项目编译时 自动生成)。 Subject 方法 描述 isPermitted(Permission p) 返回 true 如果该 Subject 被允许执行某动作或访问被权限实例指定的资源集 合,否则返回 false。 isPermitted(List\\&lt;Permission> perms) 返回一个与方法参数中目录一致的 isPermitted 结果的数组。有性能的提高如 果需要执行许多检查(例如,当自定义一个复杂的视图)。 isPermittedAll(Collection\\&lt;Permission> perms) 返回 true 如果该 Subject 被允许所有指定的权限,否则返回 false。 ####### (2)String-based permission checks(基于字符串的权限检查)基于对象的权限可以是很有用的(编译时类型安全,保证行为,定制蕴含逻辑等),它们有时对应用程序来说会感 到有点“笨手笨脚”的。另一种方法是使用正常的字符串来表示权限实例。 Subject currentUser = SecurityUtils.getSubject(); if (currentUser.isPermitted(&quot;printer:print:laserjet4400n&quot;)) { //show the Print button } else { //don&apos;t show the button? Grey it out? } 一个特殊冒号分隔的格式,它由 Shiro 默认的 org.apache.shiro.authz.permission.WildcardPermission 实现来定义,其中大多数人会找到适合自己的格式。 Subject currentUser = SecurityUtils.getSubject(); Permission p = new WildcardPermission(&quot;printer:print:laserjet4400n&quot;); if(currentUser.isPermitted(&quot;printer:print:laserjet4400n&quot;)) { //show the Print button } else { //don&apos;t show the button? Grey it out? } WildcardPermission token 规定和构造操作的格式在 Shiro 的 Permission 文档中被深入的涉及到。 除了上面的字符串默认的 WildcardPermission 格式,你可以创建和使用自己的字符串格式如果你喜欢的话。 基于字符串的权限是很有帮助的,由于你不必被迫实现一个接口,而且简单的字符串易于阅读。其缺点是,你不具备类型安全,如果你需要更为复杂的行为将超出了字符串所能代表的范围,你就得实现你自己的基于权限接口的权限对象。在实际中,大部分的 Shiro 终端用户为了简洁选择基于字符串的方式,但最终你应用程序的需求会决定哪一个更好。 Subject 方法 描述 isPermitted(String perm) 返回 true 如果该 Subject 被允许执行某动作或访问被字符串权限指定的资源,否则返回 false。 isPermitted(String… perms) 返回一个与方法参数中目录一致的 isPermitted 结果的数组。有性能的提高如果许多字符串 权限检查需要被执行(例如,当自定义一个复杂的视图)。 isPermittedAll(String… perms) 返回 true 如果该 Subject 被允许所有指定的字符串权限,否则返回 false。 ####### (3)Permission Assertions(权限断言)作为检查一个布尔值来判断 Subject 是被允许做某事的一种替代,你可以在逻辑被执行之前简单地断言他们是否拥 有预期的权限。如果该 Subject 是不被允许,AuthorizationException 异常将会被抛出。如果他们如预期的被允许,断 言将安静地执行,逻辑也将如预期般继续。 Subject 方法 描述 checkPermission(Permission p) 安静地返回,如果 Subject 被允许执行某 动作或访问被特定的权限实例指定的资 源,不然的话就抛出 AuthorizationException 异常。 checkPermission(String perm) 安静地返回,如果 Subject 被允许执行某 动作或访问被特定的字符串权限指定的 资源,不然的话就抛出 AuthorizationException 异常。 checkPermissions(Collection\\&lt;Permission> perms) 安静地返回,如果 Subject 被允许所有的 权限,不然的话就抛出 AuthorizationException 异常。 checkPermissions(String… perms) 和上面的 checkPermissions 方法效果相 同,但是使用的是基于字符串的权限。 7.Annotation-based Authorization(基于注解的授权)除了 Subject API 的调用,Shiro 提供 Java 5+注解的集合,如果你喜欢以注解为基础的授权控制。 *configuration(配置)在你可以使用 Java 注释之前,你需要在你的应用程序中启用 AOP 支持。虽然现在有许多不同的 AOP 框架,但不幸 的是,在应用程序中没有一个使用 AOP 的标准。对于 AspectJ 而言,你你可以回顾我们的 AspectJ 的示例程序。对于 Spring 应用而言,你可以看看我们的 Spirng 集成文档。 (1)The RequiresAuthentication annotation(RequiresAuthentication 注解)RequiresAuthentication 注解要求当前 Subject 已经在当前的 session 中被验证通过才能被注解的类/实例/方法访问或 调用。 @RequiresAuthentication public void updateAccount(Account userAccount) { //this method will only be invoked by a //Subject that is guaranteed authenticated ... } (2)The RequiresGuest annotation(RequiresGuest 注解)RequiresGuest 注解要求当前的 Subject 是一个”guest”,也就是说,他们必须是在之前的 session 中没有被验证或记住 才能被注解的类/实例/方法访问或调用。 @RequiresGuest public void signUp(User newUser) { //this method will only be invoked by a //Subject that is unknown/anonymous ... } (3)The RequiresPermissions annotation(RequiresPermissions 注解)RequiresPermissions 注解要求当前的 Subject 被允许一个或多个权限,以便执行注解的方法。 @RequiresPermissions(&quot;account:create&quot;) public void createAccount(Account account) { //this method will only be invoked by a Subject //that is permitted to create an account ... } ####### (4)The RequiresRoles annotation(RequiresRoles 注解)RequiresRoles 注解要求当前的 Subject 拥有所有指定的角色。如果他们没有,则该方法将不会被执行,而且 AuthorizationException 异常将会被抛出。 @RequiresRoles(&quot;administrator&quot;) public void deleteUser(User user) { //this method will only be invoked by an administrator ... } ####### (5)The RequiresUser annotation(RequiresUser 注解)RequiresUser 注解需要当前的 Subject 是一个应用程序用户才能被注解的类/实例/方法访问或调用。一个“应用程序用户”被定义为一个拥有已知身份,或在当前 session 中由于通过验证被确认,或者在之前 session 中的’RememberMe’ 服务被记住。 @RequiresUser public void updateAccount(Account account) { //this method will only be invoked by a &apos;user&apos; //i.e. a Subject with a known identity ... } 8.JSP TagLib Authorization(JSP TagLib 授权)Shiro 提供了一个用于控制 JSP/GSP 页面输出的基于 Subject 状态的标签库。这些包含在 Web 章节的 JSP/GSP 标签库部分。 9.Authorization Sequence(授权顺序)现在我们已经知道了基于当前 Subject 上如何执行授权,让我们看看当授权调用时,Shiro 内部会发生什么。 我们采用了 Architecture 那一章的体系结构图,并只留下与 authorization 有关的组件突出显示。 Step 1: 应用程序或框架代码调用任何 Subject 的 hasRole*, checkRole*, isPermitted*, 或者 checkPermission*方法的变 体,传递任何所需的权限或角色代表。 Step 2: Subject 的实例,通常是 DelegatingSubjec(t 或子类)代表应用程序的 SecurityManager 通过调用 securityManager 的几乎各自相同的 hasRole*, checkRole*, isPermitted*,或 checkPermission*方法的变体(SecurityManager 实现 org.apache.shiro.authz.Authorizer 接口,他定义了所有 Subject 具体的授权方法)。 Step 3: SecurityManager,作为一个基本的“保护伞”组件,接替/代表它内部的 org.apache.shiro.authz.Authorizer 实例通过调用 authorizer 各自的 hasRole*, checkRole*, isPermitted*, 或者 checkPermissions*方法。默认情况下, authorizer 实例是一个ModularRealmAuthorizer 实例,它支持协调任何授权操作过程中的一个或多个 Realm 实例。 Step 4: 每个配置好的 Realm 被检查是否实现了相同的 Authorizer 接口。如果是,Realm 各自的 hasRole*, checkRole*, isPermitted*,或 checkPermission*方法将被调用。 ModularRealmAuthorizer如前所述,Shiro SecurityManager 的实现默认是使用一个 ModularRealmAuthorizer 实例。ModularRealmAuthorizer 同样支持单一的 Realm,以及那些与多个 Realm 的应用。对于任何授权操作,ModularRealmAuthorizer 将遍历其内部的 Realm 集合,并按迭代顺序与每一个进行交互。每个 Realm 的交互功能如下: 如果 Realm 自己实现了 Authorizer 接口,它的各个 Authorizer 方法(hasRole*, checkRole*, isPermitted*, 或 checkPermission*)将被调用 (1). 如果 Realm 的方法导致异常,该异常将会以 AuthorizationException 的形式传递给调用者。这将短路授权 过程,同时任何剩余的 Realm 将不会被该授权操作所访问。 (2). 如果该 Realm 的方法是一个返回布尔值的 hasRole*或者 isPermitted*的变体,并且该返回值为 true,真 值将会立即被返回,同时任何剩余的 Realm 都将被短路。这种行为作为提高性能的一种存在,如果该行 为被一个 Realm 允许,这意味着该 Subject 也是被允许的。这有利于安全政策,每一处都是默认被禁止的 情况下,一切都明确允许的,这是安全政策最安全的类型。 如果 Realm 不实现 Authorizer 接口,它会被忽略。 Realm Authorization Order(Realm 的授权顺序)需要重要指出的是,尤其是身份验证,ModularRealmAuthorizer 将以迭代顺序与 Realm 实例进行交互。 ModularRealmAuthorizer 根据SecurityManager的配置获得对Realm实例的访问。当执行授权操作时,它会遍历该集 合,同时对于每一个自己实现 Authorizer 接口的 Realm,调用 Realm 各自的 Authorizer 方法(如 hasRole, checkRole\\, isPermitted*,或 checkPermission*)。 Configuring a global PermissionResolver(配置全局的 PermissionResolver)当执行基于字符串的权限检查是,大多数 Shiro 的默认 Realm 实现首先将该字符串转换成一个实际的 Permission 实 例,在执行权限 implication 逻辑之前。 这是因为 Permission 是基于 implication 逻辑评估的,而不是直接的 equality 检查(见 Permission 文档有关更多 implication 和 equality 的对比)。Implication 逻辑对比通过字符串比较能够更好的在代码中体现。因此,大多数 Realm 需要转换,或者将提交的权限字符串解析成相应的代表权限的实例。 为了帮助这种转换,Shiro 支持 PermissionResolver 的概念。大多数 Shiro Realm 的实现使用一个 PermissionResolver 以支持他们的基于字符串权限的 Authorizer 接口方法的实现:当其中一种方法在 Realm 上被调用是,它将使用 PermissionResolver 把该字符串转换成一个权限实例,并用这种方式来执行检查。 所有 Shiro Realm 的实现默认是内部的 WildcardPermissionResolver,它采用 Shiro 的 WildcardPermission 字符串格式。 如过你想创建自己的 PermissionResolver 的实现,也许是为了支持自己的权限字符串语法,而且你想要所有配置的 Realm 实例支持该语法,你可以将你的 PermissionResolver 设置为全局的,这样所有的 Realm 能够用一个配置。 globalPermissionResolver = com.foo.bar.authz.MyPermissionResolver securityManager.authorizer.permissionResolver = $globalPermissionResolver PermissionResolverAware如果你想配置一个全局的 PermissionResolver,每个用来接收配置的 PermissionResolver 的 Realm 必须实现 PermissionResolverAware 接口。这样保证了配置的实例能够被每个支持该配置的 Realm 转发。 Configuring a global RolePermissionResolver(配置全局的 RolePermissionResolver)与 PermissionResolver 在概念上相似,RolePermissionResolver 有能力代表需要的权限实例,通过一个 Realm 执行权 限检查。 然而,与一个 RolePermissionResolver 的关键区别是输入的字符串是一个角色名,而不是一个权限字符串。 RolePermissionResolver 能够在 Realm 内部使用,当需要将一个角色名转换成一组具体的权限实例时。 这是一个特别有用的特征用来支持旧的或不灵活的,可能没有权限概念的数据源。由于这种转换角色名到权限的概念非常特定于应用程序,Shiro 默认 Realm 的实现并不使用它们。 然而,如果你想创建你自己的 RolePermissionResolver,并有多个你想配置的 Realm 的实现,你可以将你的 RolePermissionResolver 设置为全局的,这样所有的 Realm 都能够用一个配置。 globalRolePermissionResolver = com.foo.bar.authz.MyPermissionResolver securityManager.authorizer.RolePermissionResolver = $globalRolePermissionResolver RolePermissionResolverAware如果你想配置一个全局的 RolePermissionResolver,每个用来接收配置的 RolePermissionResolver 的 Realm 必须实现 RolePermissionResolverAware 接口。这样保证了配置的全局的 RolePermissionRosolver 实例能够被每个支持该配置的 Realm 转发。 Custom Authorizer(自定义授权者)如果你的应用程序使用多个 realm 来执行授权,并且 ModularRealmAuthorizer 默认基于简单的迭代,短路授权行为 不符合你的要求,你很有可能想创建一个自定义的授权者,并配置相应的 SecurityManager。 authorizer = com.foo.bar.authz.CustomAuthorizer securityManager.authorizer = $authorizer","categories":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/tags/shiro/"},{"name":"SecurityManager","slug":"SecurityManager","permalink":"https://lbvs86823.github.io/tags/SecurityManager/"},{"name":"Realms","slug":"Realms","permalink":"https://lbvs86823.github.io/tags/Realms/"},{"name":"Authentication","slug":"Authentication","permalink":"https://lbvs86823.github.io/tags/Authentication/"},{"name":"Authorization","slug":"Authorization","permalink":"https://lbvs86823.github.io/tags/Authorization/"}],"keywords":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}]},{"title":"Shiro 第二章 身份认证","slug":"shiro/shiro_02","date":"2010-12-16T08:05:29.000Z","updated":"2020-03-20T06:27:43.668Z","comments":true,"path":"2010/12/16/shiro/shiro_02/","link":"","permalink":"https://lbvs86823.github.io/2010/12/16/shiro/shiro_02/","excerpt":"","text":"1.Shiro 身份认证要素：Authentication 是指身份验证的过程——即证明一个用户实际上是不是他们所说的他们是谁。对于一个用户证明自己 的身份来说,他们需要提供一些身份识别信息,以及某些你的系统能够理解和信任的身份证明。 这是通过提交用户的身份和凭证给 Shiro,以判断它们是否和应用程序预期的相匹配 Principals(身份)是 Subject 的‘identifying attributes(标识属性)’。Principals(身份)可以是任何能够证明 Subject 的东西,因此,最好的用来进行身份验证的 Principals(身份)是对应用程序来说应 该是独一无二的——通常是用户名或电子邮件地址. Credentials(凭证)通常是只被 Subject 知道的秘密值,它用来作为一种起支持作用的证据,此证据事实上 包含着所谓的身份证明。一些常见 credentials(凭证)的例子有密码,生物特征数据如指纹和视网膜扫描, 以及 X.509 证书。 principal/credential 配对最常见的例子是用户名和密码。用户名是所声称的身份,密码是匹配所声称的身份的证明。 2.Shiro 身份认证过程：Authenticating Subjects(验证 Subjects)，验证 Subjects 的过程中,可以有效地分解成三个不同的步骤: 收集 Subjects 提交的 Principals(身份)和 Credentials(凭证); 提交 Principals(身份)和 Credentials(凭证)进行身份验证; 如果提交成功,则允许访问,否则重新进行身份验证或者阻止访问。 Step 1 ===&gt; 收集 Subject 的 Principals(身份)和 Credentials(凭证)UsernamePasswordToken token = new UsernamePasswordToken(username, password); token.setRememberMe(true); 我们使用 UsernamePasswordToken 来支持最常见的用户名/密码的身份验证方法。这是 Shiro 的 org.apache.shiro.authc.AuthenticationToken 的接口,是 Shiro 代表提交的 Principals(身份)和 Credentials(凭证)的身份验证系统所使用的基本接口的一个实现。 Step 2 ===&gt; 提交 Subject 的 Principals(身份)和 Credentials(凭证)Subject currentUser = SecurityUtils.getSubject(); currentUser.login(token); 在 Principals(身份)和 Credentials(凭证)被收集以及被实例化为 AuthenticationToken 实例后,我们需要提交这个 token 给 Shiro 来执行真正的身份验证尝试。在捕获到当前执行的 Subject 后,我们获得一个单一的 login 方法调用,并将之前获得的 AuthenticationToken 实例传递给它。通过调用 login 方法,有效地体现了身份验证尝试。 Step 3 ===&gt; 处理成功或失败如果 login 方法返回平静地,就是它——我们所做的一切!该 Subject 已通过验证。 应用程序线程可以不受干扰地继续下去,而且所有进一步对 SecurityUtils.getSubject()的调用将返回认证后的 Subject 实例,同时任何对 subject.isAuthenticated()的调用将返回 true。 但是如果登录尝试失败会发生什么呢?例如,如果终端用户提供了不正确的密码,或这访问系统的次数太多, 亦或是他们的帐户被锁定? Shiro 拥有丰富的运行时 AuthenticationException 层次结构,可以指出尝试失败的确切原因。你可以用一个 try/catch 块将 login 方法包围起来,然后捕捉任何你期望的异常并进行相应的反应。例如: try { currentUser.login(token); } catch ( UnknownAccountException uae ) { ... } catch ( IncorrectCredentialsException ice ) { ... } catch (LockedAccountException lae ) { ... } catch (ExcessiveAttemptsException eae ) { ... } ... catch your own ... } catch ( AuthenticationException ae ) { } //unexpected error? 如果现有的异常类不符合您的要求,可以自定义 AuthenticationExceptions 来代表具体的异常情况。 3.Remembered vs. Authenticated(记住我对比认证)Shiro 支持除了普通的登录过程的所有“记住我”的概念。此时值得指出的是,Shiro 对记 住我的 Subject 和通过验证的 Subject 作了精确的区分: Remembered(记住我):一个记住我的 Subject 不是匿名的,而且有一个已知的身份 ID(也就是 subject.getPrincipals()是非空的)。但是这个被记住的身份 ID 是在之前的 session 中被认证的。如果 subject.isRemembered()返回 true,则 Subject 被认为是被记住的。 Authenticated(已认证):一个已认证的 Subject 是指在当前 Session 中被成功地验证过了(也就是说,login 方法被调用并且没有抛出异常)。如果 subject.isAuthenticated()返回 true 则认为 Subject 已通过验证。 Remembered 和 Authenticated 是互斥的——若其中一个为真则另一个为假,反之亦然。 为何有这样的区别?“身份验证”这个词有很强的证明的意思在里面。也就是说,有一个预期保证 Subject 已经证明他们是他们所说的谁。当用户只记得之前与应用的交互时,认证将不复存在:被记住的身份 ID 使系统明白这个用户可能是谁,但在 现实中没有办法绝对保证被记住的 Subject 代表期望的用户。一旦 Subject 通过验证,它们将不再仅仅被认为是被记住的,由于它们的身份已经在当前 session 中被证实。 尽管应用程序的许多部分仍然能够执行基于被记住身份 ID 的用户特定逻辑,像自定义视图,但它绝不应该执 行高度敏感的操作,除非用户通过执行一个成功的认证尝试来合法地验证自己的身份。 例如,一个检查来判断一个 Subject 可以访问财务信息应该几乎总是取决于 isAuthenticated(),而不是 isRemembered(),以保证一个预期和核实的身份。 4.注销进行身份验证的反面是释放所有已知的的识别状态。当 Subject 完成了与应用程序的交互后,你可以调用 subject.logout() 来释放所有的识别信息: currentUser.logout(); 5.验证顺序详解 Step 1:应用程序代码调用 Subject.login 方法,传递创建好的包含终端用户的 Principals(身份)和 Credentials(凭 证)的 AuthenticationToken 实例。 Step 2:Subject 实例,通常是 DelegatingSubject(或子类)委托应用程序的 SecurityManager 通过调用securityManager.login(token)开始真正的验证工作。 Step3:SubjectManager 作为一个基本的“保护伞”的组成部分,接收 token 以及简单地委托给内部的 Authenticator 实例通过调用 authenticator.authenticate(token)。这通常是一个 ModularRealmAuthenticator 实例, 支持在身份验证中协调一个或多个 Realm 实例。ModularRealmAuthenticator 本质上为 Apache Shiro 提供了 PAM-style 范式(其中在 PAM 术语中每个 Realm 都是一个’module’)。 Step 4:如果应用程序中配置了一个以上的 Realm,ModularRealmAuthenticator 实例将利用配置好的 AuthenticationStrategy 来启动 Multi-Realm 认证尝试。在 Realms 被身份验证调用之前,期间和以后, AuthenticationStrategy 被调用使其能够对每个 Realm 的结果作出反应。我们马上就会涉及到 AuthenticationStrategies。 Single-Realm Application 如果只有一个单一的 Realm 被配置,它将被直接调用——没有必要为一个单一 Realm 的应用使用 AuthenticationStrategy。 Step 5:每个配置的 Realm 用来帮助看它是否支持提交的 AuthenticationToken。如果支持,那么支持 Realm 的 getAuthenticationInfo 方法将会伴随着提交的 token 被调用。getAuthenticationInfo 方法有效地代表一个特定 Realm 的单一的身份验证尝试。我们将在不久涉及到 Realm 验证行为。Authenticator(认证器)如前所述,Shiro SecurityManager 的实现默认使用一个 ModularRealmAuthenticator 实例。 ModularRealmAuthenticator 同样支持单一的 Realm 以及那些多个 Realm 的应用。在一个单一的 Realm 应用中,ModularRealmAuthenticator 将直接调用这个单一的 Realm。如果有两个或两个 以上的 Realm 配置,它将使用 AuthenticationStrategy 实例来调整这些尝试如何出现。下面我们将介绍 AuthenticationStrategies。 AuthenticationStrategy当一个应用程序配置了两个或两个以上的 Realm 时,ModularRealmAuthenticator 依靠内部的 AuthenticationStrategy 组件来确定这些认证尝试的成功或失败条件。例如,如果只有一个 Realm 验证一个 AuthenticationToken 成功,但所有其他的都失败,这被认为是成功的身 份验证尝试吗?或者必须所有的 Realm 验证成功才被认为样子成功吗?或者,如果一个 Realm 验证成功,是 否有必要进一步征询其他 Realm?AuthenticationStrategy 基于程序需要作出合适的决定。 AuthenticationStrategy 是一个无状态的组件,它在身份验证尝试中被询问 4 次(这 4 次交互所需的任何必要的 状态将被作为方法参数): 在任何 Realm 被调用之前被询问; 在一个单独的 Realm 的 getAuthenticationInfo 方法被调用之前立即被询问; 在一个单独的 Realm 的 getAuthenticationInfo 方法被调用之后立即被询问; 在所有的 Realm 被调用后询问。 另外,AuthenticationStrategy 负责从每一个成功的 Realm 汇总结果并将它们“捆绑”到一个单一的 AuthenticationInfo 再现。这最后汇总的 AuthenticationInfo 实例就是从 Authenticator 实例返回的值以及 Shiro 所用来代表 Subject 的最终身份 ID 的值(即 Principals(身份))。 如果在你的应用程序中使用多个 Realm 从多个数据源获取账户资料,AuthenticationStrategy 是最终为最后的“合 并”能够被应用程序理解的 Subject 的身份的视图的负责人。 Shiro 有 3 个具体的 AuthenticationStrategy 实现: 实现类 描述 AtLeastOneSuccessfulStrategy 如果一个(或更多)Realm 验证成功,则整体的尝试被认为是成功的。如果没有一个验证成功,则整体尝试失败。 FirstSuccessfulStrategy 只有第一个成功地验证的 Realm 返回的信息将被使用。所有进一步的 Realm 将被忽略。如果没有一个验证成功,则整体尝试失败。 AllSucessfulStrategy 为了整体的尝试成功,所有配置的 Realm 必须验证成功。如果没有一个验证成功,则整体尝试失败。 ModularRealmAuthenticator 默认的是 AtLeastOneSuccessfulStrategy 实现,因为这是最常所需的方案。然而,如果你愿意的话,你可以配置一个不同的方案 自定义认证策略如果你想创建你自己的 AuthenticationStrategy 来实现你自己,你可以使用org.apache.shiro.authc.pam.AbstractAuthenticationStrategy 作为出发点。AbstractAuthenticationStrategy 类自动实现“捆绑”/“聚集”行为,从每一个 Realm 合并结果到一个单一的 AuthenticationInfo 实例。 Realm 的验证顺序需要指出非常重要的一点是,ModularRealmAuthenticator 将与 Realm 实例以迭代的顺序进行交互。在 SecurityManager 中已经配置好了 ModularRealmAuthenticator 对 Realm 实例的访问。当执行一个认证尝试时, 它将会遍历该集合,并对每一个支持提交 AuthenticationToken 的 Realm 调用 Realm 的 getAuthenticationInfo 方 法。","categories":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/tags/shiro/"},{"name":"Subject","slug":"Subject","permalink":"https://lbvs86823.github.io/tags/Subject/"},{"name":"SecurityManager","slug":"SecurityManager","permalink":"https://lbvs86823.github.io/tags/SecurityManager/"},{"name":"Realms","slug":"Realms","permalink":"https://lbvs86823.github.io/tags/Realms/"},{"name":"Authentication","slug":"Authentication","permalink":"https://lbvs86823.github.io/tags/Authentication/"}],"keywords":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}]},{"title":"Shiro 第一章 简介","slug":"shiro/shiro_01","date":"2010-12-15T04:25:17.000Z","updated":"2020-03-20T06:27:43.667Z","comments":true,"path":"2010/12/15/shiro/shiro_01/","link":"","permalink":"https://lbvs86823.github.io/2010/12/15/shiro/shiro_01/","excerpt":"","text":"1.简介：Apache Shiro 是一个强大而灵活的开源安全框架,它干净利落地处理身份认证,授权,企业会话管理和加密。以下是你可以用 Apache Shiro 所做的事情: 验证用户来核实他们的身份 对用户执行访问控制,如: 判断用户是否被分配了一个确定的安全角色 判断用户是否被允许做某事 在任何环境下使用 Session API,即使没有 Web 或 EJB 容器。 在身份验证,访问控制期间或在会话的生命周期,对事件作出反应。 聚集一个或多个用户安全数据的数据源,并作为一个单一的复合用户“视图”。 启用单点登录(SSO)功能。 为没有关联到登录的用户启用”Remember Me”服务。 Shiro 视图在所有应用程序环境下实现这些目标——从最简单的命令行应用程序到最大的企业应用,不强制依赖其 他第三方框架,容器,或应用服务器。当然,该项目的目标是尽可能地融入到这些环境,但它能够在任何环境下立 即可用。 2.特征：Apache Shiro 是一个拥有许多功能的综合性的程序安全框架。 Shiro 把 Shiro 开发团队称为“应用程序的四大基石”——身份验证,授权,会话管理和加密作为其目标。 Authentication:有时也简称为“登录”,这是一个证明用户是他们所说的他们是谁的行为。 Authorization:访问控制的过程,也就是绝对“谁”去访问“什么”。 Session Management:管理用户特定的会话,即使在非 Web 或 EJB 应用程序。 Cryptography:通过使用加密算法保持数据安全同时易于使用。 也提供了额外的功能来支持和加强在不同环境下所关注的方面,尤其是以下这些: Web Support:Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。 Caching:缓存是 Apache Shiro 中的第一层公民,来确保安全操作快速而又高效。 Concurrency:Apache Shiro 利用它的并发特性来支持多线程应用程序。 Testing:测试支持的存在来帮助你编写单元测试和集成测试,并确保你的能够如预期的一样安全。 “Run As”:一个允许用户假设为另一个用户身份(如果允许)的功能,有时候在管理脚本很有用。 “Remember Me”:在会话中记住用户的身份,所以他们只需要在强制时候登录。 3.架构：在最高的概念层次,Shiro 的架构有 3 个主要的概念:Subject,SecurityManager 和 Realms。 Subject 实质上是一个当前执行用户的特定的安全“视图”。鉴于”User” 一词通常意味着一个人,而一个 Subject 可以是一个人,但它还可以代表第三方服务——基本上是当前正与软件进行交互的任何东西。 SecurityManager 是 Shiro 架构的心脏,并作为一种“保护伞”对象来协调内部的安全组件 共同构成一个对象图。然而,一旦 SecurityManager 和 它的内置对象图已经配置给一个应用程序,那么它单独留下来,且应用程序开发人员几乎使用他们所有的时间来处理 Subject API。 Realms:Realms 担当 Shiro 和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相 关的数据如用来执行身份验证(登录)及授权(访问控制)的用户帐户交互时,Shiro 从一个或多个为应用程 序配置的 Realm 中寻找许多这样的东西。 4.Shiro 涉及的核心架构类： Subject(org.apache.shiro.subject.Subject) 当前与软件进行交互的实体(用户,第三方服务,cron job,等等)的安全特定“视图”。 SecurityManager(org.apache.shiro.mgt.SecurityManager)如上所述,SecurityManager 是 Shiro 架构的心脏。它基本上是一个“保护伞”对象,协调其管理的组件以确保 它们能够一起顺利的工作。它还管理每个应用程序用户的 Shiro 的视图,因此它知道如何执行每个用户的安全操作。 Authenticator(org.apache.shiro.authc.Authenticator)Authenticator 是一个对执行及对用户的身份验证(登录)尝试负责的组件。当一个用户尝试登录时,该逻辑 被 Authenticator 执行。Authenticator 知道如何与一个或多个 Realm 协调来存储相关的用户/帐户信息。从这些 Realm 中获得的数据被用来验证用户的身份来保证用户确实是他们所说的他们是谁。 Authentication Strategy(org.apache.shiro.authc.pam.AuthenticationStrategy)如果不止一个 Realm 被配置,则 AuthenticationStrategy 将会协调这些 Realm 来决定身份认证尝试成功或 失败下的条件(例如,如果一个 Realm 成功,而其他的均失败,是否该尝试成功? 是否所有的 Realm 必须成功?或只有第一个成功即可?)。 Authorizer(org.apache.shiro.authz.Authorizer)Authorizer 是负责在应用程序中决定用户的访问控制的组件。它是一种最终判定用户是否被允许做某事的机制。 与 Authenticator 相似,Authorizer 也知道如何协调多个后台数据源来访问角色恶化权限信息。Authorizer 使用 该信息来准确地决定用户是否被允许执行给定的动作。 SessionManager(org.apache.shiro.session.SessionManager)SessionManager 知道如何去创建及管理用户 Session 生命周期来为所有环境下的用户提供一个强健的 Session 体验。这在安全框架界是一个独有的特色——Shiro 拥有能够在任何环境下本地化管理用户 Session 的能力, 即使没有可用的 Web/Servlet 或 EJB 容器,它将会使用它内置的企业级会话管理来提供同样的编程体验。 SessionDAO 的存在允许任何数据源能够在持久会话中使用。 SessionDAO(org.apache.shiro.session.mgt.eis.SessionDAO) SesssionDAO 代表 SessionManager 执行 Session 持久化(CRUD)操作。这允许任何数据存储被插入到会 话管理的基础之中。 CacheManager(org.apahce.shiro.cache.CacheManager)CacheManager 创建并管理其他 Shiro 组件使用的 Cache 实例生命周期。因为 Shiro 能够访问许多后台数据源, 由于身份验证,授权和会话管理,缓存在框架中一直是一流的架构功能,用来在同时使用这些数据源时提高 性能。任何现代开源和/或企业的缓存产品能够被插入到 Shiro 来提供一个快速及高效的用户体验。 Cryptography(org.apache.shiro.crypto.*)Cryptography 是对企业安全框架的一个很自然的补充。Shiro 的 crypto 包包含量易于使用和理解的 cryptographic Ciphers,Hasher(又名 digests)以及不同的编码器实现的代表。所有在这个包中的类都被精心地设计以易于 使用和易于理解。任何使用 Java 的本地密码支持的人都知道它可以是一个难以驯服的具有挑战性的动物。Shiro 的 cryptoAPI 简化了复杂的 Java 机制,并使加密对于普通人也易于使用。 Realms(org.apache.shiro.realm.Realm)如上所述,Realms 在 Shiro 和你的应用程序的安全数据之间担当“桥梁”或“连接器”。当它实际上与安全 相关的数据如用来执行身份验证(登录)及授权(访问控制)的用户帐户交互时,Shiro 从一个或多个为应用 程序配置的 Realm 中寻找许多这样的东西。你可以按你的需要配置多个 Realm(通常一个数据源一个 Realm), 且 Shiro 将为身份验证和授权对它们进行必要的协调。 应用程序的 SecurityManager 执行安全操作并管理所有应用程序用户的状态。在 Shiro 的默认 SecurityManager 实现中,这包括: Authentication Authorization Session Management Cache Management Realm coordination Event propagation “Remember Me” Services Subject creation Logout以及更多。但这是许多功能来尝试管理一个单一的组件。而且,使这些东西灵活而又可定制将会是非常困难的,如果一切都集中到一个单一的实现类。","categories":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/tags/shiro/"},{"name":"Subject","slug":"Subject","permalink":"https://lbvs86823.github.io/tags/Subject/"},{"name":"SecurityManager","slug":"SecurityManager","permalink":"https://lbvs86823.github.io/tags/SecurityManager/"},{"name":"Realms","slug":"Realms","permalink":"https://lbvs86823.github.io/tags/Realms/"}],"keywords":[{"name":"shiro","slug":"shiro","permalink":"https://lbvs86823.github.io/categories/shiro/"}]},{"title":"Jetty 嵌入式开发","slug":"server/jetty","date":"2010-12-10T03:25:11.000Z","updated":"2020-03-20T06:27:43.665Z","comments":true,"path":"2010/12/10/server/jetty/","link":"","permalink":"https://lbvs86823.github.io/2010/12/10/server/jetty/","excerpt":"","text":"Jetty 嵌入式开发概述Jetty 有一个标语 “不要部署你的应用在Jetty上，部署Jetty在你的应用中”；以嵌入式模式运行Jetty，这意味着把HTTP模块放入到你的应用中，而不是把你的应用放入到HTTP服务中。参考文档 为了嵌入Jetty服务，通常需要执行以下步骤： 创建一个服务 添加和配置连接器 添加和配置处理器 添加和配置Servlet， Webapp 到处理器 启动服务 等待(join 服务防止主线程退出) 创建一个服务实例化和运行一个最简单的Jetty服务： public class SimpleServer { public static void main(String[] args) { try { Server server = new Server(8080); server.start(); server.join(); } catch (InterruptedException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 在端口8080上运行一个HTTP服务，这个服务没什么实际用处，因为它没有任何处理器，对于每一个请求只是返回一个404错误。 编写处理器为了生成请求响应，Jetty要求在服务上设置一个Handler，一个处理器可能： 检查和修改HTTP请求 生成完整的HTTP详情 调用其他的处理器(比如：HandlerWrapper) 选择一个或者多个处理器调用(不如：HandlerCollection) 比如编写显示一个简单的Hello World 的处理器： public class HelloHandler extends AbstractHandler { @Override public void handle(String target, Request jtyRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setStatus(HttpServletResponse.SC_OK); jtyRequest.setHandled(true); response.getWriter().println(&quot;&lt;h1&gt;hello, world!&lt;/h1&gt;&quot;); } } 传递给 handle 方法的参数包括： target 请求的目标， 它可以是一个URI或者命名分发器的名称 jtyRequest Jetty可变请求对象，它总是解包的 request 不可变的请求对象，它可能已经被封装 response 响应，它可能已经被封装 处理器设置了请求的状态，内容类型，在使用writer生成请求体之前标注请求已经处理（后续就不在处理了） public class OneHandlerServer { public static void main(String[] args) { try { Server server = new Server(8080); server.setHandler(new HelloHandler()); server.start(); server.join(); } catch (InterruptedException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 复杂的请求处理通常使用多个处理器构建，你能查看Jetty 的org.eclipse.jetty.server.handler包种有哪些可用的处理器。 配置连接器你可以为服务设置一个或者多个连接器，你能够对每一个连接器进行详细配置比如端口, buffer大小, timeout超时时间等。 public class ManyConnectorsServer { public static void main(String[] args) { try { Server server = new Server(8080); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(8080); connector.setLowResourcesMaxIdleTime(30000); connector.setRequestHeaderSize(8192); SelectChannelConnector adminConnector = new SelectChannelConnector(); adminConnector.setHost(&quot;127.0.0.1&quot;); adminConnector.setPort(8888); adminConnector.setThreadPool(new QueuedThreadPool(20)); adminConnector.setName(&quot;admin&quot;); SslSelectChannelConnector ssl_connector = new SslSelectChannelConnector(); String jetty_home = System.getProperty(&quot;jetty.home&quot;, &quot;/Users/libing/Downloads/jetty-distribution-7.6.16.v20140903&quot;); System.setProperty(&quot;jetty.home&quot;, jetty_home); ssl_connector.setPort(8443); SslContextFactory scf = ssl_connector.getSslContextFactory(); scf.setKeyStore(jetty_home + &quot;/etc/keystore&quot;); scf.setKeyStorePassword(&quot;OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4&quot;); scf.setKeyManagerPassword(&quot;OBF:1u2u1wml1z7s1z7a1wnl1u2g&quot;); server.setConnectors(new Connector[]{connector, adminConnector, ssl_connector}); server.setHandler(new HelloHandler()); server.start(); server.join(); } catch (InterruptedException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 现在你可以通过下面的三种方式进行访问了： http://localhost:8080/ http://localhost:8888/ https://localhost:8443/ 理解 Handler Collections, Wrappers and Scopes复杂的请求处理一般都要构建于多个处理器，它们可以通过许多中方法进行组合: Handler Collection :依次顺序调用每一个处理器的一个处理器集合，用于处理响应的统计和日志非常的有用 Handler List : 依次顺序调用每一个处理器(除非有一个处理器有异常抛出, 或者 response被提交，或者 request.isHandled() 返回true)的一个处理器集合，用于有条件的处理一个请求非常合适。 Handler Wrapper : 链式处理器的基础类，用于切面编程，比如一个标准的web application 实现了一个链式的context, session, security, servlet handlers. Context Handler Collection : 使用最长的一个请求URI(contextPath),选择一个特殊的 ContextHandler来处理请求 配置一个文件服务public class FileServer { public static void main(String[] args) { try { Server server = new Server(8080); ResourceHandler resource_handler = new ResourceHandler(); resource_handler.setDirectoriesListed(true); resource_handler.setWelcomeFiles(new String[]{&quot;index.html&quot;}); resource_handler.setResourceBase(&quot;.&quot;); HandlerList handlers = new HandlerList(); handlers.setHandlers(new Handler[]{resource_handler, new DefaultHandler()}); server.setHandler(handlers); server.start(); server.join(); } catch (InterruptedException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 用XML文件配置一个文件服务&lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE Configure PUBLIC “-//Jetty//Configure//EN” “http://www.eclipse.org/jetty/configure.dtd&quot;&gt; &lt;Configure id=&quot;FileServer&quot; class=&quot;org.eclipse.jetty.server.Server&quot;&gt; &lt;Call name=&quot;addConnector&quot;&gt; &lt;Arg&gt; &lt;New class=&quot;org.eclipse.jetty.server.nio.SelectChannelConnector&quot;&gt; &lt;Set name=&quot;port&quot;&gt;8080&lt;/Set&gt; &lt;/New&gt; &lt;/Arg&gt; &lt;/Call&gt; &lt;Set name=&quot;handler&quot;&gt; &lt;New class=&quot;org.eclipse.jetty.server.handler.HandlerList&quot;&gt; &lt;Set name=&quot;handlers&quot;&gt; &lt;Array type=&quot;org.eclipse.jetty.server.Handler&quot;&gt; &lt;Item&gt; &lt;New class=&quot;org.eclipse.jetty.server.handler.ResourceHandler&quot;&gt; &lt;Set name=&quot;directoriesListed&quot;&gt;true&lt;/Set&gt; &lt;Set name=&quot;welcomeFiles&quot;&gt; &lt;Array type=&quot;String&quot;&gt;&lt;Item&gt;index.html&lt;/Item&gt;&lt;/Array&gt; &lt;/Set&gt; &lt;Set name=&quot;resourceBase&quot;&gt;.&lt;/Set&gt; &lt;/New&gt; &lt;/Item&gt; &lt;Item&gt; &lt;New class=&quot;org.eclipse.jetty.server.handler.DefaultHandler&quot;&gt; &lt;/New&gt; &lt;/Item&gt; &lt;/Array&gt; &lt;/Set&gt; &lt;/New&gt; &lt;/Set&gt; &lt;/Configure&gt; 运行一个文件服务从xml文件加载配置： public class FileWithXmlServer { public static void main(String[] args) throws Exception { Resource fileserver_xml = Resource.newSystemResource(&quot;fileserver.xml&quot;); XmlConfiguration configuration = new XmlConfiguration(fileserver_xml.getInputStream()); Server server = (Server) configuration.configure(); server.start(); server.join(); } } 设置 ContextsContextHandler 是一个HandlerWapper 只对与配置的contextPath相匹配的一个URI前缀的请求作出相应。可以对Context设置一些适合的特性如下： A Thread Context classloader. A set of attributes A set of init parameters A resource base (aka document root) A set of virtual host names 请求不匹配的他将不会处理，以下代码是为HelloHandler 设置context path, classloader public class OneContextServer { public static void main(String[] args) throws Exception { Server server = new Server(8080); ContextHandler context = new ContextHandler(); context.setContextPath(&quot;/hello&quot;); context.setResourceBase(&quot;.&quot;); context.setClassLoader(Thread.currentThread().getContextClassLoader()); server.setHandler(context); context.setHandler(new HelloHandler()); server.start(); server.join(); } } 创建一个ServletsServlets 是一个提供处理HTTP请求应用逻辑的标准方法。 public class HelloServlet extends HttpServlet { private String greeting = &quot;Hello World&quot;; public HelloServlet() { } public HelloServlet(String greeting) { this.greeting = greeting; } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); response.setStatus(HttpServletResponse.SC_OK); response.getWriter().println(&quot;&lt;h1&gt;&quot; + greeting + &quot;&lt;/h1&gt;&quot;); response.getWriter().println(&quot;session=&quot; + request.getSession(true).getId()); } } 设置一个ServletContextServletContextHandler 是一个专门用于支持标准Servlet的ContextHandler。下面显示了用ServletContextHandler注册的3个实例化helloworld Servlet。 public class OneServletContextServer { public static void main(String[] args) throws Exception { Server server = new Server(8080); ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); context.setContextPath(&quot;/&quot;); server.setHandler(context); context.addServlet(new ServletHolder(new HelloServlet()), &quot;/*&quot;); context.addServlet(new ServletHolder(new HelloServlet(&quot;Buongiorno Mondo&quot;)), &quot;/it/*&quot;); context.addServlet(new ServletHolder(new HelloServlet(&quot;Bonjour le Monde&quot;)), &quot;/fr/*&quot;); server.start(); server.join(); } } 设置一个Web Application Context一个 Web Application Context 是个使用标准布局和web.xml配置servlet，filter,和其他一些特征的 许许多多 ServletContextHandler， public class OneWebApp { public static void main(String[] args) throws Exception { String jetty_home = System.getProperty(&quot;jetty.home&quot;, &quot;..&quot;); Server server = new Server(8080); WebAppContext webapp = new WebAppContext(); webapp.setContextPath(&quot;/&quot;); webapp.setWar(jetty_home + &quot;/webapps/test.war&quot;); server.setHandler(webapp); server.start(); server.join(); } } 在开发的时候，你应该还没有把你的应用打包成一个WAR的文件，这时候你可以用源代码的方式运行如下： public class OneWebAppUnassembled { public static void main(String[] args) throws Exception { Server server = new Server(8080); WebAppContext context = new WebAppContext(); //context.setDescriptor(webapp+&quot;/WEB-INF/web.xml&quot;); context.setResourceBase(&quot;../test-jetty-webapp/src/main/webapp&quot;); context.setContextPath(&quot;/&quot;); context.setParentLoaderPriority(true); server.setHandler(context); server.start(); server.join(); } }","categories":[{"name":"server","slug":"server","permalink":"https://lbvs86823.github.io/categories/server/"}],"tags":[{"name":"jetty","slug":"jetty","permalink":"https://lbvs86823.github.io/tags/jetty/"},{"name":"servlet","slug":"servlet","permalink":"https://lbvs86823.github.io/tags/servlet/"}],"keywords":[{"name":"server","slug":"server","permalink":"https://lbvs86823.github.io/categories/server/"}]},{"title":"Linux VI 命令详解","slug":"linux/linux_vi","date":"2010-10-07T08:41:24.000Z","updated":"2020-03-20T06:27:43.651Z","comments":true,"path":"2010/10/07/linux/linux_vi/","link":"","permalink":"https://lbvs86823.github.io/2010/10/07/linux/linux_vi/","excerpt":"","text":"一. vi的三种操作模式: 命令模式(Command mode): 控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入 Insert mode下，或者到 Last line mode。 插入模式(Insert mode): 唯有在该模式下，才可做文字数据输入，按Esc等可回到Comand mode。 底线命令模式(Last line mode): 将储存文件或离开编辑器，也可设置编辑环境，如寻找字符串、列出行号等。 二. 进入vi的命令：vi fileName 打开或新建文件，并将光标置于第一行首 vi +n fileName 打开文件，并将光标置于第n行首 vi + fileName 打开文件，并将光标置于最后一行首 vi +/pattern fileName 打开文件，并将光标置于第一个与pattern匹配的串处 vi -r fileName 在上次正用vi编辑时发生系统崩溃，恢复fileName vi fileName....fileName 打开多个文件，依次进行编辑 三. 命令模式(Command mode)下的常用操作：(1) 光标的移动： h、j、k、l 分别控制光标左、下、上、右移一格 Ctrl+G 在状态栏显示当前进度 num+G 移动到第num行，例：15G Ctrl+B 屏幕往后移动一页 [常用] Ctrl+F 屏幕往前移动一页 [常用] Ctrl+U 屏幕往后移动半页 Ctrl+D 屏幕往前移动半页 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 gg 移动文章的开头 [常用] G 移动到文章的最后 [常用] 0[数字零] 移到光标所在行的开头位置 [常用] $ 移到光标所在行的行尾 [常用] w 光标跳到下个word的开头 [常用] e 光标跳到下个word的字尾 b 光标回到上个word的开头 (2) 复杂操作： 同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中 ---- vi file1 file2 ---- yy 在文件1的光标处拷贝所在行 ---- :n 切换到文件2 (n=next) ---- p 在文件2的光标所在处粘贴所拷贝的行 ---- :n 切换回文件1 替换文件中的路径 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。 (3) 选项设置操作： all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位(Ctrl+I)和行尾标志（$) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示NO write信息 nomagic 允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan 禁止vi在搜索到达文件两端时，又从另一端开始 mesg 允许vi显示其他用户用write写到自己终端上的信息 (4) 删除，复制，粘贴操作： x,X : 在一行中，x为向后删除一个字符（相当于del键），X为向前删除一个字符（相当于backspace键) dd : 删除光标所在的那一整行。 ndd : n 为数字。从光标开始，删除向下n列。 yy : 复制光标所在的那一行。 nyy : n为数字。复制光标所在的向下n行。 p,P : p 为将已复制的数据粘贴到光标的下一行，P则为贴在光标的上一行。 u : 复原前一个操作 CTRL + r : 重做上一个操作。 小数点&apos;.&apos;: 重复前一个动作。 yw：将光标所在处到字尾的字符复制到缓冲区中。 p：将缓冲区内的字符粘贴到光标所在位置(指令&apos;yw&apos;与&apos;p必须搭配使用)。 yy：复制光标所在行。[超常用] p：复制单行到您想粘贴之处。(指令&apos;yy&apos;与&apos;p&apos;必须搭配使用) #yy：如：6yy表示拷贝从光标所在的该行往下数6行之文字。[常用] p: 复制多行到您想粘贴之处。(指令&apos;#yy&apos;与&apos;p&apos;必须搭配使用) ayy：将复制行放入buffer a, vi提供buffer功能，可将常用的数据存在buffer ap：将放在buffer a的数据粘贴。 b3yy：将三行数据存入buffer b。 b3p：将存在buffer b的资料粘贴 (5) 删除操作： do 删至行首 d$ 删至行尾 ndd 删除当前行及其后n-1行 Ctrl+u 撤销输入方式下所输入的文本 x或X 删除一个字符，x删除光标后的，而X删除光标前的 ndw或ndW 删除光标处开始及其后的n-1个 (6) 寄存器操作： &quot;?nyy 将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字 &quot;?nyw 将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字 &quot;?nyl 将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字 &quot;?p 取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字 ndd 将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。 shift+zz 保存并退出，功能同:wq [常用] 四. 插入模式(Insert mode)下的常用操作：切换至 Insert mode 编辑文件在 Command mode 下按 ‘i’、‘a’、‘o’、‘O’ 都可进入 Insert mode ；Insert mode 切换至 Command mode，按 Esc 键 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符，直至按ESC键 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 nCC 修改指定数目的行 ncw 或 nCW 修改指定数目的字 五. 底线命令模式(Last line mode)下的常用操作：在Command mode下，可按 “:”、 “/”、 “?” 键都可以进入 Last line mode 模式 (1) 行号相关操作： :set nu 显示行号 :set nonu 隐藏行号 :num&lt;Enter&gt; 跳到第num行 (2) 查找与替换相关操作： /pattern&lt;Enter&gt; 向下查找pattern匹配字符串 [按n查找下一个匹配的字符串，按N查找上一个匹配的字符串] ?pattern&lt;Enter&gt; 向上查找pattern匹配字符串 [按n查找下一个匹配的字符串，按N查找上一个匹配的字符串] :s/w1/w2/g 将当前行中所有w1均用w2替代 [g : 表示全部取代不必确认] :n1,n2s/w1/w2/g 将第n1至n2行中所有w1均用w2替代 [g : 表示全部取代不必确认] :g/w1/s//w2/g 将文件中所有w1均用w2替换 [g : 表示全部取代不必确认] (3) 退出VI相关操作： :w 保存 :w fileName 另存为: fileName :n1,n2 w fileName 将文件中的n1到n2行的内容写入到文件fileName :wq 保存并退出 [常用] :q 退出,不存储 :q! 强制退出,不存储 [常用] :n1,n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下 :n1,n2 m n3 将n1行到n2行之间的内容移至到第n3行下 :n1,n2 d 将n1行到n2行之间的内容删除 :!command 执行shell命令command :r!command 将命令command的输出结果放到当前行 :n1,n2 w!command 将文件中n1行至n2行的内容作为command的输入并执行之 :w!command 将整个文件内容作为command的输入并执行之","categories":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/tags/linux/"},{"name":"vi","slug":"vi","permalink":"https://lbvs86823.github.io/tags/vi/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}]},{"title":"JQuery开发插件的机种方式讨论","slug":"js/jquery/jueryPlugin","date":"2010-09-27T12:43:44.000Z","updated":"2020-03-20T06:27:43.630Z","comments":true,"path":"2010/09/27/js/jquery/jueryPlugin/","link":"","permalink":"https://lbvs86823.github.io/2010/09/27/js/jquery/jueryPlugin/","excerpt":"","text":"插件开发的三种方式： 通过$.extend(object)来扩展JQuery(类级别的插件开发)：这种方式的扩展是给jQuery添加新的全局函数，相当于给jQuery类本身添加方法，jQuery的全局函数是属于jQuery命名空间的数(比如：$.AJAX())。 通过$.fn向JQuery添加新的方法(对象级别的插件开发)：这种方式的扩展是给jQuery的原型增加方法，以后jQuery的对象对象都可以使用，至于为什么你可以参考jQuery源代码中可以发现这样的代码：jQuery.fn = jQuery.prototype = { //代码段 }; 通过$.widget()应用JQuery UI的部件工厂方式创建 1.$.extend(object)方式这种方式是最简单的，仅仅是在JQuery命名空间上添加了一个函数。比如：定义一个log()方法用于打印日志: $.extend({ log: function(msg){ if(console &amp;&amp; msg){ console.log(msg); } } }); 当然，你也可以直接使用给jQuery类添加一个新的全局函数的方式： jQuery.log = function(msg){ if(console &amp;&amp; msg){ console.log(msg); } }; 直接使用如下方式进行调用： $.log(&quot;用于打印日志信息!&quot;); 采用这种方式有一个致命的缺陷就是它是绑定在Jquery对象上的方法，无法利用Jquery选择器来把已经选择的Dom元素应用上你自己写的插件。所以一般都采用下面的这种方式开发插件。 2.$.fn方式首页看下这种方式的基本语法： $.fn.pluginName = function(){ // 你的插件代码 ... } 可以看出，其实就是向jQuery的fn对象上面添加一个方法。这里就顺便说说，为什么第一种方式我叫做添加一个函数，而这里我又说是添加一个方法呢？我理解上看，函数一般就是比较孤立(独立)的一些功能点，而方法一般就是必须要先存在一个对象的前提下，即只有在这个对象的身上才能调用这个方法。 比如我需要将所有选中的Dom元素的高度设置为 350px，那么我可以写一个这样的插件： $.fn.setHeight = function(){ //在这里面,this指的是用jQuery选中的元素 this.css(&apos;height&apos;, &apos;350px&apos;); } 注意这里使用的是this,而不是$(this) 因为编写插件函数内部的this就直接代表了jQuery选择器过滤出来的jQuery对象了。 如果我要使div标签的ID=“test”的高度设置成350px，那么直接使用如下方式进行调用： $(&quot;#test&quot;).setHeight(); 但是我们都知道jQuery的方法有一个很重要的特点就是支持链式调用，选择好Dom元素后可以不断的调用其他方法。如果要让我们的插件支持这种链式调用，只需要return一下即可。 $.fn.setHeight = function(){ this.css(&apos;height&apos;, &apos;350px&apos;); this.each(function(){ //而在这里面,this指的是被遍历的每个dom元素. $(this).append(&apos;&lt;span&gt;这个div被操作了&lt;/span&gt;&apos;); }); return this; } 接着我们就可以进行如下的链式的调用了： $(&quot;#test&quot;).setHeight().addClass(&quot;green&quot;); 你也许会问上面的高度不可以让我随意改吗？很显然是可以的，下面就让我们来看下插件一般都是怎么样接受参数的。在处理插件参数的方式上，通常都使用Jquery的extend方法，就是上面我们提到过的一种写插件的方式，只不过上面是给extend方法传递单个对象的情况下，这个对象会合并到Jquery身上去，所以我们就可以在jQuery身上调用新合并对象里面包含的方法了。 而这里有一点不同的是，当给extend方法传递两个及其以上的参数时，它会将所有的参数对象合并到第一个里面去，同时，如果对象中有同名属性时，合并的时候后面的会覆盖前面的。 利用这种特性，我们可以在定义插件里面写一个对象用来保存一组参数的默认值，同时将接收来的参数对象合并到默认的对象上面去，这样我们就很好的实现了插件的定制功能(用户指定了参数的使用指定的参数，没有指定的使用默认参数值)。 现在我们对上面的插件进行改进，另外让它在增加一个可以设置背景色的一个功能： $.fn.setHeight = function(options){ var default = { &quot;height&quot;: &quot;50px&quot;, &quot;bgcolor&quot; : &quot;red&quot; } var setting = $.extend(default, options); return this.css(setting); } 如果我要使div标签的ID=“test”的高度设置成350px，背景为黑色，那么直接使用如下方式进行调用： $(&quot;#test&quot;).setHeight({&quot;height&quot;:&quot;350px&quot;, &quot;bgcolor&quot;:&quot;black&quot;}); 我们应该还可以考虑到，某些默认值是插件内部使用的(私有变量)，我不希望用户设置它，这该怎么弄？有人可能会说在插件内部用的，还不好办，直接单独定义一个对象来保存这些(私有变量)在内部使用就可以了，没错这样是没问题的，但是如果插件很复杂的时候，你到处定义你的配置就会造成很混乱，不方便维护，也不够清晰。一个好的做法是将一个新的空对象做为$.extend的第一个参数，defaults和用户传递的参数对象紧随其后，这样做的好处是所有值被合并到这个空对象上，保护了插件里面的默认值。 $.fn.setHeight = function(options){ var default = { &quot;height&quot;: &quot;50px&quot;, &quot;bgcolor&quot; : &quot;red&quot; } //将一个空对象作为第一个参数，让原始的默认值不受用户传入参数的影响， //在插件内部还可以使用这些默认值。 var setting = $.extend({}, default, options); return this.css(setting); } #######优化插件的作用域范围： 不仅仅是jQuery插件的开发，我们在写任何JS代码时都应该注意的一点是不要污染全局命名空间。因为随着你代码的增多，如果有意无意在全局范围内定义一些变量的话，最后很难维护，也容易跟别人写的代码有冲突。 比如你在代码中向全局window对象添加了一个变量status用于存放状态，同时页面中引用了另一个别人写的库，也向全局添加了这样一个同名变量，最后的结果肯定不是你想要的。所以不到万不得已，一般我们不会将变量定义成全局的。 一个好的做法是始终用自调用匿名函数(闭包)包裹你的代码，这样就可以完全放心，安全地将它用于任何地方了，绝对没有冲突。另外还有一个好处就是，自调用匿名函数里面的代码会在第一时间执行，页面准备好过后，上面的代码就将插件准备好了，以方便在后面的代码中使用插件。 我们知道JavaScript中无法用花括号方便地创建作用域，但函数却可以形成一个作用域，域内的代码是无法被外界访问的。如果我们将自己的代码放入一个函数中，那么就不会污染全局命名空间，同时不会和别的代码冲突。 所以我们对上面的代码进行如下的优化： (function(){ $.fn.setHeight = function(options){ var default = { &quot;height&quot;: &quot;50px&quot;, &quot;bgcolor&quot; : &quot;red&quot; } //将一个空对象作为第一个参数，让原始的默认值不受用户传入参数的影响， //在插件内部还可以使用这些默认值。 var setting = $.extend({}, default, options); return this.css(setting); } })(); #######优化插件中用到的全局变量： 如果再考虑到其他一些因素，比如我们将这段代码放到页面后，前面别人写的代码没有用分号结尾，或者前面的代码将window, undefined等这些系统变量或者关键字修改掉了，正好我们又在自己的代码里面进行了使用，那结果也是不可预测的，这不是 我们想要的。 这里就提出另一个插件编写过程中的好习惯，将系统变量以参数的形式传递到我们的代码中，这样就可以安全地使用而不用担心得到的是一个被修改后的值。同时这也是使用自调用匿名函数的带来的另一个好处。 最后我们得到一个非常安全结构良好的代码： ;(function($, window, document){ $.fn.setHeight = function(options){ var default = { &quot;height&quot;: &quot;50px&quot;, &quot;bgcolor&quot; : &quot;red&quot; } //将一个空对象作为第一个参数，让原始的默认值不受用户传入参数的影响， //在插件内部还可以使用这些默认值。 var setting = $.extend({}, default, options); return this.css(setting); } })(jQuery, window, document, undefined); 我们在参数里传递了真实的undefined，但接收的时候参数列表里没接收，既然没接收，那我们在代码里使用的undefined就是实际的undefined，因为该参数空缺，一个空缺的参数的值默认是undefined的。 因此上面的代码优化后可以得到如下的结果： ;(function($, window, document){ $.fn.setHeight = function(options){ var default = { &quot;height&quot;: &quot;50px&quot;, &quot;bgcolor&quot; : &quot;red&quot; } //将一个空对象作为第一个参数，让原始的默认值不受用户传入参数的影响， //在插件内部还可以使用这些默认值。 var setting = $.extend({}, default, options); return this.css(setting); } })(jQuery, window, document, undefined); #######下面在介绍些常用的编写插件的规则：jQuery 团队建立了许多希望插件作者都能遵守的通用规则，为插件用户创建一个通用而可信的环境。因此，列出这些规则，并且在插件的每一步都尽量遵守这些规则： 文件命名为 “jquery.&lt;pluginName&gt;.js”这是有道理的，因为您希望用户查看文件时立即知道这是一个 jQuery 插件以及这是哪个插件。 所有新方法都附加到 jQuery.fn 对象，所有新功能都附加到 jQuery 对象 “this” 用于引用 jQuery 对象这有利于插件作者的编写，它让所有插件作者在引用 “this” 时都知道将从jQuery 收到哪个对象。 插件中定义的所有方法/函数的末尾都必须带有一个 “;”（分号），否则将不利于代码的最小化。因为这是最小化 JavaScript 文件的最佳实践，大于最小值会很糟糕，您的插件有可能很快就被抛弃。 除有特别注明外，所有方法都必须返回 jQuery 对象 jQuery 方法的顺序链 (daisy-chaining) 非常著名，如果您编写打破链条的插件，它就一定会 “打破链条”。 您应该总是使用 this.each() 迭代匹配的元素，这是一种可靠而有效地迭代对象的方式。出于性能和稳定性考虑，他们推荐所有的方法都使用它迭代匹配的元素。 总是在插件代码中使用 “jQuery” 而不是 “$” 这很重要，它使与 “$” 有冲突的用户（那些使用另一个JavaScript 库的用户）能够使用 “var JQ = jQuery.noConflict();” 函数更改他们的 jQuery 别名（pseudonym）。但是，在我查看许多插件时，我发现该规则常常得不到遵守，这太不幸了。如果开发人员需要更改 jQuery 别名，那么很可能意味着该插件要被弃用了。 ########相关参考：jQuery官网插件学习中心：http://learn.jquery.com/pluginsjQuery官网插件中心：http://plugins.jquery.comjQuery官网插件发布指南：http://plugins.jquery.com/docs/publishGoogle Web Developer Tool : https://developers.google.com/closure","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/tags/javaScript/"},{"name":"jquery","slug":"jquery","permalink":"https://lbvs86823.github.io/tags/jquery/"}],"keywords":[{"name":"javaScript","slug":"javaScript","permalink":"https://lbvs86823.github.io/categories/javaScript/"}]},{"title":"redis入门之hashes数据类型(三)","slug":"redis/redis_hash","date":"2010-07-28T13:11:47.000Z","updated":"2020-03-20T06:27:43.663Z","comments":true,"path":"2010/07/28/redis/redis_hash/","link":"","permalink":"https://lbvs86823.github.io/2010/07/28/redis/redis_hash/","excerpt":"","text":"##一，hashes数据类型介绍 Redis hash是一个string类型的field和value的映射表。它的添加、删除操作都是0(1)( 平均)。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。 将一个对象存储在hash类型中会占用更少的 内存,并且可以更方便的存取整个对象。 ##二，hashes数据类型相关操作 ###【注意操作命令在链接到服务器上的客户端上面都是不区分大小写的】 ###set作用： 设置key对应的值为string类型的value语法： set key value返回值：设置成功返回 OK注意： 对一个key重复设置，会被覆盖。样例： 设置key1的值为100 127.0.0.1:6379&gt; set key1 100 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; set key1 200 OK 127.0.0.1:6379&gt; get key1 &quot;200&quot; ###setnx作用： 设置key对应的值为string类型的value,如果key已经存在,则不会再设置(nx是not exist的意思) 语法： setnx key value返回值：设置成功返回 1; 设置失败(该key对应的值已经存在)返回 0；注意： 对一个key重复设置，不会被设置成功。样例： 设置key1的值为100 127.0.0.1:6379&gt; get key1 &quot;200&quot; 127.0.0.1:6379&gt; setnx key1 300 (integer) 0 127.0.0.1:6379&gt; get key1 &quot;200&quot; 127.0.0.1:6379&gt; setnx key2 300 (integer) 1 127.0.0.1:6379&gt; get key2 &quot;300&quot; ###setex作用： 设置key对应的值为string类型的value,并 指定此键值对应的有效期(ex是expires的意思)。 语法： setex key time value返回值：设置成功返回 OK,注意： 有效期的单位是秒，如果对相同的key重复设置时间和值都会被覆盖。样例： 添加一个 key3=500 的键值对,并指定有效期为10秒  127.0.0.1:6379&gt; setex key3 10 500 OK 127.0.0.1:6379&gt; get key3 &quot;500&quot; 127.0.0.1:6379&gt;(等待10秒过后，再查询该key4对应的值) 127.0.0.1:6379&gt; get key3 (nil) ###setrange作用： 替换指定key对应value值的指定位置开始替换字符串。 语法： setrange key pos replaceValue返回值：设置成功返回替换后的对应值的字符串长度注意： pos为开始替换的位置(从0开始的)，如果原字符串被替换后，尾部还有字符没有替换，会原样保留；如果key不存在或者pos越界则会先对其设置值，然后再补位。样例： 将key=redis@163.com 的邮箱替换成google的邮箱 127.0.0.1:6379&gt; set key3 redis@163.com OK 127.0.0.1:6379&gt; get key3 &quot;redis@163.com&quot; 127.0.0.1:6379&gt; setrange key3 4 google.com.hk (integer) 18 127.0.0.1:6379&gt; get key3 &quot;redis@google.com.hk&quot; 127.0.0.1:6379&gt; set key4 redis@163.com.shawxyztyuig OK 127.0.0.1:6379&gt; get key4 &quot;redis@163.com.shawxyztyuig&quot; 127.0.0.1:6379&gt; setrange key4 4 google.com.hk (integer) 26 127.0.0.1:6379&gt; get key4 &quot;redigoogle.com.hkwxyztyuig&quot; 127.0.0.1:6379&gt; setrange ke78 4 hhjj (integer) 8 127.0.0.1:6379&gt; get ke78 &quot;\\x00\\x00\\x00\\x00hhjj&quot; 127.0.0.1:6379&gt; set key20 50 OK 127.0.0.1:6379&gt; setrange key20 3 77 (integer) 5 127.0.0.1:6379&gt; get key20 &quot;50\\x0077&quot; ###mset作用： 一次设置多个key的值(批量设置)。 语法： mset key1 value1 key2 value2 … keyN valueN返回值：设置成功返回 OK,表示都设置成功， 设置失败返回 0, 表示没有任何值被设置注意： 多个key-value对设置时，有一个不成功，都不成功;重复设置相同key的值会被覆盖。样例： 127.0.0.1:6379&gt; mset key1 100 key2 200 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; get key2 &quot;200&quot; 127.0.0.1:6379&gt; mset key2 250 key3 400 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; get key2 &quot;250&quot; 127.0.0.1:6379&gt; get key3 &quot;400&quot; ###msetnx作用： 一次设置多个key的值(批量设置),但是不会覆盖已经存在的key. 语法： msetnx key1 value1 key2 value2 … keyN valueN返回值：设置成功返回 OK,表示都设置成功， 设置失败返回 0, 表示没有任何值被设置注意： 多个key-value对设置时，有一个不成功，都不成功;重复设置相同key的值不会被设置成功。样例： 127.0.0.1:6379&gt; msetnx key6 400 key7 500 (integer) 1 127.0.0.1:6379&gt; get key6 &quot;400&quot; 127.0.0.1:6379&gt; get key7 &quot;500&quot; 127.0.0.1:6379&gt; msetnx key7 550 key8 800 (integer) 0 127.0.0.1:6379&gt; get key6 &quot;400&quot; 127.0.0.1:6379&gt; get key7 &quot;500&quot; 127.0.0.1:6379&gt; get key8 (nil) ###get作用： 获取key对应的string值, 如果key不存在返回 nil。语法： get key返回值：获取成功返回 对应key的value,失败返回nil注意：样例： 127.0.0.1:6379&gt; get key9 (nil) 127.0.0.1:6379&gt; set key9 900 OK 127.0.0.1:6379&gt; get key9 &quot;900&quot; ###getset作用： 设置key的值,并返回key的旧值。语法： getset key value返回值：获取成功返回 对应key的原来的oldValue,如果原来没有值就返回 nil注意：样例： 127.0.0.1:6379&gt; getset key10 10 (nil) 127.0.0.1:6379&gt; get key10 &quot;10&quot; 127.0.0.1:6379&gt; getset key10 100 &quot;10&quot; 127.0.0.1:6379&gt; get key10 &quot;100&quot; ###getrange作用： 获取key的value值的子字符串。语法： getrange key startPos endPos返回值：获取成功返回 对应key的value的字串,失败返回nil注意： endPos 为-1时表示value字符串长度的最后一位,大于最大长度时，就取最大长度； startPos为负数的时候表示从字符串的尾部开始数数。样例： 127.0.0.1:6379&gt; set key15 123456789 OK 127.0.0.1:6379&gt; get key15 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 0 5 &quot;123456&quot; 127.0.0.1:6379&gt; get key15 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 0 -1 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 -2 -1 &quot;89&quot; 127.0.0.1:6379&gt; getrange key15 -3 -1 &quot;789&quot; 127.0.0.1:6379&gt; getrange key15 0 15 &quot;123456789&quot; ###mget作用： 一次获取多个key的值,如果对应key不存 在则对应返回 nil。语法： mget key1 key2 … keyN返回值：获取成功返回 对应key的value,失败返回nil注意：样例： 127.0.0.1:6379&gt; mget key1 key2 key3 1) &quot;100&quot; 2) &quot;250&quot; 3) &quot;400&quot; 127.0.0.1:6379&gt; mget key1 key2 key30 1) &quot;100&quot; 2) &quot;250&quot; 3) (nil) ###incr作用： 对key的值做加加操作,并返回新的值。key不存在时候会设置key,并认为原来的value是0。语法： incr key返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错。样例： 127.0.0.1:6379&gt; get key99 (nil) 127.0.0.1:6379&gt; incr key99 (integer) 1 127.0.0.1:6379&gt; get key99 &quot;1&quot; 127.0.0.1:6379&gt; incr key99 (integer) 2 127.0.0.1:6379&gt; get key99 &quot;2&quot; 127.0.0.1:6379&gt; set key80 yjk OK 127.0.0.1:6379&gt; get key80 &quot;yjk&quot; 127.0.0.1:6379&gt; incr key80 (error) ERR value is not an integer or out of range ###incrby作用： 同incr类似,加指定值,key不存在时候会设置key,并认为原来的value是0。语法： incrby key num返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错, num为负数的时候表示减少指定的值。样例： 127.0.0.1:6379&gt; get key70 (nil) 127.0.0.1:6379&gt; incrby key70 2 (integer) 2 127.0.0.1:6379&gt; get key70 &quot;2&quot; 127.0.0.1:6379&gt; incrby key70 5 (integer) 7 127.0.0.1:6379&gt; get key70 &quot;7&quot; 127.0.0.1:6379&gt; incrby key70 -2 (integer) 5 127.0.0.1:6379&gt; get key70 &quot;5&quot; ###decr作用： 对key的值做减减操作,key不存在时候会设置key,并认为原来的value是0。语法： decr key返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错样例： 127.0.0.1:6379&gt; get key70 &quot;6&quot; 127.0.0.1:6379&gt; decr key70 (integer) 5 127.0.0.1:6379&gt; get key70 &quot;5&quot; ###decrby作用： 同decr类似,减少指定值,key不存在时候会设置key,并认为原来的value是0。语法： decrby key num返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错, num为负数的时候表示增加指定的值。样例： 127.0.0.1:6379&gt; get key70 &quot;5&quot; 127.0.0.1:6379&gt; decrby key70 2 (integer) 3 127.0.0.1:6379&gt; get key70 &quot;3&quot; 127.0.0.1:6379&gt; decrby key70 -5 (integer) 8 127.0.0.1:6379&gt; get key70 &quot;8&quot; ###append作用： 给指定key的字符串追加value,返回新字 符串值的长度。语法： append key appendValue返回值：返回追加成功后的新字符串长度注意： 如果key不存在则自动进行设置为追加字符串。样例： 127.0.0.1:6379&gt; get key50 (nil) 127.0.0.1:6379&gt; append key50 yui (integer) 3 127.0.0.1:6379&gt; get key50 &quot;yui&quot; 127.0.0.1:6379&gt; append key50 dhdg (integer) 7 127.0.0.1:6379&gt; get key50 &quot;yuidhdg&quot; ###strlen作用： 取指定key的value值的长度。语法： strlen key返回值：返回字符串长度注意： 如果key不存在则认为长度为0。样例： 127.0.0.1:6379&gt; get key44 (nil) 127.0.0.1:6379&gt; strlen key44 (integer) 0 127.0.0.1:6379&gt; set key44 123456789 OK 127.0.0.1:6379&gt; get key44 &quot;123456789&quot; 127.0.0.1:6379&gt; strlen key44 (integer) 9","categories":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}]},{"title":"redis入门之Strings数据类型(二)","slug":"redis/redis_string","date":"2010-07-24T15:45:41.000Z","updated":"2020-03-20T06:27:43.664Z","comments":true,"path":"2010/07/24/redis/redis_string/","link":"","permalink":"https://lbvs86823.github.io/2010/07/24/redis/redis_string/","excerpt":"","text":"##一，Strings数据类型介绍 String是最简单的类型,一个Key对应一 个Value,string类型是二进制安全的 。Redis的string可以包含任何数据,比如jp g图片或者序列化的对象。 ##二，Strings数据类型相关操作 ###【注意操作命令在链接到服务器上的客户端上面都是不区分大小写的】 ###set作用： 设置key对应的值为string类型的value语法： set key value返回值：设置成功返回 OK注意： 对一个key重复设置，会被覆盖。样例： 设置key1的值为100 127.0.0.1:6379&gt; set key1 100 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; set key1 200 OK 127.0.0.1:6379&gt; get key1 &quot;200&quot; ###setnx作用： 设置key对应的值为string类型的value,如果key已经存在,则不会再设置(nx是not exist的意思) 语法： setnx key value返回值：设置成功返回 1; 设置失败(该key对应的值已经存在)返回 0；注意： 对一个key重复设置，不会被设置成功。样例： 设置key1的值为100 127.0.0.1:6379&gt; get key1 &quot;200&quot; 127.0.0.1:6379&gt; setnx key1 300 (integer) 0 127.0.0.1:6379&gt; get key1 &quot;200&quot; 127.0.0.1:6379&gt; setnx key2 300 (integer) 1 127.0.0.1:6379&gt; get key2 &quot;300&quot; ###setex作用： 设置key对应的值为string类型的value,并 指定此键值对应的有效期(ex是expires的意思)。 语法： setex key time value返回值：设置成功返回 OK,注意： 有效期的单位是秒，如果对相同的key重复设置时间和值都会被覆盖。样例： 添加一个 key3=500 的键值对,并指定有效期为10秒  127.0.0.1:6379&gt; setex key3 10 500 OK 127.0.0.1:6379&gt; get key3 &quot;500&quot; 127.0.0.1:6379&gt;(等待10秒过后，再查询该key4对应的值) 127.0.0.1:6379&gt; get key3 (nil) ###setrange作用： 替换指定key对应value值的指定位置开始替换字符串。 语法： setrange key pos replaceValue返回值：设置成功返回替换后的对应值的字符串长度注意： pos为开始替换的位置(从0开始的)，如果原字符串被替换后，尾部还有字符没有替换，会原样保留；如果key不存在或者pos越界则会先对其设置值，然后再补位。样例： 将key=redis@163.com 的邮箱替换成google的邮箱 127.0.0.1:6379&gt; set key3 redis@163.com OK 127.0.0.1:6379&gt; get key3 &quot;redis@163.com&quot; 127.0.0.1:6379&gt; setrange key3 4 google.com.hk (integer) 18 127.0.0.1:6379&gt; get key3 &quot;redis@google.com.hk&quot; 127.0.0.1:6379&gt; set key4 redis@163.com.shawxyztyuig OK 127.0.0.1:6379&gt; get key4 &quot;redis@163.com.shawxyztyuig&quot; 127.0.0.1:6379&gt; setrange key4 4 google.com.hk (integer) 26 127.0.0.1:6379&gt; get key4 &quot;redigoogle.com.hkwxyztyuig&quot; 127.0.0.1:6379&gt; setrange ke78 4 hhjj (integer) 8 127.0.0.1:6379&gt; get ke78 &quot;\\x00\\x00\\x00\\x00hhjj&quot; 127.0.0.1:6379&gt; set key20 50 OK 127.0.0.1:6379&gt; setrange key20 3 77 (integer) 5 127.0.0.1:6379&gt; get key20 &quot;50\\x0077&quot; ###mset作用： 一次设置多个key的值(批量设置)。 语法： mset key1 value1 key2 value2 … keyN valueN返回值：设置成功返回 OK,表示都设置成功， 设置失败返回 0, 表示没有任何值被设置注意： 多个key-value对设置时，有一个不成功，都不成功;重复设置相同key的值会被覆盖。样例： 127.0.0.1:6379&gt; mset key1 100 key2 200 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; get key2 &quot;200&quot; 127.0.0.1:6379&gt; mset key2 250 key3 400 OK 127.0.0.1:6379&gt; get key1 &quot;100&quot; 127.0.0.1:6379&gt; get key2 &quot;250&quot; 127.0.0.1:6379&gt; get key3 &quot;400&quot;  ###msetnx作用： 一次设置多个key的值(批量设置),但是不会覆盖已经存在的key. 语法： msetnx key1 value1 key2 value2 … keyN valueN返回值：设置成功返回 OK,表示都设置成功， 设置失败返回 0, 表示没有任何值被设置注意： 多个key-value对设置时，有一个不成功，都不成功;重复设置相同key的值不会被设置成功。样例： 127.0.0.1:6379&gt; msetnx key6 400 key7 500 (integer) 1 127.0.0.1:6379&gt; get key6 &quot;400&quot; 127.0.0.1:6379&gt; get key7 &quot;500&quot; 127.0.0.1:6379&gt; msetnx key7 550 key8 800 (integer) 0 127.0.0.1:6379&gt; get key6 &quot;400&quot; 127.0.0.1:6379&gt; get key7 &quot;500&quot; 127.0.0.1:6379&gt; get key8 (nil) ###get作用： 获取key对应的string值, 如果key不存在返回 nil。语法： get key返回值：获取成功返回 对应key的value,失败返回nil注意：样例： 127.0.0.1:6379&gt; get key9 (nil) 127.0.0.1:6379&gt; set key9 900 OK 127.0.0.1:6379&gt; get key9 &quot;900&quot; ###getset作用： 设置key的值,并返回key的旧值。语法： getset key value返回值：获取成功返回 对应key的原来的oldValue,如果原来没有值就返回 nil注意：样例： 127.0.0.1:6379&gt; getset key10 10 (nil) 127.0.0.1:6379&gt; get key10 &quot;10&quot; 127.0.0.1:6379&gt; getset key10 100 &quot;10&quot; 127.0.0.1:6379&gt; get key10 &quot;100&quot; ###getrange作用： 获取key的value值的子字符串。语法： getrange key startPos endPos返回值：获取成功返回 对应key的value的字串,失败返回nil注意： endPos 为-1时表示value字符串长度的最后一位,大于最大长度时，就取最大长度； startPos为负数的时候表示从字符串的尾部开始数数。样例： 127.0.0.1:6379&gt; set key15 123456789 OK 127.0.0.1:6379&gt; get key15 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 0 5 &quot;123456&quot; 127.0.0.1:6379&gt; get key15 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 0 -1 &quot;123456789&quot; 127.0.0.1:6379&gt; getrange key15 -2 -1 &quot;89&quot; 127.0.0.1:6379&gt; getrange key15 -3 -1 &quot;789&quot; 127.0.0.1:6379&gt; getrange key15 0 15 &quot;123456789&quot; ###mget作用： 一次获取多个key的值,如果对应key不存 在则对应返回 nil。语法： mget key1 key2 … keyN返回值：获取成功返回 对应key的value,失败返回nil注意：样例： 127.0.0.1:6379&gt; mget key1 key2 key3 1) &quot;100&quot; 2) &quot;250&quot; 3) &quot;400&quot; 127.0.0.1:6379&gt; mget key1 key2 key30 1) &quot;100&quot; 2) &quot;250&quot; 3) (nil) ###incr作用： 对key的值做加加操作,并返回新的值。key不存在时候会设置key,并认为原来的value是0。语法： incr key返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错。样例： 127.0.0.1:6379&gt; get key99 (nil) 127.0.0.1:6379&gt; incr key99 (integer) 1 127.0.0.1:6379&gt; get key99 &quot;1&quot; 127.0.0.1:6379&gt; incr key99 (integer) 2 127.0.0.1:6379&gt; get key99 &quot;2&quot; 127.0.0.1:6379&gt; set key80 yjk OK 127.0.0.1:6379&gt; get key80 &quot;yjk&quot; 127.0.0.1:6379&gt; incr key80 (error) ERR value is not an integer or out of range ###incrby作用： 同incr类似,加指定值,key不存在时候会设置key,并认为原来的value是0。语法： incrby key num返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错, num为负数的时候表示减少指定的值。样例： 127.0.0.1:6379&gt; get key70 (nil) 127.0.0.1:6379&gt; incrby key70 2 (integer) 2 127.0.0.1:6379&gt; get key70 &quot;2&quot; 127.0.0.1:6379&gt; incrby key70 5 (integer) 7 127.0.0.1:6379&gt; get key70 &quot;7&quot; 127.0.0.1:6379&gt; incrby key70 -2 (integer) 5 127.0.0.1:6379&gt; get key70 &quot;5&quot; ###decr作用： 对key的值做减减操作,key不存在时候会设置key,并认为原来的value是0。语法： decr key返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错样例： 127.0.0.1:6379&gt; get key70 &quot;6&quot; 127.0.0.1:6379&gt; decr key70 (integer) 5 127.0.0.1:6379&gt; get key70 &quot;5&quot; ###decrby作用： 同decr类似,减少指定值,key不存在时候会设置key,并认为原来的value是0。语法： decrby key num返回值：返回增加成功后的值注意： 如果value不是一个整数可能会出错, num为负数的时候表示增加指定的值。样例： 127.0.0.1:6379&gt; get key70 &quot;5&quot; 127.0.0.1:6379&gt; decrby key70 2 (integer) 3 127.0.0.1:6379&gt; get key70 &quot;3&quot; 127.0.0.1:6379&gt; decrby key70 -5 (integer) 8 127.0.0.1:6379&gt; get key70 &quot;8&quot; ###append作用： 给指定key的字符串追加value,返回新字 符串值的长度。语法： append key appendValue返回值：返回追加成功后的新字符串长度注意： 如果key不存在则自动进行设置为追加字符串。样例： 127.0.0.1:6379&gt; get key50 (nil) 127.0.0.1:6379&gt; append key50 yui (integer) 3 127.0.0.1:6379&gt; get key50 &quot;yui&quot; 127.0.0.1:6379&gt; append key50 dhdg (integer) 7 127.0.0.1:6379&gt; get key50 &quot;yuidhdg&quot; ###strlen作用： 取指定key的value值的长度。语法： strlen key返回值：返回字符串长度注意： 如果key不存在则认为长度为0。样例： 127.0.0.1:6379&gt; get key44 (nil) 127.0.0.1:6379&gt; strlen key44 (integer) 0 127.0.0.1:6379&gt; set key44 123456789 OK 127.0.0.1:6379&gt; get key44 &quot;123456789&quot; 127.0.0.1:6379&gt; strlen key44 (integer) 9","categories":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}]},{"title":"redis入门之介绍和安装篇(一)","slug":"redis/redis","date":"2010-07-24T02:15:45.000Z","updated":"2020-03-20T06:27:43.662Z","comments":true,"path":"2010/07/24/redis/redis/","link":"","permalink":"https://lbvs86823.github.io/2010/07/24/redis/redis/","excerpt":"","text":"##一，redis介绍 Redis 是完全开源免费的，遵守BSD协议，先进的key-value持久化产品。它通常被称为数据结构服务器,因为键可以包含string(字符串)、list(链表)、 set(集合)、zset(有序集合)。 Redis数据库提供多种灵活的数据结构和数据操作。它支持存储的value类型很多,包括string(字符串)、list(链表)、 set(集合)、zset(有序集合)。 这些数据类型都支持 push/pop、add/remove及取交集和并集及更丰富的操作,Redis支持各种不同方式的排序。为了保证效率, 数据都是缓存在内存中,它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 Redis提供的API接口程序语言包括:C、C++、C#、Clojure  Common  Lisp、Erlang、Haskell、Java、Javascript、 Lua、Objective-C、Perl、PHP、Python、Ruby  Scala、Go、Tcl。 ##二，Redis适用的场景 1.取最新N个数据的操作  2.排行榜应用,取 TOPN 操作  3.需要精确设定过期时间的应用  4.计数器应用  5.Uniq操作,获取某段时间所有数据排重值  6.实时系统,反垃圾系统 7.Pub/Sub(发布/订阅)构建实时消息系统  8.构建队列系统  9.缓存 ##三，redis的编译运行 $ wget http://download.redis.io/releases/redis-2.8.7.tar.gz $ tar xzf redis-2.8.7.tar.gz $ cd redis-2.8.7 $ make 编译后的可执行文件在src目录中，可以使用下面的命令运行Redis: $ src/redis-server 你可以使用内置的客户端连接Redis: $ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; ##四，redis手动优化安装 通过上面的步骤你可以进行redis的学习是没有问题的，但是如果要运行在生产环境还有很多需要优化的地方。比如：按照上面的方法启动redis-server会占用当前会话(而不是以后台服务运行的)，而且还会出现一些警告信息(没有指定配置文件)，你不得不新开一个终端进行客户端的连接，为了解决上述的一些问题，你可以进行如下的一些优化操作： 一般我们都是安装部署redis在linux服务器上面的，而按照Linux系统安装软件的习惯一般都放在 /usr/local/下面；所以便于我们以后的软件管理，我们也在这个目录下新建一个redis的安装文件夹，如下： $ mkdir  -p  /usr/local/redis/bin  $ mkdir  -p  /usr/local/redis/etc  bin：目录用来存放redis的命令文件 比如：redis-server，redis-clietc：目录用来存放redis的配置文件 比如：redis.conf 下面我们就把相关的命令文件和配置文件拷贝到指定的目录(可能需要root权限操作) $ cd redis-2.8.7 $ cp  ./redis.conf  /usr/local/redis/etc $ cd src $ cp redis-benchmark redis-check-aof redis-check-dump redis-cli redis-sentinel redis-server /usr/local/redis/bin/ 启动Redis服务(已经没有警告信息咯):  $ /usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf Redis启动的时候指定了配置文件以后，你可以看到之前的警告信息已经没有了，并且可以看到服务器的进程号和默认连接的端口号:6379  默认情况下,Redis不是在后台运行的,我们需要把开启Redis的后台运行,即将daemonize的值由 “no” 改为 “yes” 就ok了。  $ vi  /usr/local/redis/redis.conf $ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf $ ps -ef | grep redis 修改配置文件后，重新启动，就可以看到已经不在占用当前会话了,并且可以查看到redis已经在后台运行了。我们也可以使用如下命令，把后台redis给关闭掉： $ pkill redis-server 我们也可以在本会话窗口中继续通过内置客户端连接redis了；如下： $ /usr/local/redis/bin/redis-cli ##五，redis自动优化安装 上面的都是我们手动制作的，后来我看到了redis的源码仓库里面的说明，其实要达到上面的效果很简单，可以按照如下的操作来执行就可以了！ 首先还是要进行编译操作： $ wget http://download.redis.io/releases/redis-2.8.7.tar.gz $ tar xzf redis-2.8.7.tar.gz $ cd redis-2.8.7 $ make 经过上面的编译后，会有一个src目录生成。比如：我打算新建一个 ~/software/redis 的文件夹用来专门放置redis的可执行程序软件, 新建文件夹 ~/software/redis/conf 用来放置启动redis的配置文件，那么进行如下操作： $ mkdir ~/software/redis $ mkdir ~/software/redis/conf $ cd src $ make PREFIX = ~/software/redis install $ cp ../redis.conf ~/software/redis/conf 通过上面的操作你可以看到，redis的相关命令(redis-benchmark, redis-cli, redis-check-aof, redis-server, redis-check-dump)都被安装到了 ~/software/redis/bin 目录下面，而且redis的配置文件redis.conf 也被copy到了 ~/software/redis/conf 目录下面(顺便修改下reids.conf 文件的 daemonize=yes)，这样我们一个完整的独立的redis软件包就制作好了；可以进行启动了： $ cd ~/software/redis $ ./bin/redis-server ./conf/redis.conf $ ./bin/reids-cli 127.0.0.1:6379&gt; keys * (empty list or set) ##六，关于redis配置文件中的一些属性说明 daemonize 如果需要在后台运行,把该项改为 yes pidfile 配置多个pid的地址 默认在/var/run/redis.pid bind 绑定ip,设置后只接受来自该ip的请求 port 监听端口,默认为6379 timeout 设置客户端连接时的超时时间,单位为秒 loglevel 分为4级,debug、verbose、notice、warning logfile 配置log文件地址 databases 设置数据库的个数,默认使用的数据库为0 save 设置redis进行数据库镜像的频率 rdbcompression 在进行镜像备份时,是否进行压缩 Dbfilename 镜像备份文件的文件名 Dir 数据库镜像备份的文件放置路径 Slaveof 设置数据库为其他数据库的从数据库 Masterauth 主数据库连接需要的密码验证 Requirepass 设置登录时需要使用的密码 Maxclients 限制同时连接的客户数量 Maxmemory 设置redis能够使用的最大内存 Appendonly 开启append only模式 Appendfsync 设置对appendonly.aof文件同步的频率 vm-enabled 是否开启虚拟内存支持 vm-swap-file 设置虚拟内存的交换文件路径 vm-max-memory 设置redis使用的最大物理内存大小 vm-page-size 设置虚拟内存的页大小 vm-pages 设置交换文件的总的page数量 vm-max-threads 设置VM IO同时使用的线程数量 Glueoutputbuf 把小的输出缓存存放在一起 hash-max-zipmap-entries 设置hash的临界值 Activerehashing 重新hash","categories":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://lbvs86823.github.io/categories/redis/"}]},{"title":"maven的入门","slug":"tools/maven02","date":"2010-05-18T14:25:01.000Z","updated":"2020-03-20T06:27:43.684Z","comments":true,"path":"2010/05/18/tools/maven02/","link":"","permalink":"https://lbvs86823.github.io/2010/05/18/tools/maven02/","excerpt":"","text":"一，认识pom.xmlPOM (Project Object Model)项目对象模型。 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lbvs.mvnbook&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-world&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; modelVersion ：指定当前项目对象模型的版本。 一个项目的基本坐标：groupId : 定义项目属于哪个组artifactId : 定义项目在项目组下的IDversion : 当前项目的版本在maven世界里，任何的jar，pom，war都是基于这些坐标进行区分的。 二，使用 archetype 手动生成项目骨架在命令行输入：$ mvn archetype:generate你将看到许多的项目骨架列表如下： [INFO] --- maven-archetype-plugin:2.2:generate (default-cli) @ standalone-pom --- [INFO] Generating project in Interactive mode [INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0) Choose archetype: ............. 341: remote -&gt; org.apache.cocoon:cocoon-22-archetype-webapp (-) 342: remote -&gt; org.apache.cocoon.archetype-block:cocoon-archetype-block (-) 343: remote -&gt; org.apache.cocoon.archetype-parent:cocoon-archetype-parent (-) 344: remote -&gt; org.apache.cocoon.archetype-sample:cocoon-archetype-sample (-) 345: remote -&gt; org.apache.cocoon.archetype-webapp:cocoon-archetype-webapp (-) ............. 同时命令行会提示一个默认的编号，其对应的archetype为maven-archetype-quickstart，直接回车可以选择该archetype，紧接着maven会提示你输入项目的groupId，artifactId，version，以及包名package。 Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 380: Choose org.apache.maven.archetypes:maven-archetype-quickstart version: 1: 1.0-alpha-1 2: 1.0-alpha-2 3: 1.0-alpha-3 4: 1.0-alpha-4 5: 1.0 6: 1.1 Define value for property &apos;groupId&apos;: : com.lbvs.mvnbook Define value for property &apos;artifactId&apos;: : hello-world Define value for property &apos;version&apos;: 1.0-SNAPSHOT: : Define value for property &apos;package&apos;: com.lbvs.mvnbook: : com.lbvs.mvnbook.hellworld Confirm properties configuration: groupId: com.lbvs.mvnbook artifactId: hello-world version: 1.0-SNAPSHOT package: com.lbvs.mvnbook.hellworld Y: : y [INFO] ---------------------------------------------------------------------------- [INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1 [INFO] ---------------------------------------------------------------------------- [INFO] Parameter: groupId, Value: com.lbvs.mvnbook [INFO] Parameter: packageName, Value: com.lbvs.mvnbook.hellworld [INFO] Parameter: package, Value: com.lbvs.mvnbook.hellworld [INFO] Parameter: artifactId, Value: hello-world [INFO] Parameter: basedir, Value: /Users/libing/Documents/IdeaProjects [INFO] Parameter: version, Value: 1.0-SNAPSHOT [INFO] project created from Old (1.x) Archetype in dir: /Users/libing/Documents/IdeaProjects/hello-world [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 07:30 min [INFO] Finished at: 2014-04-26T17:43:48+08:00 [INFO] Final Memory: 9M/81M [INFO] ------------------------------------------------------------------------ 三，Maven的坐标maven的坐标元素包括以下几个部分组成： groupId : 定义当前项目隶属的实际项目。推荐的做法是：组织(公司)域名反写.项目名称 artfactId : 定义实际项目中的一个Maven项目(模块)。推荐的做法是：项目名称-模块名称 version : 定义Maven项目当前所处的版本。推荐的做法是：参考Maven定义了一套完整的版本规范。 packaging : 定义Maven项目的打包方式。当没有定义该元素时候，Maven默认使用jar方式打包。其次打包方式会影响到构建的生命周期。 classifier : 定义构建输出的一些附属构建。注意，不能直接定义项目的classifier，因为附属构建不是项目默认直接生成的，而是由附加的插件帮助生成的。 特别注意：上述5个元素中，groupId，artifactId，version 是必须定义的。packaging 是可选的(默认是jar)。 classifier 是不能直接定义的。 常见的仓库中的构件定义如下： 依赖于其他构件 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;3.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 自定义一个构件： &lt;groupId&gt;com.lbvs.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-email&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; 只要我们能提供正确的坐标元素，maven就能从仓库中找到对应的构件。在我们开发自己的项目的时候，也需要定义适当的坐标，这是maven强制要求的。在此基础之上，其他的maven项目可能引用该项目生成的构件。 五，Maven的依赖5.1 依赖的配置每个依赖可以包含的元素有： groupId, artifactId, version : 依赖的基本坐标系。 type ： 依赖的类型，对应于项目坐标系的packaging，大部分情况下，该元素不必声明，默认是jar。 scope ： 范围的依赖。 optional : 标记依赖是否可选。 exclusions ：用来排除传递性依赖。 5.2 依赖的范围Maven在编译项目主代码的时候需要使用一套classpath。依赖范围就是用来控制依赖与三种classpath(编译classpath，测试classpath，运行classpath)的关系。Maven有以下几种范围依赖： complie ： 编译依赖范围。如果没有指定，默认就使用此范围依赖。该范围依赖，对于编译，测试，运行三种classpath都有效。比如：spring-core test ： 测试依赖范围。只对测试classpath有效。 比如：JUnit provided ：已提供依赖范围。只对编译，测试classpath有效，对应运行classpath无效。比如：servlet-api runtime ：运行时依赖范围。只对测试和运行classpath有效，对编译classpath无效。比如：jdbc驱动实现 system ：系统依赖范围。对classpath的影响和provided相同。但是使用system依赖范围时，必须显示的使用systemPath 指定依赖文件的路径(其值可以引用环境变量)。此类依赖不是由Maven仓库解析的，而且往往与本机系统绑定，可能造成构件不可移植。比如：本地仓库之外的类文件。 import ：导入依赖范围。该依赖范围不会对编译，测试，运行classpath造成影响。 5.3 依赖的传递性依赖的范围不仅可以对编译，测试，运行的classpath产生影响，而且还会影响到依赖的传递性。 六，Maven的仓库","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://lbvs86823.github.io/tags/maven/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"maven的安装与配置","slug":"tools/maven01","date":"2010-05-18T02:25:01.000Z","updated":"2020-03-20T06:27:43.684Z","comments":true,"path":"2010/05/18/tools/maven01/","link":"","permalink":"https://lbvs86823.github.io/2010/05/18/tools/maven01/","excerpt":"","text":"一，maven介绍Maven是一跨平台的项目管理工具。Maven 主要服务于基于 Java 平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven 都能大显身手 Maven 不仅是构建工具，还是一个依赖管理工具和项目信息管理工具。它提供了中央仓库，能帮我们自动下载构件。它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。 我们一直在不停地寻找避免重复的方法。设计的重复、编码的重复、文档的重复，当然还有构建的重复。Maven 最大化地消除了构建的重复，抽象了构建生命周期，并且为绝大部分的构建任务提供了已实现的插件，我们不再需要定义过程，甚至不需要再去实现这些过程中的一些任务。 使用 Maven 还能享受一个额外的好处，即 Maven 对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置。 二，Maven 的安装和配置首先下载 maven最新的安装包(apache-maven-3.2.1-bin.tar.gz)。 Windows环境下的安装： 设置java环境变量: JAVA_HOME = C:\\Java\\jdk1.6.31 解压安装包，设置maven环境变量： M2_HOME = D:\\apache-maven-3.2.1 添加Path环境变量： path = .;%JAVA_HOME%\\bin;%M2_HOME%\\bin 测试是否安装成功：在命令行输入： mvn -v 后可以看相关系统和java版本以及maven版本信息即安装成功了。 Linux环境下的安装： 设置java环境变量: export JAVA_HOME = /home/wda/jdk1.6.31 解压安装包，设置maven环境变量： tar -xvzf apache-maven-3.2.1-bin.tar.gz export M2_HOME=/home/wda/apache-maven-3.2.1 添加Path环境变量： export PATH=$PATH:$M2_HOME/bin 测试是否安装成功：在终端输入： mvn -v 后可以看相关系统和java版本以及maven版本信息即安装成功了。 注意：一般为了以后升级maven方便，在安装目录旁平行的创建一个符号链接如下： $ ln -s apache-maven-3.2.1 apache-maven然后，让M2_HOME指向链接文件，而不指向具体的版本。 export M2_HOME=/home/wda/apache-maven export PATH=$PATH:$M2_HOME/bin当要升级maven的时候就可以只需要重新指定链接的文件就可以了，如下： $ rm apache-maven $ ln -s apache-maven-3.2.1 apache-maven这样简单的就完成了maven的升级了。 Mac环境下的安装： 启动终端Terminal: 进入当前用户的home目录: 输入: cd ~ 创建.bash_profile 输入: touch .bash_profile 编辑.bash_profile文件 输入: open -e .bash_profile 写入下内容： export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home export M2_HOME=/Users/wda/Documents/workspace/apache-maven-3.2.1 export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin 保存文件，关闭 .bash_profile 文件 更新刚配置的环境变量： 输入: source .bash_profile 验证配置是否成功： 输入: mvn -v 后可以看相关系统和java版本以及maven版本信息即安装成功了。 三，Maven安装目录的结构分析 bin boot conf lib LICENSE NOTICE README.txt bin： 该目录包含了 mvn 运行的脚本，基于UNIX 平台的(mvn, mvnDebug),基于 Windows 平台的(mvn.bat, mvnDebug.bat)，m2.conf 文件，这是classworlds的配置文件。mvnDebug相比mvn命令而言只是多了一条 MAVEN_DEBUG_OPTS 配置，作用就是在运行Maven时开启 debug模式，以便调试 Maven 本身。 boot： 该目录只包含一个文件，以 maven 3.2.1 为例，该文件为 plexus-classworlds-2.5.1.jar 这是一个类加载器框架，相对于默认的 java 类加载器，它提供了更丰富的语法以方便配置，Maven 使用该框架加载自己的类库。 conf： 该目录包含了一个非常重要的文件 settings.xml。直接修改该文件，就能在机器上全局地定制 Maven 的行为。一般情况下，我们更偏向于复制该文件至~/.m2/目录下，然后修改该文件，在用户范围定制 Maven 的行为。 lib： 该目录包含了所有 Maven 运行时需要的 Java 类库，Maven 本身是分模块开发的，因此用户能看到 诸如 mavn-core-3.0.jar、maven-model-3.0.jar 之类的文件，此外这里还包含一些 Maven 用到的第三方依赖 如 common-cli-1.2.jar、google-collection-1.0.jar 等等。 四，Maven本地仓库的设置默认情况下，~/.m2 目录下除了 repository 仓库之外就没有其他目录和文件了，不过大多数 Maven 用户需要复制 M2_HOME/conf/settings.xml 文件到~/.m2/settings.xml, 这是一条最佳实践. 默认情况下仓库位置(${user.home}/.m2/repository) ,但是可以自行设置：编辑 ~/.m2/settings.xml 文件（如果没有该文件，则复制$M2_HOME/conf/settings.xml）。添加如下配置： &lt;localRepository&gt;${user.home}/Documents/workspace/mavenRepository&lt;/localRepository&gt; 五，Maven设置HTTP代理有时候你所在的公司可能基于安全的考虑，要求你使用通过安全认证的代理访问Internet网络。这种时候就需要为maven配置HTTP代理，它才能正常访问外部的仓库下载所需资源。编辑~/.m2/settings.xml 文件（如果没有该文件，则复制$M2_HOME/conf/settings.xml）。添加代理配置如下： &lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;wda&lt;/username&gt; &lt;password&gt;wda123456&lt;/password&gt; &lt;host&gt;218.14.227.197&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; 注意：proxies 下可以有多个 proxy 元素，如果你声明了多个 proxy 元素，则默认情况下第一个被激活的 proxy 会生效。这里声明了一个 id 为 my-proxy 的代理，active 的值为 true 表示激活该代理。 nonProxyHost 元素用来指定哪些主机名不需要代理，可以使用 | 符号来分隔多个主机名。此外，该配置也支持通配符，如:*.google.com 表示所有以 google.com 结尾的域名访问都不要通过代理。 六，Maven设置MAVEN_OPTS环境变量通常需要设置MAVEN_OPTS的值为：-Xms128m -Xmx512m, 因为java默认的最大可用内存往往不能够满足maven的运行需要。","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://lbvs86823.github.io/tags/maven/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"log4j.properties配置详解","slug":"log/log4j-config","date":"2010-05-14T12:55:08.000Z","updated":"2020-03-20T06:27:43.654Z","comments":true,"path":"2010/05/14/log/log4j-config/","link":"","permalink":"https://lbvs86823.github.io/2010/05/14/log/log4j-config/","excerpt":"","text":"一，log4j介绍：Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等;我们也可以控制每一条日志的输出格式;通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 作为记录日志的工具，它至少应该包含如下几个组成部分(组件)： Logger记录器组件负责产生日志，并能够对日志信息进行分类筛选，控制什么样的日志应该被输出，什么样的日志应该被忽略。它还有一个重要的属性－日志级别。 Level日志级别组件,不管何种日志记录工具，大概包含了如下几种日志级别：DEBUG, INFO, WARN, ERROR 和 FATAL。 Appender日志记录工具基本上通过 Appender 组件来输出到目的地的，一个 Appender 实例就表示了一个输出的目的地。 LayoutLayout 组件负责格式化输出的日志信息，一个 Appender 只能有一个 Layout。 ##二，针对log4j的主要组件介绍 Logger每个Logger拥有自己的名字，Logger之间通过名字来表明隶属关系。有一个Logger称为Root，它永远 存在，且不能通过名字检索或引用，可以通过Logger.getRootLogger()方法获得。其它Logger通过 Logger.getLogger(String name)方法。 AppenderAppender则是用来指明将所有的log信息存放到什么地方，Log4j中支持多种appender，如 console、files、GUI components、NT Event Loggers等.一个Logger可以拥有多个Appender，也就是你既可以将Log信息输出到屏幕，同时存储到一个文件中。 LayoutLayout的作用是控制Log信息的输出方式，也就是格式化输出的信息。Log4j中将要输出的Log信息定义了5种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL.当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码 下面我们来看看Log4j是怎么使用这3个组件完成当我们调用logger.debug()方法能在控制台上打印出日志信息的： 第一步，继承数体系上的门槛检查：首先当调用info()方法后，Log4J会立刻使用该Logger所在的体系结构中设置的门槛去检查当前日志的级别。如果级别不够，立刻作废当前日志请求。 第二步，Level级别检查：使用当前Logger上设置的或者继承的Level级别来检查当前的日志级别。如果当前日志级别不够，立刻作废当前日志请求。 第三步，创建LoggingEvent对象：当日志审核通过，Log4J就会创建一个LoggingEvent对象（即日志事件对象）。在该对象中，会保存和本次日志相关的所有参数信息，包括日志内容，日志时间等。 第四步，执行Appender：当创建完成LoggingEvent对象时候，会该对象交给当前logger上起作用的所有的Appender对象，并调用这些对象的doAppend方法来处理日志消息。 第五步，格式化日志消息：接下来，会使用每一个Appender绑定的Layout对象（如果有）来格式化日志消息。Layout对象会把LoggingEvent格式化成最终准备输出的String。 第六步，输出日志消息：当得到最终要输出的String对象之后，appender会把字符输出到最终的目标上，比如控制台或者文件。 ##三，Logger的配置方法： ####(1)语法格式首先，是设置root，格式为： log4j.rootLogger=[level],appenderName, ...， 其中level就是设置需要输出信息的级别：level可能的值:OFF ,FATAL ,ERROR ,WARN ,INFO ,DEBUG ,ALL后面的appenderName是输出的目的地。appenderName就是指定日志信息输出到哪个地方。您可以同时指定多个输出目的地。 ####(2)og4j.additivity(属性)简单一句话就是logger子类是否继承父类的Appender输出源。默认情况下,子类会默认继承，即子类Logger会同时输出到父类的Appender和子类自己的Appender中去。若是additivity设为false，则，子类Logger只会在自己的Appender里输出，而不会在父类Logger的appender里输出。 比如： log4j.rootLogger=DEBUG,Main,Console log4j.logger.com.lvy.market.service.ConfigService= debug, Main log4j.additivity.com.lvy.market.service.ConfigService= false Logger(Root)父类是要将日志输出到 Main 和 Console的。但是子类Logger(com.lvy.market.service.ConfigService)的additivity设置成了false所以，子类(com.lvy.market.service.ConfigService)的日志只会输出到 Main 中，不会输出到 Console 下面是配置Logger的完整样例： log4j.rootLogger=DEBUG,Main,Console //其他Logger的设置：(比如打印sql语句的日志) log4j.logger.java.sql=DEBUG,Console log4j.logger.com.ibatis=DEBUG,Console log4j.org.springframework.orm.ibatis=DEBUG,Console ##四，Appender的配置方法：配置日志信息输出目的地Appender，其语法为： log4j.appender.appenderName = appender实现类的完全限定名 log4j.appender.appenderName.option1 = value1 ... log4j.appender.appenderName.optionN = valueN 根据Appender的类型可以分为两种： 基于文件系统的(需要配置一个Layout对象) 基于网络(Socket)的（不需要配置Layout对象） ####(1)基于文件系统的有存在不同的类型： #####org.apache.log4j.WriterAppender WriterAppender是一个非常基础的Appender，他可以将LoggingEvent合成的结果直接交给一个Writer对象去处理。通过这个描述，其实我们也能很简单的想到，WriterAppender是不能通过配置脚本来完成配置的，只能允许通过代码的方式指定要输出的Writer。那为什么我们还要学习WriterAppender呢？其实很简单，因为他是后面要讲到的ConsoleAppender，FileAppender的父类。 相关属性：encoding：用来规定了输出String的编码格式，如果没有设置编码格式，那么按照系统的默认编码格式输出Threshold：设置日志输出的级别immediateFlush：用来确定是否需要立刻记录。默认情况下，这个选项为true，代表每一次日志请求之后，立刻把这次日志的内容输出到Writer上，如果设置这个选项为false，则在一次日志请求之后，不会立刻的把内容输出到writer上，而会先把日志请求缓存一下，过段时间再发送到Writer上输出。这样做可以提高20%左右的程序性能，但随之而来的问题是，有可能有一小部分的日志请求会丢失。 配置样例 Logger.getRootLogger().setLevel(Level.INFO); WriterAppender wa=new WriterAppender(new SimpleLayout(),System.out); wa.setImmediateFlush(false); Logger.getRootLogger().addAppender(wa); Logger logger = Logger.getLogger(&quot;cd.lbvs&quot;); Logger barLogger = Logger.getLogger(&quot;cd.lbvs.log&quot;); logger.warn(&quot;logger warn&quot;); logger.debug(&quot;logger debug&quot;); barLogger.info(&quot;bar logger info&quot;); barLogger.debug(&quot;bar logger debug&quot;); #####org.apache.log4j.ConsoleAppenderConsoleAppender就是直接把日志内容输出到控制台上面首先ConsoleAppender是继承WriterAppender的，所以不用多说，ConsoleAppender也有encoding和immediateFlush两个配置项使用ConsoleAppender，由于没有需要特殊指定的类似Writer的对象，所以整个ConsoleAppender可以直接在配置脚本中完成 相关属性target：设置采用哪种方式将日志输出到控制台。对于Java来说，将内容输出到控制台有两种方式，System.out和System.err 配置样例 log4j.rootLogger=INFO,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.target=System.err log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout #####org.apache.log4j.FileAppenderFileAppender其实也是继承WriterAppender的，只是提供了一个指定的FileWriter而已。自然FileAppender也继承了encoding和immediateFlush两个配置项 相关属性append：一个布尔值，默认为true。这个值很好理解。如果append=true，则每次记录的日志是采用追加的方式添加到文件当中，如果append=false，则每次记录日志都是使用覆写的方式，大部分情况下，我们都保持默认值就行了。file：指定要保存日志的文件名称；bufferedIO：一个布尔值，默认为false。这个值也很好理解，当bufferedIO=false的时候，相当于直接打开了一个FileWriter，每次日志都是直接写入到文件里面。如果bufferedIO=true，则FileAppender会为我们在FileWriter之上再包装一个BufferedWriter，在日志量很大的情况下，这会适当提高系统整体性能。bufferSize：如果设置了bufferedIO为true，则可以通过设置BufferSize参数来调整BufferedWriter的缓存大小。 配置样例 log4j.rootLogger=DEBUG,file log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.file=../logs/main.log log4j.appender.file.bufferedIO=true log4j.appender.file.bufferSize=1024 log4j.appender.file.layout=org.apache.log4j.SimpleLayout #####org.apache.log4j.RollingFileAppenderRollingFileAppender也能够将日志记录到文件中，并且可以当一个文件到达了指定大小后，把这个日志文件备份并重开一个日志文件。RollingFileAppender是继承自FileAppender，所以FileAppender那些配置项仍然能够使用 首先创建file名字的文件：log.log；当log.log到达maxFileSize后，就把log.log备份为log.log.1，并且新开log.log文件；当log.log再次达到maxFileSize后，就依次把log.log.N重命名为log.log.N+1，即log.log.1就变成了log.log.2，log.log就变成了log.log.1；如果log.log.N+1超过了maxBackupIndex大小，就删除备份文件。 相关属性MaximumFileSize：设置日志文件能达到的最大的容量，超过这个大小，日志文件就会备份并新开。注意，这个maximumFileSize的参数值是文件的大小值，是long型的。MaxFileSize：这个参数项也是用来设置日志文件能达到的最大的容量。但这个参数值传入的参数类型是String；在这个String中，可以允许通过使用KB，MB，或者GB来方便的指定文件的大小，这个参数比maximumFileSize方便的多。MaxBackupIndex：设置备份文件能够存在的最大索引号。他用来设置最大备份文件的序号，如果备份文件的序号超过了这个数，那么更早的日志文件就被删除了。 配置样例 log4j.rootLogger=DEBUG,file log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.file=log.log log4j.appender.file.maxFileSize=10KB log4j.appender.file.maxBackupIndex=100 log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.conversionPattern=%r [%t] %p %c %x - %m%n #####org.apache.log4j.DailyRollingFileAppenderDailyRollingFileAppender提供了按照特定时间生成一份日志文件的方式，这个类的设计比较有灵活。首先，这个类是继承FileAppender的，所以他具有FileAppender相关的所有属性配置 相关属性datePattern：设置日期格式。这个日期格式是一个String，其实就是在SimpleDateFormat中允许的日期格式。这个参数有两个作用，1，他设置了分隔日志文件的间隔；2，设置了日志文件的后缀名。我们不能在datePattern中使用’/’；’;’等文件名不允许出现的字符 当然也可以指定按月、周、天、时和分。即对应的格式如下：‘.’yyyy-MM: 每月‘.’yyyy-ww: 每周‘.’yyyy-MM-dd: 每天‘.’yyyy-MM-dd-a: 每天两次‘.’yyyy-MM-dd-HH: 每小时‘.’yyyy-MM-dd-HH-mm: 每分钟 配置样例 log4j.rootLogger=DEBUG,file log4j.appender.file=org.apache.log4j.DailyRollingFileAppender log4j.appender.file.file=log log4j.appender.file.datePattern=&apos;.&apos;yyyy-MM-dd-HH-mm‘.log’ log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.conversionPattern=%r [%t] %p %c %x - %m%n 下面这是一个完整的Appender的配置样例： log4j.logger.com.lvy.market.service.UserService= debug, Main log4j.additivity.com.lvy.market.service.UserService= false log4j.appender.Main=org.apache.log4j.RollingFileAppender log4j.appender.Main.File=../logs/main.log log4j.appender.Main.MaxFileSize=5000KB log4j.appender.Main.MaxBackupIndex=20 log4j.appender.Main.layout=org.apache.log4j.PatternLayout log4j.appender.Main.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n ####(2)基于网络系统的有存在不同的类型： #####org.apache.log4j.net.SocketAppenderSocketAppender是基于Socket的Appender，他不会对日志消息做任何的处理，而仅仅是通过Socket将日志请求发送到特定的服务器上。既然是把日志请求发送到特定的服务器上，首先要考虑的就是日志消息使用什么样的方式发送，在SocketAppender中，只是简单的把LoggingEvent对象直接通过序列化的方式发送到Socket的输出流上。所以，要能正常使用SocketAppender，就不单单是使用日志的应用了，还需要一个能统一和接受日志消息的独立的日志服务器应用了。我们下面就简单的把使用日志功能的应用称为Logging Client，把接收和处理日志消息的服务器应用称为Logging Server。 相关属性RemoteHost：指定远端的Logging Server的地址。Port：指定远端的Logging Server的端口。默认情况下，SocketAppender就是请求的4560端口。Application：可以设置应用的名称。因为使用SocketAppender，就可以使用同一个专门的Logging Server来统一完成日志记录。那么就有可能会有不同的应用提交日志到Server上reconnectionDelay：如果客户端连接不上服务器端，那么会在reconnectionDelay指定的时间之后重新连接。这里需要注意的一个问题就是，客户端发送日志请求和服务器之间的通信问题。在网络通信正常的情况下，每一条客户端的日志请求都会正常的发送给服务器端处理，这是没有问题的。 但是考虑网络的不稳定性，就会出现以下的情况： 1，当网络发送包的频率大于日志频率，会正常的按照日志频率发送信息； 2，当网络发送包的频率低于日志频率，则只会按照网络发送包的频率来发送客户端的日志信息。这里就有可能出现日志消息丢失的问题； 3，当服务器连接断开，SocketAppender会尝试重新连接服务器端，但是在这个断开的过程当中，所有的日志信息将会丢失。 配置样例 本地客户端配置样例： log4j.rootLogger=DEBUG,socket log4j.appender.socket=org.apache.log4j.net.SocketAppender log4j.appender.socket.RemoteHost=localhost log4j.appender.socket.port=4560 log4j.appender.socket.application=localclient 服务端接收处理样例：org.apache.log4j.net.SimpleSocketServer 我们也没有必要自己来写这个Server端的应用，因为Log4J为我们实现了一个Server端：SimpleSocketServer。这个SimpleSocketServer的使用非常简单，他相当于把接受到的LoggingEvent作为本地的日志记录事件，再使用在服务器端配置的Log4J环境来记录日志。 Usage: java org.apache.log4j.net.SimpleSocketServer port configFile where port is a part number where the server listens and configFile is a configuration file fed to the PropertyConfigurator or to DOMConfigurator if an XML file. #####org.apache.log4j.net.SocketHubAppender #####org.apache.log4j.net.SMTPAppender #####org.apache.log4j.net.TelnetAppender #####org.apache.log4j.net.SyslogAppender #####org.apache.log4j.net.SocketHubAppender #####org.apache.log4j.net.JMSAppender ##五，Layout的配置方法：配置日志信息的格式（布局），其语法为： log4j.appender.appenderName.layout = 布局实现类的完全限定名 log4j.appender.appenderName.layout.option1 = value1 .... log4j.appender.appenderName.layout.optionN = valueN ####Layout种类及配置： #####org.apache.log4j.SimpleLayoutSimpleLayout可以说是几乎没有任何复杂度，我们只需要设置对应Appender的layout属性为SimpleLayout即可，这个Layout本身没有任何的配置项。SimpleLayout在测试中可以说是最简单的Layout了，他仅仅输出了Logger级别和日志内容： 配置样例 log4j.rootLogger=DEBUG,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout #####org.apache.log4j.PatternLayoutPatternLayout允许我们定义非常多我们需要的输出格式，而我们需要配置的仅仅是告诉PatternLayout我们需要的输出格式而已： 相关属性conversionPattern:%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL。%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921。%r: 输出自应用启动到输出该log信息耗费的毫秒数。%c: 输出日志信息所属的类目，通常就是所在类的全名。%t: 输出产生该日志事件的线程名。%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)。%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。%%: 输出一个”%”字符。%F: 输出日志消息产生时所在的文件名称。%L: 输出代码中的行号。%m: 输出代码中指定的消息,产生的日志具体信息。%n: 输出一个回车换行符，Windows平台为”\\r\\n”，Unix平台为”\\n”输出日志信息换行。可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。%20c：指定输出类名的名称，最小的宽度是20，如果类名的名称小于20的话，默认的情况下右对齐。%-20c:指定输出类名的名称，最小的宽度是20，如果类名的名称小于20的话，”-“号指定左对齐。%.30c:指定输出类名的名称，最大的宽度是30，如果类名的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。%20.30c:如果类名的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远处的字符截掉。 配置样例 log4j.rootLogger=DEBUG,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.conversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n #####org.apache.log4j.HTMLLayout ##六，使用logger的前提条件：首先 需要将commons-logging.jar和logging-log4j-1.2.9.jar导入到构建路径中。然后 再将log4j.properties放到src根目录下。这样就可以在程序中使用log4j了。 在类中使用log4j， 首先声明一个静态变量 private static Logger logger=Logger.getLog(“className”)；现在就可以使用了，用法如下：logger.debug(“debug message”)或者logger.info(“info message”) log4j加载配置文件的流程：如果没有设置log4j.configuration变量，则先尝试使用ClassPath下的log4j.xml文件，如果没有log4j.xml文件，则使用ClassPath下的log4j.properties文件。 第一，大部分情况下，把log4j.xml或者log4j.properties文件直接放到对应web应用的webapps/classes/文件夹下面即可。这种情况下，各个web应用会分别使用各自的配置文件来完成log4j的初始化。 第二，如果需要不用的应用使用统一的log4j配置，只需要单独的把log4j.properties文件或者log4j.xml文件放到一个指定的位置，并且使用环境变量log4j.configuration来完成配置文件的指定。注意，在log4j.configuration的值中，可以使用文件名称或者url的方式。但是如果直接使用文件名，使用的还是各个应用目录下的classes/文件夹中的配置文件。比如log4j.configuration=log4jconfig.properties，那么还是寻找的各个web app目录下的classes/中的log4jconfig.properties文件配置。 要想让所有的web app应用实例使用相同的配置文件，需要这样写：log4j.configuration=file:/c:/log4jconfig.xml那么所有的web app都会使用c:/log4jconfig.xml来完成log4j的配置了。 第三，注意，如果所有的web app实例都使用同一个log4j配置文件，那么，尽量不要使用FileAppender。因为这个日志文件会被所有的web app线程使用，容易造成极大的性能问题。 public class Logger { // 输出日志方法: public void debug(Object message); public void info(Object message); public void warn(Object message); public void error(Object message); public void fatal(Object message); // 输出带有错误的日志方法： public void debug(Object message, Throwable t); public void info(Object message, Throwable t); public void warn(Object message, Throwable t); public void error(Object message, Throwable t); public void fatal(Object message, Throwable t); // 更通用的输出日志方法: public void log(Level p, Object message); } ##七，logger的性能问题： 例如下面的logger cat程序段中： logger.debug(&quot;Entry number: &quot; + i + &quot; is &quot; + String.valueOf(entry[i])); 不管message被日志记录与否，构造message参数的开销还是有的，比如说， 把整数i 和数组entry[i]转化为String，连接中间字串。参数构造的这种开销可能很高，它依赖于所介入的参数数量有多少。 为了避免这种参数构造开销，把以上的代码段改写为： if(logger.isDebugEnabled() { logger.debug(&quot;Entry number: &quot; + i + &quot; is &quot; + String.valueOf(entry[i])); } 如果排错功能不被使用，就不会有参数构造上的开销。但是，另一方面，如果logger的排错功能被起用，就会有俩倍的开销用于评估logger是否被起用：一次是判断debugEnabled，一次是判断debug是否被启用。但这不是极重的负担，因为评估logger的时间只有整个log语句执行时间的1% ##八，logger配置的完整样例： # level:OFF ,FATAL ,ERROR ,WARN ,INFO ,DEBUG ,ALL log4j.rootLogger=DEBUG,Main,Console #close c3p0 log log4j.logger.com.mchange.v2=off #整个应用的日志文件输出到控制台 log4j.logger.java.sql=DEBUG,Console log4j.logger.com.ibatis=DEBUG,Console log4j.org.springframework.orm.ibatis=DEBUG,Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.target=System.out log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #整个应用的日志文件 log4j.logger.com.huawei.market.service.ConfigService= debug, Main log4j.additivity.com.huawei.market.service.ConfigService= false log4j.logger.com.huawei.market.service.MarketService= debug, Main log4j.additivity.com.huawei.market.service.MarketService= false log4j.logger.com.huawei.market.service.UserService= debug, Main log4j.additivity.com.huawei.market.service.UserService= false log4j.appender.Main=org.apache.log4j.RollingFileAppender log4j.appender.Main.file=../logs/main.log log4j.appender.Main.maxFileSize=5000KB log4j.appender.Main.maxBackupIndex=20 log4j.appender.Main.layout=org.apache.log4j.PatternLayout log4j.appender.Main.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #Sql语句日志文件 log4j.logger.com.huawei.market.service.dao=debug, Sql log4j.additivity.com.huawei.market.service.dao=false log4j.appender.Sql=org.apache.log4j.RollingFileAppender log4j.appender.Sql.file=../logs/sql.log log4j.appender.Sql.maxFileSize=5000KB log4j.appender.Sql.maxBackupIndex=20 log4j.appender.Sql.layout=org.apache.log4j.PatternLayout log4j.appender.Sql.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #短信日志文件 log4j.logger.com.huawei.market.sms=debug, Sms log4j.additivity.com.huawei.market.sms= false log4j.appender.Sms=org.apache.log4j.RollingFileAppender log4j.appender.Sms.file=../logs/sms.log log4j.appender.Sms.maxFileSize=10000KB log4j.appender.Sms.maxBackupIndex=200 log4j.appender.Sms.layout=org.apache.log4j.PatternLayout log4j.appender.Sms.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #ftp文件导入日志文件 log4j.logger.FtpAndImportLog=debug,ftpAndImport log4j.additivity.FtpAndImportLog=false log4j.logger.com.huawei.market.util.FTPUtil=debug, ftpAndImport log4j.additivity.com.huawei.market.util.FTPUtil=false log4j.appender.ftpAndImport=org.apache.log4j.RollingFileAppender log4j.appender.ftpAndImport.file=../logs/ftpAndImport.log log4j.appender.ftpAndImport.maxFileSize=5000KB log4j.appender.ftpAndImport.maxBackupIndex=20 log4j.appender.ftpAndImport.layout=org.apache.log4j.PatternLayout log4j.appender.ftpAndImport.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #鉴权Token日志文件 log4j.logger.AuthLog= debug, AuthToken log4j.additivity.AuthLog= false log4j.appender.AuthToken=org.apache.log4j.RollingFileAppender log4j.appender.AuthToken.file=../logs/auth.log log4j.appender.AuthToken.maxFileSize=5000KB log4j.appender.AuthToken.maxBackupIndex=20 log4j.appender.AuthToken.layout=org.apache.log4j.PatternLayout log4j.appender.AuthToken.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #应用的单元测试日志文件 log4j.logger.MarketJunit= info, MarketJunit log4j.additivity.MarketJunit= false log4j.appender.MarketJunit=org.apache.log4j.RollingFileAppender log4j.appender.MarketJunit.file=../logs/junit.log log4j.appender.MarketJunit.maxFileSize=5000KB log4j.appender.MarketJunit.maxBackupIndex=20 log4j.appender.MarketJunit.layout=org.apache.log4j.PatternLayout log4j.appender.MarketJunit.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #A1调查问卷日志文件 log4j.appender.A1=org.apache.log4j.RollingFileAppender log4j.appender.A1.file=../logs/questionnaire.log log4j.appender.A1.maxFileSize=5000KB log4j.appender.A1.maxBackupIndex=20 log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #A2日志文件 log4j.logger.market=DEBUG,A2 log4j.additivity.market = false log4j.appender.A2=org.apache.log4j.RollingFileAppender log4j.appender.A2.file=../logs/web/market.log log4j.appender.A2.maxFileSize=5000KB log4j.appender.A2.maxBackupIndex=20 log4j.appender.A2.layout=org.apache.log4j.PatternLayout log4j.appender.A2.layout.ConversionPattern=%-5p %d{yyyy-MM-dd HH:mm:ss} %l%n%m%n #A3统计登录日志文件 log4j.logger.marketlogin=DEBUG,A3 log4j.additivity.marketlogin = false log4j.appender.A3=org.apache.log4j.RollingFileAppender log4j.appender.A3.file=../logs/web/marketlogin.log log4j.appender.A3.maxFileSize=5000KB log4j.appender.A3.maxBackupIndex=20 log4j.appender.A3.layout=org.apache.log4j.PatternLayout log4j.appender.A3.layout.ConversionPattern=%-5p %d{yyyy-MM-dd HH:mm:ss} %l%n%m%n #A4统计PV日志文件 log4j.logger.PVSTATISTIC=DEBUG,A4 log4j.additivity.PVSTATISTIC=false log4j.appender.A4=org.apache.log4j.DailyRollingFileAppender log4j.appender.A4.file=../logs/web/accesslog_tomcat_market log4j.appender.A4.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos; log4j.appender.A4.layout=org.apache.log4j.PatternLayout log4j.appender.A4.layout.ConversionPattern=%m%n #A5统计url请求次数的日志文件 log4j.logger.URLSTATISTIC=DEBUG,A5 log4j.additivity.URLSTATISTIC=false log4j.appender.A5=org.apache.log4j.DailyRollingFileAppender log4j.appender.A5.file=../logs/web/requesturllog_tomcat_market log4j.appender.A5.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos; log4j.appender.A5.layout=org.apache.log4j.PatternLayout log4j.appender.A5.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #DailyQuest log log4j.logger.com.huawei.market.service.DailyQuestService= info, DailyQuest log4j.additivity.com.huawei.market.service.DailyQuestService= false log4j.appender.DailyQuest=org.apache.log4j.RollingFileAppender log4j.appender.DailyQuest.file=../logs/DailyQuest.log log4j.appender.DailyQuest.maxFileSize=5000KB log4j.appender.DailyQuest.maxBackupIndex=20 log4j.appender.DailyQuest.layout=org.apache.log4j.PatternLayout log4j.appender.DailyQuest.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n #caiyunApplyFail log4j.appender.caiyunApplyFail=org.apache.log4j.DailyRollingFileAppender log4j.appender.caiyunApplyFail.file=../logs/caiyunApplyFail.log log4j.appender.caiyunApplyFail.Append=true log4j.appender.caiyunApplyFail.Threshold=INFO log4j.appender.caiyunApplyFail.DatePattern=&apos;.&apos;yyyy-MM-dd log4j.appender.caiyunApplyFail.layout=org.apache.log4j.PatternLayout log4j.appender.caiyunApplyFail.layout.ConversionPattern=%m%n #TRACE log4j.logger.TRACE = INFO,TRACE log4j.additivity.TRACE = false log4j.appender.TRACE=org.apache.log4j.DailyRollingFileAppender log4j.appender.TRACE.file=../logs/mrp-trace.log log4j.appender.TRACE.Append=true log4j.appender.TRACE.Threshold=INFO log4j.appender.TRACE.DatePattern=&apos;.&apos;yyyy-MM-dd log4j.appender.TRACE.layout=org.apache.log4j.PatternLayout log4j.appender.TRACE.layout.ConversionPattern=[%d{yyyy-MM-dd HH:mm:ss}]%m%n #DIGEST log4j.logger.DIGEST = INFO,DIGEST log4j.additivity.DIGEST = false log4j.appender.DIGEST=org.apache.log4j.DailyRollingFileAppender log4j.appender.DIGEST.file=../logs/mrp-digest.log log4j.appender.DIGEST.Append=true log4j.appender.DIGEST.Threshold=INFO log4j.appender.DIGEST.DatePattern=&apos;.&apos;yyyy-MM-dd log4j.appender.DIGEST.layout=org.apache.log4j.PatternLayout log4j.appender.DIGEST.layout.ConversionPattern=[%d{yyyy-MM-dd HH:mm:ss}]%m%n #task log4j.logger.task=INFO,task log4j.additivity.task = false log4j.appender.task=org.apache.log4j.RollingFileAppender log4j.appender.task.file=../logs/task.log log4j.appender.task.maxFileSize=5000KB log4j.appender.task.maxBackupIndex=20 log4j.appender.task.layout=org.apache.log4j.PatternLayout log4j.appender.task.layout.ConversionPattern=%p %d{yyyy-MM-dd HH:mm:ss} %t %c.%M - %m%n","categories":[{"name":"log","slug":"log","permalink":"https://lbvs86823.github.io/categories/log/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"https://lbvs86823.github.io/tags/log4j/"}],"keywords":[{"name":"log","slug":"log","permalink":"https://lbvs86823.github.io/categories/log/"}]},{"title":"commons-logging 和 log4j 之间的关系","slug":"log/common-logging","date":"2010-05-13T10:31:54.000Z","updated":"2020-03-20T06:27:43.652Z","comments":true,"path":"2010/05/13/log/common-logging/","link":"","permalink":"https://lbvs86823.github.io/2010/05/13/log/common-logging/","excerpt":"","text":"一，前言：我们在做项目时，日志的记录是必不可少的一项任务，而我们通常是使用 apache 的 log4j 日志管理工具。然而，在项目中，我们经常会看到两个 jar 包：commons-logging.jar 和 log4j.rar。为什么我们在使用 log4j 的同时还要引入 commons-logging.jar 呢，或者说不用 commons-logging.jar 可不可以，这两者之间到底是怎么的一种关系呢？ 作为记录日志的工具，它至少应该包含如下几个组成部分(组件)： Logger记录器组件负责产生日志，并能够对日志信息进行分类筛选，控制什么样的日志应该被输出，什么样的日志应该被忽略。它还有一个重要的属性－日志级别。 Level日志级别组件,不管何种日志记录工具，大概包含了如下几种日志级别：DEBUG, INFO, WARN, ERROR 和 FATAL。 Appender日志记录工具基本上通过 Appender 组件来输出到目的地的，一个 Appender 实例就表示了一个输出的目的地。 LayoutLayout 组件负责格式化输出的日志信息，一个 Appender 只能有一个 Layout。 ##二，common-logging 源码解析接下来看看 commons-logging 中的 org.apache.commons.logging.Log.java 源码： package org.apache.commons.logging; public interface Log { public boolean isDebugEnabled(); public boolean isErrorEnabled(); public boolean isFatalEnabled(); public boolean isInfoEnabled(); public boolean isTraceEnabled(); public boolean isWarnEnabled(); public void trace(Object message); public void trace(Object message, Throwable t); public void debug(Object message); public void debug(Object message, Throwable t); public void info(Object message); public void info(Object message, Throwable t); public void warn(Object message); public void warn(Object message, Throwable t); public void error(Object message); public void error(Object message, Throwable t); public void fatal(Object message); public void fatal(Object message, Throwable t); } 很显然，只要实现了 Log 接口，它就是一个名副其实的 Logger 组件，也验证了 Logger 组件具有日志级别的属性。 继续看 commons-logging org.apache.commons.logging.impl 包下的几个类的源码片段： --------org.apache.commons.logging.impl.Log4JLogger实现类-------- package org.apache.commons.logging.impl; import org.apache.commons.logging.Log; import org.apache.log4j.Logger; import org.apache.log4j.Priority; import org.apache.log4j.Level; import ...... public class Log4JLogger implements Log, Serializable { // 对 org.apache.commons.logging.Log 的实现 ...... } --------org.apache.commons.logging.impl.Jdk14Logger实现类-------- package org.apache.commons.logging.impl; import org.apache.commons.logging.Log; import java.io.Serializable; import java.util.logging.Level; import java.util.logging.Logger; import ...... public class Jdk14Logger implements Log, Serializable { // 对 org.apache.commons.logging.Log 的实现 ...... } 好了，分析到这里，我们应该知道，真正的记录日志的工具是 log4j 和 sun 公司提供的日志工具。而 commons-logging 把这两个(实际上，在 org.apache.commons.logging.impl 包下，commons-logging 仅仅为我们封装了 log4j 和 sun logger)记录日志的工具重新封装了一遍(Log4JLogger.java 和 Jdk14Logger.java)，可以认为 org.apache.commons.logging.Log 是个傀儡，它只是提供了对外的统一接口。因此我们只要能拿到 org.apache.commons.logging.Log，而不用关注到底使用的是 log4j 还是 sun logger。 正如我们经常在项目中这样写： // Run 是我们自己写的类，LogFactory 是一个专为提供 Log 的工厂(abstract class) private static final Log logger = LogFactory.getLog(Run.class); 既然如此，我们向构建路径加了 commons-logging.jar 和 log4j.jar 两个 jar 包，那我们的应用程序到底使用的 log4j 还是 sun logger 呢？我们能不能认为由于加了 log4j.jar 包，就认为系统使用的就是 log4j 呢？事实上当然不是这样的，那我还认为我正在使用 jdk 而认为系统使用的是 sun logger 呢! 使用 Spring 的朋友可以在 web.xml 中看到如下 listener 片段： &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; 这是由 Spring 为我们提供的实现了标准的 servlet api 中的 javax.servlet.ServletContextListener 接口，用于在 web 容器启动时做一些初始化操作。我们逐层进入 Spring 的源码，可以看到如下代码： Log4jConfigurer.initLogging(location, refreshInterval); 终于找到了 org.springframework.util.Log4jConfigurer，这正是 log4j 提供给我们的初始化日志的类。至此，我们终于明白了我们系统的的确确使用的是 log4j 的日志工具。 可是问题又来了，org.apache.commons.logging.Log 和 org.apache.log4j.Logger 这两个类，通过包名我们可以发现它们都是 apache 的项目，既然如下，为何要动如此大的动作搞两个东西(指的是 commons-logging 和 log4j)出来呢？事实上，在 sun 开发 logger 前，apache 项目已经开发了功能强大的 log4j 日志工具，并向 sun 推荐将其纳入到 jdk 的一部分，可是 sun 拒绝了 apache 的提议，sun 后来自己开发了一套记录日志的工具。可是现在的开源项目都使用的是 log4j，log4j 已经成了事实上的标准，但由于又有一部分开发者在使用 sun logger，因此 apache 才推出 commons-logging，使得我们不必关注我们正在使用何种日志工具。","categories":[{"name":"log","slug":"log","permalink":"https://lbvs86823.github.io/categories/log/"}],"tags":[{"name":"common-logging","slug":"common-logging","permalink":"https://lbvs86823.github.io/tags/common-logging/"},{"name":"log4j","slug":"log4j","permalink":"https://lbvs86823.github.io/tags/log4j/"}],"keywords":[{"name":"log","slug":"log","permalink":"https://lbvs86823.github.io/categories/log/"}]},{"title":"linux 查看版本","slug":"linux/linux_version","date":"2010-05-09T05:11:45.000Z","updated":"2020-03-20T06:27:43.649Z","comments":true,"path":"2010/05/09/linux/linux_version/","link":"","permalink":"https://lbvs86823.github.io/2010/05/09/linux/linux_version/","excerpt":"","text":"通用命令# lsb_release -a LSB Version: :core-3.1-ia32:core-3.1-noarch:graphics-3.1-ia32:graphics-3.1-noarch Distributor ID: CentOS Description: CentOS release 5.4 (Final) Release: 5.4 Codename: Final 这个命令适用于所有的linux，包括Redhat、SuSE、Debian、Centos等发行版。 利用uname显示系统信息# uname -a Linux localhost.localdomain 2.6.18-194.el5 #1 SMP Fri Apr 2 14:58:35 EDT 2010 i686 i686 i386 GNU/Linux linux 各种版本的查看方式适用于RedHat,CentOS# cat /etc/redhat-release CentOS release 5.4 (Final) # cat /proc/version # Ubuntu 也适用 Linux version 2.6.9-78.ELsmp (mockbuild@builder16.centos.org) (gcc version 3.4.6 20060404 (Red Hat 3.4.6-10)) #1 SMP Fri Jul 25 00:04:28 EDT 2008 # rpm -q redhat-release # 适用于redhat # rpm -q centos-release # 适用于centos","categories":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}]},{"title":"Markdown 语法说明","slug":"tools/markdown","date":"2010-04-25T04:08:20.000Z","updated":"2020-03-20T06:27:43.683Z","comments":true,"path":"2010/04/25/tools/markdown/","link":"","permalink":"https://lbvs86823.github.io/2010/04/25/tools/markdown/","excerpt":"","text":"1.标题：Markdown 支持两种标题的语法，类 Setext 和类 atx 形式: (1)类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题）。 (2)类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 2.段落和换行：一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行 3.区块引用:(1)Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; (2)Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; (3)区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 4.代码区块：和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块： (1)Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 (2)只要简单地缩进 4 个空格或是 1 个制表符就可以。 5.列表:Markdown 支持有序列表和无序列表: (1)无序列表使用星号、加号或是减号作为列表标记。 (2)有序列表则使用数字接着一个英文句点和空格。。 6.分隔线:在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 7.链接:Markdown 支持两种形式的链接语法： 行内式和参考式两种形式: (1)不管是哪一种，链接文字都是用 [方括号] 来标记。 (2)要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的title 文字，只要在网址后面，用双引号把 title 文字包起来即可)。 (3)参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记。 8.图片:Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字。 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &apos;title&apos; 文字。 或者参考式的图片语法则长得像这样：![Alt text][id] 9.强调：(1)Markdown 使用星号（*）和底线（_）作为标记强调字词的符号。 (2)被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;。 (3)如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 10.代码:(1)如果要标记一小段行内代码，你可以用反引号把它包起来（`）。 11.自动链接：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱。 只要是用尖括号包起来，Markdown 就会自动把它转成链接。 12.反斜杠:Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号, Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 13.特殊字符自动转换:在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。&lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp; Markdown 让你可以自然地书写字符，需要转换的由它来处理。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp; 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体。","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://lbvs86823.github.io/tags/blog/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lbvs86823.github.io/tags/Markdown/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"采用Jekyll “增强版” 写博客","slug":"tools/blog02","date":"2010-04-18T02:23:39.000Z","updated":"2020-03-20T06:27:43.680Z","comments":true,"path":"2010/04/18/tools/blog02/","link":"","permalink":"https://lbvs86823.github.io/2010/04/18/tools/blog02/","excerpt":"","text":"一，首先在你自己的 gitHub 上面创建一个新的仓库仓库名称： userName.github.com (userName 指的是你的账户ID) 二，安装Jekyll-Bootstrap打开你的终端，cd 到你希望创建一个博客项目的地方(比如：我放在 /Users/admin/Documents下)： $ git clone https://github.com/plusjade/jekyll-bootstrap.git userName.github.com$ cd userName.github.com$ git remote set-url origin git@github.com:userName/userName.github.com.git$ git push origin master 三，测试安装Jekyll-Bootstrap是否成功经过上面的2个步骤之后，实际上你只需等待几分钟，就可以点击这里http://userName.github.com 看到你自己使用Jekyll-Bootstrap部署的博客啦。 那如何在本地运行自己的博客系统呢？只要你本地安装了jekyll，那很简单了，进入自己的博客目录下：$ cd userName.github.com$ jekyll serve 在自己的浏览器中输入：http://127.0.0.1:4000/ 就可以看到博客内容主页啦。 四，创建一篇新的博客实际上通过一个rake命令来创建是非常容易的事情，它自动给你的文件名加上了符合JeKyll规范的日期为当天并且按照YAML 进行了格式化，你只需要指定博客的标题就OK了，如果存在重名的博客，它是不会覆盖的，除非你进行明确指定要覆盖。命令格式如下：$ rake post title = &quot;Hello world&quot;不出意外，你可以在当前目录下已经产生了如下文件 ./_posts/2014-03-01-hello-world.md 五，创建一个独立的页面同样是通过rake命令来完成，命令格式化如下：$ rake page name = “about.md”你可以在当前目录下已经产生了如下文件： ./about.md如果已经存在时，一般会创建一个 ./new-page.md 文件 创建一个嵌套的Page页：$ rake page name = &quot;pages/about.md&quot;你可以在当前目录下已经产生了如下文件： ./pages/about.md 用一个路径创建一个page页：$ rake page name = &quot;pages/about&quot;你可以在当前目录下已经产生了如下文件： ./pages/about/index.html ####六，发布新创建的博客到gitHub上面去$ git add .$ git commit -m &quot;提交我刚刚新写的博客啦&quot;$ git push origin master 通过上面的几行命令，gitHub会自动的部署你改变过的博客到它的主机上面。 七，定制博客Jekyll-Bootstrap 被作为一个博客平台使用，自然可以进行深度的客户化定制啦。 主题配置： 1. 在线安装：Jekyll-Bootstrap 使用 rake tasks来实现主题的安装，那么我们到哪里去找这些主题呢？其实我们可以在 这里 在线选择你喜欢的主题，然后点击左下角的 “Install Theme“ 就会再弹出框中显示安装命令，复制到命令行执行即可。比如在你的本地博客目录下面运行以下命令： $ rake theme:install git=&quot;git://github.com/sodabrew/theme-dinky.git&quot; 等待下载安装成功后，命令行会提示你是否要(Y/N)切换到新的主题，你直接回复 “Y” 回车， 这个时候就会提示你安装成功了，让你重启jekyll一切就OK了。 2. 本地安装：首先下载主题包的 themeName.zip 文件，然后放到你的博客目录下的 ./_theme_packages 文件夹下面，让后在博客目录下面运行如下命令进行安装： $ rake theme:install name=&quot;themeName&quot; (注意=号两边不要有空格) 3. 切换主题： 你只要知道主题的名字，你就可以用下面的命令随意的切换主题啦： $ rake theme:switch name=&quot;themeNewName&quot; (themeNewName 为你要切换的主题名字) 4. 自定义主题： 一般主题的布局文件都放在博客系统的 ./_includes/themes/themeName 下面， 然而这些主题的静态资源文件却全部放在 ./assets/themes/themeName 下面； 你可以手动修改这些文件，在你切换主题的时候，它们就会自动的覆盖到 ./_layouts 目录下面进行应用了。 至于你要自己完全编写一套主题，你可以参考这里 博客配置：对于博客的配置一般都放在 ./_config.yml 文件中，下面介绍一些常用的配置项： 1. 自己写的博客的永久链接地址格式的配置： 默认：permalink: /:categories/:year/:month/:day/:title/ 2. 博客系统的根路径配置： BASE_PATH,所有博客的链接都要靠它来定义命名空间，你站点的链接一般都以以这个BASE_PATH的值作为前缀的。但是当你部署到github上面时，情况就有所变化：如果你是以个人主页的方式部署，那么你不用设置BASE_PATH，系统默认以“/” 作为前缀(包括你设置了CNAME的情况都是这样)；如果你是以项目主页的方式部署，那么假如你的项目路径为：http://username.github.io/project-name， 那么你的BASE_PATH必须要设置为: http://username.github.io/project-name；如果你是在本地运行，那么系统会默认以“/”为前缀，忽略BASE_PATH的设置；BASE_PATH的设置必须以http或者https协议打头，否则就只能以“/”打头了。 3. 博客系统的评论配置： Jekyll-Bootstrap 里面已经配置了一些国外的评论插件，比如：Disqus, Intense Debate, livefyre, Facebook Comments; 国内的嘛，比如：友言, 评论啦 (不过貌似被前者给兼并了), 贝米, 多说 不过国内的这些评论系统貌似都支持的不是很好，不过可以将就着用吧。 由于在天朝，国外的评论系统一般用的比较少，所以我们需要自定义一个国内的评论系统提供商，所以就拿 多说 评论系统为例配置一个自定义的评论系统。首先你要到 多说 官网登陆获取评论系统的模板代码(比如我获取的) ： 然后在你的配置文件中找到如下字样： comments : provider : disqus 将 provider 提供商改成自定义(provider :custom)提供商, 下一步就在你的博客系统中创建一个如下路径的文件：./_includes/custom/comments 将多说博客系统的模板代码粘贴在上面的文件中保存。重启服务就可看到多说的评论插件已经安装OK啦。 4. 博客系统的pv/uv统计配置：","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://lbvs86823.github.io/tags/Jekyll/"},{"name":"blog","slug":"blog","permalink":"https://lbvs86823.github.io/tags/blog/"},{"name":"Jekyll-Bootstrap","slug":"Jekyll-Bootstrap","permalink":"https://lbvs86823.github.io/tags/Jekyll-Bootstrap/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"怎么写自己的博客","slug":"tools/blog01","date":"2010-04-17T04:13:29.000Z","updated":"2020-03-20T06:27:43.679Z","comments":true,"path":"2010/04/17/tools/blog01/","link":"","permalink":"https://lbvs86823.github.io/2010/04/17/tools/blog01/","excerpt":"","text":"一，首先在你自己的 gitHub 上面创建一个新的仓库仓库名称： userName.github.com (userName 指的是你的账户ID) 二，安装Jekyll安装Jekyll之前，你的电脑需要具备以下的条件： 首先你的系统必须要是Linux or Unix or Mac OSX 其中的任何一种。 (当然，jekyll也是可以在windows下面跑起来的，不过比较麻烦，你可以参考这里 ) 系统上面必须要先安装Ruby (因为Jekyll是采用Ruby开发的) 系统还必须安装RubyGems （Ruby平台上面的软件管理工具） 打开你的终端，cd 到你希望创建一个博客项目的地方(比如：我放在 /Users/admin/Documents下)：$ git clone https://github.com/plusjade/jekyll-bootstrap.git userName.github.com$ cd userName.github.com$ git remote set-url origin git@github.com:userName/userName.github.com.git$ git push origin master","categories":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://lbvs86823.github.io/tags/Jekyll/"},{"name":"blog","slug":"blog","permalink":"https://lbvs86823.github.io/tags/blog/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://lbvs86823.github.io/categories/tools/"}]},{"title":"linux 防火墙管理","slug":"linux/linux_firewall","date":"2010-03-09T02:12:45.000Z","updated":"2021-04-25T07:46:57.281Z","comments":true,"path":"2010/03/09/linux/linux_firewall/","link":"","permalink":"https://lbvs86823.github.io/2010/03/09/linux/linux_firewall/","excerpt":"","text":"Centos7 防火墙管理1、开放端口firewall-cmd --zone=public --add-port=5672/tcp --permanent # 开放5672端口 firewall-cmd --zone=public --remove-port=5672/tcp --permanent #关闭5672端口 firewall-cmd --reload # 配置立即生效 这个命令适用于所有的linux，包括Redhat、SuSE、Debian、Centos等发行版。 2、查看防火墙所有开放的端口firewall-cmd --zone=public --list-ports 3、关闭防火墙systemctl stop firewalld.service 4、查看防火墙状态firewall-cmd --state 4、查看系统监听端口netstat -lnpt centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools","categories":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://lbvs86823.github.io/categories/linux/"}]}]}